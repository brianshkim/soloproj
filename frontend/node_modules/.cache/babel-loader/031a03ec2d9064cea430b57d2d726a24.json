{"ast":null,"code":"\"use strict\";\n\nconst Deferred = require(\"./Deferred\");\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @class\n * @param {Object} factory\n *   Factory to be used for generating and destroying the items.\n * @param {String} [factory.name]\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use).\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} [factory.idleTimeoutMillis=30000]\n *   Delay in milliseconds after which available resources in the pool will be destroyed.\n *   This does not affects pending acquire requests.\n * @param {Number} [factory.acquireTimeoutMillis=30000]\n *   Delay in milliseconds after which pending acquire request in the pool will be rejected.\n *   Pending acquires are acquire calls which are yet to receive an response from factory.create\n * @param {Number} [factory.reapIntervalMillis=1000]\n *   Clean up is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} [factory.log=false]\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n */\n\n\nclass Pool {\n  constructor(factory) {\n    if (!factory.create) {\n      throw new Error(\"create function is required\");\n    }\n\n    if (!factory.destroy) {\n      throw new Error(\"destroy function is required\");\n    }\n\n    if (!factory.validate) {\n      throw new Error(\"validate function is required\");\n    }\n\n    if (typeof factory.min !== \"number\" || factory.min < 0 || factory.min !== Math.round(factory.min)) {\n      throw new Error(\"min must be an integer >= 0\");\n    }\n\n    if (typeof factory.max !== \"number\" || factory.max <= 0 || factory.max !== Math.round(factory.max)) {\n      throw new Error(\"max must be an integer > 0\");\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error(\"max is smaller than min\");\n    } // defaults\n\n\n    factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    factory.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    factory.reapInterval = factory.reapIntervalMillis || 1000;\n    factory.max = parseInt(factory.max, 10);\n    factory.min = parseInt(factory.min, 10);\n    factory.log = factory.log || false;\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false; // queues\n\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = []; // timing controls\n\n    this._removeIdleTimer = null;\n    this._removeIdleScheduled = false;\n  }\n\n  get size() {\n    return this._count;\n  }\n\n  get name() {\n    return this._factory.name;\n  }\n\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  get using() {\n    return this._inUseObjects.length;\n  }\n\n  get waiting() {\n    return this._pendingAcquires.length;\n  }\n\n  get maxSize() {\n    return this._factory.max;\n  }\n\n  get minSize() {\n    return this._factory.min;\n  }\n  /**\n   * logs to console or user defined log function\n   * @private\n   * @param {string} message\n   * @param {string} level\n   */\n\n\n  _log(message, level) {\n    if (typeof this._factory.log === \"function\") {\n      this._factory.log(message, level);\n    } else if (this._factory.log) {\n      console.log(`${level.toUpperCase()} pool ${this.name} - ${message}`);\n    }\n  }\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   * @private\n   */\n\n\n  _removeIdle() {\n    const toRemove = [];\n    const now = Date.now();\n    let i;\n    let available = this._availableObjects.length;\n    const maxRemovable = this._count - this._factory.min;\n    let timeout;\n    this._removeIdleScheduled = false; // Go through the available (idle) items,\n    // check if they have timed out\n\n    for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n      timeout = this._availableObjects[i].timeout;\n\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        this._log(\"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout, \"verbose\");\n\n        toRemove.push(this._availableObjects[i].resource);\n      }\n    }\n\n    toRemove.forEach(this.destroy, this); // NOTE: we are re-calculating this value because it may have changed\n    // after destroying items above\n    // Replace the available items with the ones to keep.\n\n    available = this._availableObjects.length;\n\n    if (available > 0) {\n      this._log(\"this._availableObjects.length=\" + available, \"verbose\");\n\n      this._scheduleRemoveIdle();\n    } else {\n      this._log(\"removeIdle() all objects removed\", \"verbose\");\n    }\n  }\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n\n\n  _scheduleRemoveIdle() {\n    if (!this._removeIdleScheduled) {\n      this._removeIdleScheduled = true;\n      this._removeIdleTimer = setTimeout(() => {\n        this._removeIdle();\n      }, this._factory.reapInterval);\n    }\n  }\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, pop the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   * @private\n   */\n\n\n  _dispense() {\n    let resourceWithTimeout = null;\n    const waitingCount = this._pendingAcquires.length;\n\n    this._log(`dispense() clients=${waitingCount} available=${this._availableObjects.length}`, \"info\");\n\n    if (waitingCount < 1) {\n      return;\n    }\n\n    while (this._availableObjects.length > 0) {\n      this._log(\"dispense() - reusing obj\", \"verbose\");\n\n      resourceWithTimeout = this._availableObjects[this._availableObjects.length - 1];\n\n      if (!this._factory.validate(resourceWithTimeout.resource)) {\n        this.destroy(resourceWithTimeout.resource);\n        continue;\n      }\n\n      this._availableObjects.pop();\n\n      this._inUseObjects.push(resourceWithTimeout.resource);\n\n      const deferred = this._pendingAcquires.shift();\n\n      return deferred.resolve(resourceWithTimeout.resource);\n    }\n\n    if (this._count < this._factory.max) {\n      this._createResource();\n    }\n  }\n  /**\n   * @private\n   */\n\n\n  _createResource() {\n    this._count += 1;\n\n    this._log(`createResource() - creating obj - count=${this._count} min=${this._factory.min} max=${this._factory.max}`, \"verbose\");\n\n    this._factory.create().then(resource => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._inUseObjects.push(resource);\n\n      if (deferred) {\n        deferred.resolve(resource);\n      } else {\n        this._addResourceToAvailableObjects(resource);\n      }\n    }).catch(error => {\n      const deferred = this._pendingAcquires.shift();\n\n      this._count -= 1;\n      if (this._count < 0) this._count = 0;\n\n      if (deferred) {\n        deferred.reject(error);\n      }\n\n      process.nextTick(() => {\n        this._dispense();\n      });\n    });\n  }\n\n  _addResourceToAvailableObjects(resource) {\n    const resourceWithTimeout = {\n      resource: resource,\n      timeout: Date.now() + this._factory.idleTimeoutMillis\n    };\n\n    this._availableObjects.push(resourceWithTimeout);\n\n    this._dispense();\n\n    this._scheduleRemoveIdle();\n  }\n  /**\n   * @private\n   */\n\n\n  _ensureMinimum() {\n    let i, diff;\n\n    if (!this._draining && this._count < this._factory.min) {\n      diff = this._factory.min - this._count;\n\n      for (i = 0; i < diff; i++) {\n        this._createResource();\n      }\n    }\n  }\n  /**\n   * Requests a new resource. This will call factory.create to request new resource.\n   *\n   * It will be rejected with timeout error if `factory.create` didn't respond\n   * back within specified `acquireTimeoutMillis`\n   *\n   * @returns {Promise<Object>}\n   */\n\n\n  acquire() {\n    if (this._draining) {\n      return Promise.reject(new Error(\"pool is draining and cannot accept work\"));\n    }\n\n    const deferred = new Deferred();\n    deferred.registerTimeout(this._factory.acquireTimeoutMillis, () => {\n      // timeout triggered, promise will be rejected\n      // remove this object from pending list\n      this._pendingAcquires = this._pendingAcquires.filter(pending => pending !== deferred);\n    });\n\n    this._pendingAcquires.push(deferred);\n\n    this._dispense();\n\n    return deferred.promise();\n  }\n  /**\n   * Return the resource to the pool, in case it is no longer required.\n   *\n   * @param {Object} resource The acquired object to be put back to the pool.\n   *\n   * @returns {void}\n   */\n\n\n  release(resource) {\n    // check to see if this object has already been released\n    // (i.e., is back in the pool of this._availableObjects)\n    if (this._availableObjects.some(resourceWithTimeout => resourceWithTimeout.resource === resource)) {\n      this._log(\"release called twice for the same resource: \" + new Error().stack, \"error\");\n\n      return;\n    } // check to see if this object exists in the `in use` list and remove it\n\n\n    const index = this._inUseObjects.indexOf(resource);\n\n    if (index < 0) {\n      this._log(\"attempt to release an invalid resource: \" + new Error().stack, \"error\");\n\n      return;\n    }\n\n    this._inUseObjects.splice(index, 1);\n\n    this._addResourceToAvailableObjects(resource);\n  }\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource The acquired item to be destroyed.\n   *\n   * @returns {void}\n   */\n\n\n  destroy(resource) {\n    const available = this._availableObjects.length;\n    const using = this._inUseObjects.length;\n    this._availableObjects = this._availableObjects.filter(object => object.resource !== resource);\n    this._inUseObjects = this._inUseObjects.filter(object => object !== resource); // resource was not removed, then no need to decrement _count\n\n    if (available === this._availableObjects.length && using === this._inUseObjects.length) {\n      this._ensureMinimum();\n\n      return;\n    }\n\n    this._count -= 1;\n    if (this._count < 0) this._count = 0;\n\n    this._factory.destroy(resource);\n\n    this._ensureMinimum();\n  }\n  /**\n   * Disallow any new requests and let the request backlog dissipate.\n   *\n   * @returns {Promise}\n   */\n\n\n  drain() {\n    this._log(\"draining\", \"info\"); // disable the ability to put more work on the queue.\n\n\n    this._draining = true;\n\n    const check = callback => {\n      // wait until all client requests have been satisfied.\n      if (this._pendingAcquires.length > 0) {\n        // pool is draining so we wont accept new acquires but\n        // we need to clear pending acquires\n        this._dispense();\n\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      } // wait until in use object have been released.\n\n\n      if (this._availableObjects.length !== this._count) {\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      }\n\n      callback();\n    }; // No error handling needed here.\n\n\n    return new Promise(resolve => check(resolve));\n  }\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @returns {Promise}\n   */\n\n\n  destroyAllNow() {\n    this._log(\"force destroying all objects\", \"info\");\n\n    const willDie = this._availableObjects.slice();\n\n    const todo = willDie.length;\n    this._removeIdleScheduled = false;\n    clearTimeout(this._removeIdleTimer);\n    return new Promise(resolve => {\n      if (todo === 0) {\n        return resolve();\n      }\n\n      let resource;\n      let done = 0;\n\n      while (resource = willDie.shift()) {\n        this.destroy(resource.resource);\n        ++done;\n\n        if (done === todo && resolve) {\n          return resolve();\n        }\n      }\n    });\n  }\n\n}\n\nexports.Pool = Pool;\nexports.default = Pool;\nexports.TimeoutError = require(\"./TimeoutError\").TimeoutError;","map":{"version":3,"names":["Deferred","require","Pool","constructor","factory","create","Error","destroy","validate","min","Math","round","max","idleTimeoutMillis","acquireTimeoutMillis","reapInterval","reapIntervalMillis","parseInt","log","_factory","_count","_draining","_pendingAcquires","_inUseObjects","_availableObjects","_removeIdleTimer","_removeIdleScheduled","size","name","available","length","using","waiting","maxSize","minSize","_log","message","level","console","toUpperCase","_removeIdle","toRemove","now","Date","i","maxRemovable","timeout","push","resource","forEach","_scheduleRemoveIdle","setTimeout","_dispense","resourceWithTimeout","waitingCount","pop","deferred","shift","resolve","_createResource","then","_addResourceToAvailableObjects","catch","error","reject","process","nextTick","_ensureMinimum","diff","acquire","Promise","registerTimeout","filter","pending","promise","release","some","stack","index","indexOf","splice","object","drain","check","callback","destroyAllNow","willDie","slice","todo","clearTimeout","done","exports","default","TimeoutError"],"sources":["/home/brian/node_modules/sequelize-pool/lib/Pool.js"],"sourcesContent":["\"use strict\";\n\nconst Deferred = require(\"./Deferred\");\n\n/**\n * Generate an Object pool with a specified `factory`.\n *\n * @class\n * @param {Object} factory\n *   Factory to be used for generating and destroying the items.\n * @param {String} [factory.name]\n *   Name of the factory. Serves only logging purposes.\n * @param {Function} factory.create\n *   Should create the item to be acquired,\n *   and call it's first callback argument with the generated item as it's argument.\n * @param {Function} factory.destroy\n *   Should gently close any resources that the item is using.\n *   Called before the items is destroyed.\n * @param {Function} factory.validate\n *   Should return true if connection is still valid and false\n *   If it should be removed from pool. Called before item is\n *   acquired from pool.\n * @param {Number} factory.max\n *   Maximum number of items that can exist at the same time.\n *   Any further acquire requests will be pushed to the waiting list.\n * @param {Number} factory.min\n *   Minimum number of items in pool (including in-use).\n *   When the pool is created, or a resource destroyed, this minimum will\n *   be checked. If the pool resource count is below the minimum, a new\n *   resource will be created and added to the pool.\n * @param {Number} [factory.idleTimeoutMillis=30000]\n *   Delay in milliseconds after which available resources in the pool will be destroyed.\n *   This does not affects pending acquire requests.\n * @param {Number} [factory.acquireTimeoutMillis=30000]\n *   Delay in milliseconds after which pending acquire request in the pool will be rejected.\n *   Pending acquires are acquire calls which are yet to receive an response from factory.create\n * @param {Number} [factory.reapIntervalMillis=1000]\n *   Clean up is scheduled in every `factory.reapIntervalMillis` milliseconds.\n * @param {Boolean|Function} [factory.log=false]\n *   Whether the pool should log activity. If function is specified,\n *   that will be used instead. The function expects the arguments msg, loglevel\n */\nclass Pool {\n  constructor(factory) {\n    if (!factory.create) {\n      throw new Error(\"create function is required\");\n    }\n\n    if (!factory.destroy) {\n      throw new Error(\"destroy function is required\");\n    }\n\n    if (!factory.validate) {\n      throw new Error(\"validate function is required\");\n    }\n\n    if (\n      typeof factory.min !== \"number\" ||\n      factory.min < 0 ||\n      factory.min !== Math.round(factory.min)\n    ) {\n      throw new Error(\"min must be an integer >= 0\");\n    }\n\n    if (\n      typeof factory.max !== \"number\" ||\n      factory.max <= 0 ||\n      factory.max !== Math.round(factory.max)\n    ) {\n      throw new Error(\"max must be an integer > 0\");\n    }\n\n    if (factory.min > factory.max) {\n      throw new Error(\"max is smaller than min\");\n    }\n\n    // defaults\n    factory.idleTimeoutMillis = factory.idleTimeoutMillis || 30000;\n    factory.acquireTimeoutMillis = factory.acquireTimeoutMillis || 30000;\n    factory.reapInterval = factory.reapIntervalMillis || 1000;\n    factory.max = parseInt(factory.max, 10);\n    factory.min = parseInt(factory.min, 10);\n    factory.log = factory.log || false;\n\n    this._factory = factory;\n    this._count = 0;\n    this._draining = false;\n\n    // queues\n    this._pendingAcquires = [];\n    this._inUseObjects = [];\n    this._availableObjects = [];\n\n    // timing controls\n    this._removeIdleTimer = null;\n    this._removeIdleScheduled = false;\n  }\n\n  get size() {\n    return this._count;\n  }\n\n  get name() {\n    return this._factory.name;\n  }\n\n  get available() {\n    return this._availableObjects.length;\n  }\n\n  get using() {\n    return this._inUseObjects.length;\n  }\n\n  get waiting() {\n    return this._pendingAcquires.length;\n  }\n\n  get maxSize() {\n    return this._factory.max;\n  }\n\n  get minSize() {\n    return this._factory.min;\n  }\n\n  /**\n   * logs to console or user defined log function\n   * @private\n   * @param {string} message\n   * @param {string} level\n   */\n  _log(message, level) {\n    if (typeof this._factory.log === \"function\") {\n      this._factory.log(message, level);\n    } else if (this._factory.log) {\n      console.log(`${level.toUpperCase()} pool ${this.name} - ${message}`);\n    }\n  }\n\n  /**\n   * Checks and removes the available (idle) clients that have timed out.\n   * @private\n   */\n  _removeIdle() {\n    const toRemove = [];\n    const now = Date.now();\n    let i;\n    let available = this._availableObjects.length;\n    const maxRemovable = this._count - this._factory.min;\n    let timeout;\n\n    this._removeIdleScheduled = false;\n\n    // Go through the available (idle) items,\n    // check if they have timed out\n    for (i = 0; i < available && maxRemovable > toRemove.length; i++) {\n      timeout = this._availableObjects[i].timeout;\n      if (now >= timeout) {\n        // Client timed out, so destroy it.\n        this._log(\n          \"removeIdle() destroying obj - now:\" + now + \" timeout:\" + timeout,\n          \"verbose\"\n        );\n        toRemove.push(this._availableObjects[i].resource);\n      }\n    }\n\n    toRemove.forEach(this.destroy, this);\n\n    // NOTE: we are re-calculating this value because it may have changed\n    // after destroying items above\n    // Replace the available items with the ones to keep.\n    available = this._availableObjects.length;\n\n    if (available > 0) {\n      this._log(\"this._availableObjects.length=\" + available, \"verbose\");\n      this._scheduleRemoveIdle();\n    } else {\n      this._log(\"removeIdle() all objects removed\", \"verbose\");\n    }\n  }\n\n  /**\n   * Schedule removal of idle items in the pool.\n   *\n   * More schedules cannot run concurrently.\n   */\n  _scheduleRemoveIdle() {\n    if (!this._removeIdleScheduled) {\n      this._removeIdleScheduled = true;\n      this._removeIdleTimer = setTimeout(() => {\n        this._removeIdle();\n      }, this._factory.reapInterval);\n    }\n  }\n\n  /**\n   * Try to get a new client to work, and clean up pool unused (idle) items.\n   *\n   *  - If there are available clients waiting, pop the first one out (LIFO),\n   *    and call its callback.\n   *  - If there are no waiting clients, try to create one if it won't exceed\n   *    the maximum number of clients.\n   *  - If creating a new client would exceed the maximum, add the client to\n   *    the wait list.\n   * @private\n   */\n  _dispense() {\n    let resourceWithTimeout = null;\n    const waitingCount = this._pendingAcquires.length;\n\n    this._log(\n      `dispense() clients=${waitingCount} available=${this._availableObjects.length}`,\n      \"info\"\n    );\n\n    if (waitingCount < 1) {\n      return;\n    }\n\n    while (this._availableObjects.length > 0) {\n      this._log(\"dispense() - reusing obj\", \"verbose\");\n      resourceWithTimeout = this._availableObjects[\n        this._availableObjects.length - 1\n      ];\n      if (!this._factory.validate(resourceWithTimeout.resource)) {\n        this.destroy(resourceWithTimeout.resource);\n        continue;\n      }\n\n      this._availableObjects.pop();\n      this._inUseObjects.push(resourceWithTimeout.resource);\n\n      const deferred = this._pendingAcquires.shift();\n      return deferred.resolve(resourceWithTimeout.resource);\n    }\n\n    if (this._count < this._factory.max) {\n      this._createResource();\n    }\n  }\n\n  /**\n   * @private\n   */\n  _createResource() {\n    this._count += 1;\n    this._log(\n      `createResource() - creating obj - count=${this._count} min=${this._factory.min} max=${this._factory.max}`,\n      \"verbose\"\n    );\n\n    this._factory\n      .create()\n      .then(resource => {\n        const deferred = this._pendingAcquires.shift();\n\n        this._inUseObjects.push(resource);\n\n        if (deferred) {\n          deferred.resolve(resource);\n        } else {\n          this._addResourceToAvailableObjects(resource);\n        }\n      })\n      .catch(error => {\n        const deferred = this._pendingAcquires.shift();\n\n        this._count -= 1;\n        if (this._count < 0) this._count = 0;\n        if (deferred) {\n          deferred.reject(error);\n        }\n        process.nextTick(() => {\n          this._dispense();\n        });\n      });\n  }\n\n  _addResourceToAvailableObjects(resource) {\n    const resourceWithTimeout = {\n      resource: resource,\n      timeout: Date.now() + this._factory.idleTimeoutMillis\n    };\n\n    this._availableObjects.push(resourceWithTimeout);\n    this._dispense();\n    this._scheduleRemoveIdle();\n  }\n\n  /**\n   * @private\n   */\n  _ensureMinimum() {\n    let i, diff;\n    if (!this._draining && this._count < this._factory.min) {\n      diff = this._factory.min - this._count;\n      for (i = 0; i < diff; i++) {\n        this._createResource();\n      }\n    }\n  }\n\n  /**\n   * Requests a new resource. This will call factory.create to request new resource.\n   *\n   * It will be rejected with timeout error if `factory.create` didn't respond\n   * back within specified `acquireTimeoutMillis`\n   *\n   * @returns {Promise<Object>}\n   */\n  acquire() {\n    if (this._draining) {\n      return Promise.reject(\n        new Error(\"pool is draining and cannot accept work\")\n      );\n    }\n\n    const deferred = new Deferred();\n    deferred.registerTimeout(this._factory.acquireTimeoutMillis, () => {\n      // timeout triggered, promise will be rejected\n      // remove this object from pending list\n      this._pendingAcquires = this._pendingAcquires.filter(\n        pending => pending !== deferred\n      );\n    });\n\n    this._pendingAcquires.push(deferred);\n    this._dispense();\n\n    return deferred.promise();\n  }\n\n  /**\n   * Return the resource to the pool, in case it is no longer required.\n   *\n   * @param {Object} resource The acquired object to be put back to the pool.\n   *\n   * @returns {void}\n   */\n  release(resource) {\n    // check to see if this object has already been released\n    // (i.e., is back in the pool of this._availableObjects)\n    if (\n      this._availableObjects.some(\n        resourceWithTimeout => resourceWithTimeout.resource === resource\n      )\n    ) {\n      this._log(\n        \"release called twice for the same resource: \" + new Error().stack,\n        \"error\"\n      );\n      return;\n    }\n\n    // check to see if this object exists in the `in use` list and remove it\n    const index = this._inUseObjects.indexOf(resource);\n    if (index < 0) {\n      this._log(\n        \"attempt to release an invalid resource: \" + new Error().stack,\n        \"error\"\n      );\n      return;\n    }\n\n    this._inUseObjects.splice(index, 1);\n    this._addResourceToAvailableObjects(resource);\n  }\n\n  /**\n   * Request the client to be destroyed. The factory's destroy handler\n   * will also be called.\n   *\n   * This should be called within an acquire() block as an alternative to release().\n   *\n   * @param {Object} resource The acquired item to be destroyed.\n   *\n   * @returns {void}\n   */\n  destroy(resource) {\n    const available = this._availableObjects.length;\n    const using = this._inUseObjects.length;\n\n    this._availableObjects = this._availableObjects.filter(\n      object => object.resource !== resource\n    );\n    this._inUseObjects = this._inUseObjects.filter(\n      object => object !== resource\n    );\n\n    // resource was not removed, then no need to decrement _count\n    if (\n      available === this._availableObjects.length &&\n      using === this._inUseObjects.length\n    ) {\n      this._ensureMinimum();\n      return;\n    }\n\n    this._count -= 1;\n    if (this._count < 0) this._count = 0;\n\n    this._factory.destroy(resource);\n    this._ensureMinimum();\n  }\n\n  /**\n   * Disallow any new requests and let the request backlog dissipate.\n   *\n   * @returns {Promise}\n   */\n  drain() {\n    this._log(\"draining\", \"info\");\n\n    // disable the ability to put more work on the queue.\n    this._draining = true;\n\n    const check = callback => {\n      // wait until all client requests have been satisfied.\n      if (this._pendingAcquires.length > 0) {\n        // pool is draining so we wont accept new acquires but\n        // we need to clear pending acquires\n        this._dispense();\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      }\n\n      // wait until in use object have been released.\n      if (this._availableObjects.length !== this._count) {\n        return setTimeout(() => {\n          check(callback);\n        }, 100);\n      }\n\n      callback();\n    };\n\n    // No error handling needed here.\n    return new Promise(resolve => check(resolve));\n  }\n\n  /**\n   * Forcibly destroys all clients regardless of timeout.  Intended to be\n   * invoked as part of a drain.  Does not prevent the creation of new\n   * clients as a result of subsequent calls to acquire.\n   *\n   * Note that if factory.min > 0, the pool will destroy all idle resources\n   * in the pool, but replace them with newly created resources up to the\n   * specified factory.min value.  If this is not desired, set factory.min\n   * to zero before calling destroyAllNow()\n   *\n   * @returns {Promise}\n   */\n  destroyAllNow() {\n    this._log(\"force destroying all objects\", \"info\");\n\n    const willDie = this._availableObjects.slice();\n    const todo = willDie.length;\n\n    this._removeIdleScheduled = false;\n    clearTimeout(this._removeIdleTimer);\n\n    return new Promise(resolve => {\n      if (todo === 0) {\n        return resolve();\n      }\n\n      let resource;\n      let done = 0;\n\n      while ((resource = willDie.shift())) {\n        this.destroy(resource.resource);\n        ++done;\n\n        if (done === todo && resolve) {\n          return resolve();\n        }\n      }\n    });\n  }\n}\n\nexports.Pool = Pool;\nexports.default = Pool;\nexports.TimeoutError = require(\"./TimeoutError\").TimeoutError;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}