{"ast":null,"code":"'use strict';\n\nconst _ = require('lodash');\n\nconst Utils = require('../../utils');\n\nconst Promise = require('../../promise');\n\nconst AbstractQuery = require('../abstract/query');\n\nconst QueryTypes = require('../../query-types');\n\nconst sequelizeErrors = require('../../errors');\n\nconst parserStore = require('../parserStore')('sqlite');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|Object} values\n   * @param {string} dialect\n   * @private\n   */\n\n\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    } else {\n      bindParam = {};\n\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, {\n        skipValueReplace: true\n      })[0];\n    }\n\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n\n    let result = this.instance; // add the inserted row id to the instance\n\n    if (this.isInsertQuery(results, metaData)) {\n      this.handleInsertQuery(results, metaData);\n\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (metaData.constructor.name === 'Statement' && this.model && this.model.autoIncrementAttribute && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute && this.model.rawAttributes[this.model.primaryKeyAttribute]) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({\n              [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i\n            });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n\n      return result;\n    }\n\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      } // This is a map of prefix strings to models, e.g. user.projects -> Project model\n\n\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n            model = prefixes[name.substr(0, lastind)];\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name) ? this.applyParsers(tableTypes[name], value) : value;\n        });\n      });\n      return this.handleSelectQuery(results);\n    }\n\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n      let defaultValue;\n\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = {\n            '0': false,\n            '1': true\n          }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n\n      return result;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n\n    if (this.options.type === QueryTypes.UPSERT) {\n      return undefined;\n    }\n\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n\n    return result;\n  }\n\n  run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    let complete;\n\n    if (method === 'exec') {\n      // exec does not support bind parameter\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', {\n        skipUnescape: true\n      })[0];\n      this.sql = sql;\n      complete = this._logQuery(sql, debug);\n    } else {\n      complete = this._logQuery(sql, debug, parameters);\n    }\n\n    return new Promise(resolve => {\n      const columnTypes = {};\n      conn.serialize(() => {\n        const executeSql = () => {\n          if (sql.startsWith('-- ')) {\n            return resolve();\n          }\n\n          resolve(new Promise((resolve, reject) => {\n            const query = this; // cannot use arrow function here because the function is bound to the statement\n\n            function afterExecute(executionError, results) {\n              try {\n                complete(); // `this` is passed from sqlite, we have no control over this.\n                // eslint-disable-next-line no-invalid-this\n\n                resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n                return;\n              } catch (error) {\n                reject(error);\n              }\n            }\n\n            if (method === 'exec') {\n              // exec does not support bind parameter\n              conn[method](sql, afterExecute);\n            } else {\n              if (!parameters) parameters = [];\n              conn[method](sql, parameters, afterExecute);\n            }\n          }));\n          return null;\n        };\n\n        if (this.getDatabaseMethod() === 'all') {\n          let tableNames = [];\n\n          if (this.options && this.options.tableNames) {\n            tableNames = this.options.tableNames;\n          } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n            tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n          } // If we already have the metadata for the table, there's no need to ask for it again\n\n\n          tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n          if (!tableNames.length) {\n            return executeSql();\n          }\n\n          return Promise.map(tableNames, tableName => new Promise(resolve => {\n            tableName = tableName.replace(/`/g, '');\n            columnTypes[tableName] = {};\n            conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n              if (!err) {\n                for (const result of results) {\n                  columnTypes[tableName][result.name] = result.type;\n                }\n              }\n\n              resolve();\n            });\n          })).then(executeSql);\n        }\n\n        return executeSql();\n      });\n    });\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'),\n        //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, {\n        timezone: this.sequelize.options.timezone\n      });\n    }\n\n    return value;\n  }\n\n  formatError(err) {\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT':\n        {\n          if (err.message.includes('FOREIGN KEY constraint failed')) {\n            return new sequelizeErrors.ForeignKeyConstraintError({\n              parent: err\n            });\n          }\n\n          let fields = []; // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n\n          let match = err.message.match(/columns (.*?) are/);\n\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ');\n          } else {\n            // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n            match = err.message.match(/UNIQUE constraint failed: (.*)/);\n\n            if (match !== null && match.length >= 2) {\n              fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n            }\n          }\n\n          const errors = [];\n          let message = 'Validation error';\n\n          for (const field of fields) {\n            errors.push(new sequelizeErrors.ValidationErrorItem(this.getUniqueConstraintErrorMessage(field), 'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field, this.instance && this.instance[field], this.instance, 'not_unique'));\n          }\n\n          if (this.model) {\n            _.forOwn(this.model.uniqueKeys, constraint => {\n              if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n                message = constraint.msg;\n                return false;\n              }\n            });\n          }\n\n          return new sequelizeErrors.UniqueConstraintError({\n            message,\n            errors,\n            parent: err,\n            fields\n          });\n        }\n\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.map(data.reverse(), item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      return this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`).then(columns => {\n        for (const column of columns) {\n          item.fields[column.seqno] = {\n            attribute: column.name,\n            length: undefined,\n            order: undefined\n          };\n        }\n\n        return item;\n      });\n    });\n  }\n\n  getDatabaseMethod() {\n    if (this.isUpsertQuery()) {\n      return 'exec'; // Needed to run multiple queries in one\n    }\n\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n\n    return 'all';\n  }\n\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;","map":{"version":3,"names":["_","require","Utils","Promise","AbstractQuery","QueryTypes","sequelizeErrors","parserStore","logger","debug","debugContext","Query","getInsertIdField","formatBindParameters","sql","values","dialect","bindParam","Array","isArray","forEach","v","i","skipValueReplace","k","Object","keys","_collectModels","include","prefix","ret","_include","key","as","model","merge","_handleQueryResponse","metaData","columnTypes","err","results","formatError","result","instance","isInsertQuery","handleInsertQuery","constructor","name","autoIncrementAttribute","primaryKeyAttribute","rawAttributes","startId","changes","push","field","isShowTablesQuery","map","row","isShowConstraintsQuery","parseConstraintsFromSql","isSelectQuery","options","raw","handleSelectQuery","prefixes","mapValues","value","includes","lastind","lastIndexOf","substr","tableName","getTableName","toString","replace","tableTypes","forOwn","attribute","prototype","hasOwnProperty","call","applyParsers","isShowOrDescribeQuery","handleShowIndexesQuery","defaultValue","_result","dflt_value","undefined","type","allowNull","notnull","primaryKey","pk","BULKUPDATE","BULKDELETE","UPSERT","VERSION","version","RAW","isUpdateQuery","run","parameters","conn","connection","method","getDatabaseMethod","complete","bind","skipUnescape","_logQuery","resolve","serialize","executeSql","startsWith","reject","query","afterExecute","executionError","error","tableNames","exec","filter","length","all","then","constraints","split","referenceTableName","referenceTableKeys","updateAction","deleteAction","splice","constraintSql","match","referencesRegex","referenceConditions","removeTicks","columnNames","column","constraintCondition","constraint","constraintName","constraintType","indexOf","trim","toUpperCase","parse","get","timezone","sequelize","code","message","ForeignKeyConstraintError","parent","fields","columnWithTable","errors","ValidationErrorItem","getUniqueConstraintErrorMessage","uniqueKeys","isEqual","msg","UniqueConstraintError","TimeoutError","DatabaseError","data","reverse","item","primary","unique","columns","seqno","order","isUpsertQuery","isBulkUpdateQuery","toLowerCase","module","exports","default"],"sources":["/home/brian/node_modules/sequelize/lib/dialects/sqlite/query.js"],"sourcesContent":["'use strict';\n\nconst _ = require('lodash');\nconst Utils = require('../../utils');\nconst Promise = require('../../promise');\nconst AbstractQuery = require('../abstract/query');\nconst QueryTypes = require('../../query-types');\nconst sequelizeErrors = require('../../errors');\nconst parserStore = require('../parserStore')('sqlite');\nconst { logger } = require('../../utils/logger');\n\nconst debug = logger.debugContext('sql:sqlite');\n\n\nclass Query extends AbstractQuery {\n  getInsertIdField() {\n    return 'lastID';\n  }\n\n  /**\n   * rewrite query with parameters.\n   *\n   * @param {string} sql\n   * @param {Array|Object} values\n   * @param {string} dialect\n   * @private\n   */\n  static formatBindParameters(sql, values, dialect) {\n    let bindParam;\n    if (Array.isArray(values)) {\n      bindParam = {};\n      values.forEach((v, i) => {\n        bindParam[`$${i + 1}`] = v;\n      });\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    } else {\n      bindParam = {};\n      if (typeof values === 'object') {\n        for (const k of Object.keys(values)) {\n          bindParam[`$${k}`] = values[k];\n        }\n      }\n      sql = AbstractQuery.formatBindParameters(sql, values, dialect, { skipValueReplace: true })[0];\n    }\n    return [sql, bindParam];\n  }\n\n  _collectModels(include, prefix) {\n    const ret = {};\n\n    if (include) {\n      for (const _include of include) {\n        let key;\n        if (!prefix) {\n          key = _include.as;\n        } else {\n          key = `${prefix}.${_include.as}`;\n        }\n        ret[key] = _include.model;\n\n        if (_include.include) {\n          _.merge(ret, this._collectModels(_include.include, key));\n        }\n      }\n    }\n\n    return ret;\n  }\n\n  _handleQueryResponse(metaData, columnTypes, err, results) {\n    if (err) {\n      err.sql = this.sql;\n      throw this.formatError(err);\n    }\n    let result = this.instance;\n\n    // add the inserted row id to the instance\n    if (this.isInsertQuery(results, metaData)) {\n      this.handleInsertQuery(results, metaData);\n      if (!this.instance) {\n        // handle bulkCreate AI primary key\n        if (\n          metaData.constructor.name === 'Statement'\n          && this.model\n          && this.model.autoIncrementAttribute\n          && this.model.autoIncrementAttribute === this.model.primaryKeyAttribute\n          && this.model.rawAttributes[this.model.primaryKeyAttribute]\n        ) {\n          const startId = metaData[this.getInsertIdField()] - metaData.changes + 1;\n          result = [];\n          for (let i = startId; i < startId + metaData.changes; i++) {\n            result.push({ [this.model.rawAttributes[this.model.primaryKeyAttribute].field]: i });\n          }\n        } else {\n          result = metaData[this.getInsertIdField()];\n        }\n      }\n    }\n\n    if (this.isShowTablesQuery()) {\n      return results.map(row => row.name);\n    }\n    if (this.isShowConstraintsQuery()) {\n      result = results;\n      if (results && results[0] && results[0].sql) {\n        result = this.parseConstraintsFromSql(results[0].sql);\n      }\n      return result;\n    }\n    if (this.isSelectQuery()) {\n      if (this.options.raw) {\n        return this.handleSelectQuery(results);\n      }\n      // This is a map of prefix strings to models, e.g. user.projects -> Project model\n      const prefixes = this._collectModels(this.options.include);\n\n      results = results.map(result => {\n        return _.mapValues(result, (value, name) => {\n          let model;\n          if (name.includes('.')) {\n            const lastind = name.lastIndexOf('.');\n\n            model = prefixes[name.substr(0, lastind)];\n\n            name = name.substr(lastind + 1);\n          } else {\n            model = this.options.model;\n          }\n\n          const tableName = model.getTableName().toString().replace(/`/g, '');\n          const tableTypes = columnTypes[tableName] || {};\n\n          if (tableTypes && !(name in tableTypes)) {\n            // The column is aliased\n            _.forOwn(model.rawAttributes, (attribute, key) => {\n              if (name === key && attribute.field) {\n                name = attribute.field;\n                return false;\n              }\n            });\n          }\n\n          return Object.prototype.hasOwnProperty.call(tableTypes, name)\n            ? this.applyParsers(tableTypes[name], value)\n            : value;\n        });\n      });\n\n      return this.handleSelectQuery(results);\n    }\n    if (this.isShowOrDescribeQuery()) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA INDEX_LIST')) {\n      return this.handleShowIndexesQuery(results);\n    }\n    if (this.sql.includes('PRAGMA INDEX_INFO')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA TABLE_INFO')) {\n      // this is the sqlite way of getting the metadata of a table\n      result = {};\n\n      let defaultValue;\n      for (const _result of results) {\n        if (_result.dflt_value === null) {\n          // Column schema omits any \"DEFAULT ...\"\n          defaultValue = undefined;\n        } else if (_result.dflt_value === 'NULL') {\n          // Column schema is a \"DEFAULT NULL\"\n          defaultValue = null;\n        } else {\n          defaultValue = _result.dflt_value;\n        }\n\n        result[_result.name] = {\n          type: _result.type,\n          allowNull: _result.notnull === 0,\n          defaultValue,\n          primaryKey: _result.pk !== 0\n        };\n\n        if (result[_result.name].type === 'TINYINT(1)') {\n          result[_result.name].defaultValue = { '0': false, '1': true }[result[_result.name].defaultValue];\n        }\n\n        if (typeof result[_result.name].defaultValue === 'string') {\n          result[_result.name].defaultValue = result[_result.name].defaultValue.replace(/'/g, '');\n        }\n      }\n      return result;\n    }\n    if (this.sql.includes('PRAGMA foreign_keys;')) {\n      return results[0];\n    }\n    if (this.sql.includes('PRAGMA foreign_keys')) {\n      return results;\n    }\n    if (this.sql.includes('PRAGMA foreign_key_list')) {\n      return results;\n    }\n    if ([QueryTypes.BULKUPDATE, QueryTypes.BULKDELETE].includes(this.options.type)) {\n      return metaData.changes;\n    }\n    if (this.options.type === QueryTypes.UPSERT) {\n      return undefined;\n    }\n    if (this.options.type === QueryTypes.VERSION) {\n      return results[0].version;\n    }\n    if (this.options.type === QueryTypes.RAW) {\n      return [results, metaData];\n    }\n    if (this.isUpdateQuery() || this.isInsertQuery()) {\n      return [result, metaData.changes];\n    }\n    return result;\n  }\n\n  run(sql, parameters) {\n    const conn = this.connection;\n    this.sql = sql;\n    const method = this.getDatabaseMethod();\n    let complete;\n    if (method === 'exec') {\n      // exec does not support bind parameter\n      sql = AbstractQuery.formatBindParameters(sql, this.options.bind, this.options.dialect || 'sqlite', { skipUnescape: true })[0];\n      this.sql = sql;\n      complete = this._logQuery(sql, debug);\n    } else {\n      complete = this._logQuery(sql, debug, parameters);\n    }\n    \n\n    return new Promise(resolve => {\n      const columnTypes = {};\n      conn.serialize(() => {\n        const executeSql = () => {\n          if (sql.startsWith('-- ')) {\n            return resolve();\n          }\n          resolve(new Promise((resolve, reject) => {\n            const query = this;\n            // cannot use arrow function here because the function is bound to the statement\n            function afterExecute(executionError, results) {\n              try {\n                complete();\n                // `this` is passed from sqlite, we have no control over this.\n                // eslint-disable-next-line no-invalid-this\n                resolve(query._handleQueryResponse(this, columnTypes, executionError, results));\n                return;\n              } catch (error) {\n                reject(error);\n              }\n            }\n\n            if (method === 'exec') {\n              // exec does not support bind parameter\n              conn[method](sql, afterExecute);\n            } else {\n              if (!parameters) parameters = [];\n              conn[method](sql, parameters, afterExecute);\n            }\n          }));\n          return null;\n        };\n\n        if (this.getDatabaseMethod() === 'all') {\n          let tableNames = [];\n          if (this.options && this.options.tableNames) {\n            tableNames = this.options.tableNames;\n          } else if (/FROM `(.*?)`/i.exec(this.sql)) {\n            tableNames.push(/FROM `(.*?)`/i.exec(this.sql)[1]);\n          }\n\n          // If we already have the metadata for the table, there's no need to ask for it again\n          tableNames = tableNames.filter(tableName => !(tableName in columnTypes) && tableName !== 'sqlite_master');\n\n          if (!tableNames.length) {\n            return executeSql();\n          }\n          return Promise.map(tableNames, tableName =>\n            new Promise(resolve => {\n              tableName = tableName.replace(/`/g, '');\n              columnTypes[tableName] = {};\n\n              conn.all(`PRAGMA table_info(\\`${tableName}\\`)`, (err, results) => {\n                if (!err) {\n                  for (const result of results) {\n                    columnTypes[tableName][result.name] = result.type;\n                  }\n                }\n                resolve();\n              });\n            })\n          ).then(executeSql);\n        }\n        return executeSql();\n      });\n    });\n  }\n\n  parseConstraintsFromSql(sql) {\n    let constraints = sql.split('CONSTRAINT ');\n    let referenceTableName, referenceTableKeys, updateAction, deleteAction;\n    constraints.splice(0, 1);\n    constraints = constraints.map(constraintSql => {\n      //Parse foreign key snippets\n      if (constraintSql.includes('REFERENCES')) {\n        //Parse out the constraint condition form sql string\n        updateAction = constraintSql.match(/ON UPDATE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n        deleteAction = constraintSql.match(/ON DELETE (CASCADE|SET NULL|RESTRICT|NO ACTION|SET DEFAULT){1}/);\n\n        if (updateAction) {\n          updateAction = updateAction[1];\n        }\n\n        if (deleteAction) {\n          deleteAction = deleteAction[1];\n        }\n\n        const referencesRegex = /REFERENCES.+\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/;\n        const referenceConditions = constraintSql.match(referencesRegex)[0].split(' ');\n        referenceTableName = Utils.removeTicks(referenceConditions[1]);\n        let columnNames = referenceConditions[2];\n        columnNames = columnNames.replace(/\\(|\\)/g, '').split(', ');\n        referenceTableKeys = columnNames.map(column => Utils.removeTicks(column));\n      }\n\n      const constraintCondition = constraintSql.match(/\\((?:[^)(]+|\\((?:[^)(]+|\\([^)(]*\\))*\\))*\\)/)[0];\n      constraintSql = constraintSql.replace(/\\(.+\\)/, '');\n      const constraint = constraintSql.split(' ');\n\n      if (constraint[1] === 'PRIMARY' || constraint[1] === 'FOREIGN') {\n        constraint[1] += ' KEY';\n      }\n\n      return {\n        constraintName: Utils.removeTicks(constraint[0]),\n        constraintType: constraint[1],\n        updateAction,\n        deleteAction,\n        sql: sql.replace(/\"/g, '`'), //Sqlite returns double quotes for table name\n        constraintCondition,\n        referenceTableName,\n        referenceTableKeys\n      };\n    });\n\n    return constraints;\n  }\n\n  applyParsers(type, value) {\n    if (type.includes('(')) {\n      // Remove the length part\n      type = type.substr(0, type.indexOf('('));\n    }\n    type = type.replace('UNSIGNED', '').replace('ZEROFILL', '');\n    type = type.trim().toUpperCase();\n    const parse = parserStore.get(type);\n\n    if (value !== null && parse) {\n      return parse(value, { timezone: this.sequelize.options.timezone });\n    }\n    return value;\n  }\n\n  formatError(err) {\n\n    switch (err.code) {\n      case 'SQLITE_CONSTRAINT': {\n        if (err.message.includes('FOREIGN KEY constraint failed')) {\n          return new sequelizeErrors.ForeignKeyConstraintError({\n            parent: err\n          });\n        }\n\n        let fields = [];\n\n        // Sqlite pre 2.2 behavior - Error: SQLITE_CONSTRAINT: columns x, y are not unique\n        let match = err.message.match(/columns (.*?) are/);\n        if (match !== null && match.length >= 2) {\n          fields = match[1].split(', ');\n        } else {\n\n          // Sqlite post 2.2 behavior - Error: SQLITE_CONSTRAINT: UNIQUE constraint failed: table.x, table.y\n          match = err.message.match(/UNIQUE constraint failed: (.*)/);\n          if (match !== null && match.length >= 2) {\n            fields = match[1].split(', ').map(columnWithTable => columnWithTable.split('.')[1]);\n          }\n        }\n\n        const errors = [];\n        let message = 'Validation error';\n\n        for (const field of fields) {\n          errors.push(new sequelizeErrors.ValidationErrorItem(\n            this.getUniqueConstraintErrorMessage(field),\n            'unique violation', // sequelizeErrors.ValidationErrorItem.Origins.DB,\n            field,\n            this.instance && this.instance[field],\n            this.instance,\n            'not_unique'\n          ));\n        }\n\n        if (this.model) {\n          _.forOwn(this.model.uniqueKeys, constraint => {\n            if (_.isEqual(constraint.fields, fields) && !!constraint.msg) {\n              message = constraint.msg;\n              return false;\n            }\n          });\n        }\n\n        return new sequelizeErrors.UniqueConstraintError({ message, errors, parent: err, fields });\n      }\n      case 'SQLITE_BUSY':\n        return new sequelizeErrors.TimeoutError(err);\n\n      default:\n        return new sequelizeErrors.DatabaseError(err);\n    }\n  }\n\n  handleShowIndexesQuery(data) {\n    // Sqlite returns indexes so the one that was defined last is returned first. Lets reverse that!\n    return Promise.map(data.reverse(), item => {\n      item.fields = [];\n      item.primary = false;\n      item.unique = !!item.unique;\n      item.constraintName = item.name;\n      return this.run(`PRAGMA INDEX_INFO(\\`${item.name}\\`)`).then(columns => {\n        for (const column of columns) {\n          item.fields[column.seqno] = {\n            attribute: column.name,\n            length: undefined,\n            order: undefined\n          };\n        }\n\n        return item;\n      });\n    });\n  }\n\n  getDatabaseMethod() {\n    if (this.isUpsertQuery()) {\n      return 'exec'; // Needed to run multiple queries in one\n    }\n    if (this.isInsertQuery() || this.isUpdateQuery() || this.isBulkUpdateQuery() || this.sql.toLowerCase().includes('CREATE TEMPORARY TABLE'.toLowerCase()) || this.options.type === QueryTypes.BULKDELETE) {\n      return 'run';\n    }\n    return 'all';\n  }\n}\n\nmodule.exports = Query;\nmodule.exports.Query = Query;\nmodule.exports.default = Query;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}