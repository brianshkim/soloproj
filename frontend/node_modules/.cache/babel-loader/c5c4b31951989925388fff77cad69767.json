{"ast":null,"code":"'use strict';\n\nvar EventEmitter = require('events').EventEmitter;\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar sasl = require('./sasl');\n\nvar pgPass = require('pgpass');\n\nvar TypeOverrides = require('./type-overrides');\n\nvar ConnectionParameters = require('./connection-parameters');\n\nvar Query = require('./query');\n\nvar defaults = require('./defaults');\n\nvar Connection = require('./connection');\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super();\n    this.connectionParameters = new ConnectionParameters(config);\n    this.user = this.connectionParameters.user;\n    this.database = this.connectionParameters.database;\n    this.port = this.connectionParameters.port;\n    this.host = this.connectionParameters.host; // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password\n    });\n    this.replication = this.connectionParameters.replication;\n    var c = config || {};\n    this._Promise = c.Promise || global.Promise;\n    this._types = new TypeOverrides(c.types);\n    this._ending = false;\n    this._connecting = false;\n    this._connected = false;\n    this._connectionError = false;\n    this._queryable = true;\n    this.connection = c.connection || new Connection({\n      stream: c.stream,\n      ssl: this.connectionParameters.ssl,\n      keepAlive: c.keepAlive || false,\n      keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n      encoding: this.connectionParameters.client_encoding || 'utf8'\n    });\n    this.queryQueue = [];\n    this.binary = c.binary || defaults.binary;\n    this.processID = null;\n    this.secretKey = null;\n    this.ssl = this.connectionParameters.ssl || false; // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false\n      });\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0;\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = query => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection);\n      });\n    };\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery);\n      this.activeQuery = null;\n    }\n\n    this.queryQueue.forEach(enqueueError);\n    this.queryQueue.length = 0;\n  }\n\n  _connect(callback) {\n    var self = this;\n    var con = this.connection;\n    this._connectionCallback = callback;\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.');\n      process.nextTick(() => {\n        callback(err);\n      });\n      return;\n    }\n\n    this._connecting = true;\n    this.connectionTimeoutHandle;\n\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true;\n        con.stream.destroy(new Error('timeout expired'));\n      }, this._connectionTimeoutMillis);\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port);\n    } else {\n      con.connect(this.port, this.host);\n    } // once connection is established send startup message\n\n\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl();\n      } else {\n        con.startup(self.getStartupConf());\n      }\n    });\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf());\n    });\n\n    this._attachListeners(con);\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly');\n      clearTimeout(this.connectionTimeoutHandle);\n\n      this._errorAllQueries(error);\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error);\n          } else {\n            this._handleErrorEvent(error);\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error);\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end');\n      });\n    });\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback);\n\n      return;\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect(error => {\n        if (error) {\n          reject(error);\n        } else {\n          resolve();\n        }\n      });\n    });\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this)); // password request handling\n\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this)); // password request handling (SASL)\n\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this));\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this));\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this));\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this));\n    con.on('error', this._handleErrorEvent.bind(this));\n    con.on('errorMessage', this._handleErrorMessage.bind(this));\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this));\n    con.on('notice', this._handleNotice.bind(this));\n    con.on('rowDescription', this._handleRowDescription.bind(this));\n    con.on('dataRow', this._handleDataRow.bind(this));\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this));\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this));\n    con.on('commandComplete', this._handleCommandComplete.bind(this));\n    con.on('parseComplete', this._handleParseComplete.bind(this));\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this));\n    con.on('copyData', this._handleCopyData.bind(this));\n    con.on('notification', this._handleNotification.bind(this));\n  } // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n\n\n  _checkPgPass(cb) {\n    const con = this.connection;\n\n    if (typeof this.password === 'function') {\n      this._Promise.resolve().then(() => this.password()).then(pass => {\n        if (pass !== undefined) {\n          if (typeof pass !== 'string') {\n            con.emit('error', new TypeError('Password must be a string'));\n            return;\n          }\n\n          this.connectionParameters.password = this.password = pass;\n        } else {\n          this.connectionParameters.password = this.password = null;\n        }\n\n        cb();\n      }).catch(err => {\n        con.emit('error', err);\n      });\n    } else if (this.password !== null) {\n      cb();\n    } else {\n      pgPass(this.connectionParameters, pass => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass;\n        }\n\n        cb();\n      });\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password);\n    });\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt);\n      this.connection.password(hashedPassword);\n    });\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      this.saslSession = sasl.startSession(msg.mechanisms);\n      this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response);\n    });\n  }\n\n  _handleAuthSASLContinue(msg) {\n    sasl.continueSession(this.saslSession, this.password, msg.data);\n    this.connection.sendSCRAMClientFinalMessage(this.saslSession.response);\n  }\n\n  _handleAuthSASLFinal(msg) {\n    sasl.finalizeSession(this.saslSession, msg.data);\n    this.saslSession = null;\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID;\n    this.secretKey = msg.secretKey;\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false;\n      this._connected = true;\n      clearTimeout(this.connectionTimeoutHandle); // process possible callback argument to Client#connect\n\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this); // remove callback for proper error handling\n        // after the connect event\n\n\n        this._connectionCallback = null;\n      }\n\n      this.emit('connect');\n    }\n\n    const {\n      activeQuery\n    } = this;\n    this.activeQuery = null;\n    this.readyForQuery = true;\n\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection);\n    }\n\n    this._pulseQueryQueue();\n  } // if we receieve an error event or error message\n  // during the connection process we handle it here\n\n\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return;\n    }\n\n    this._connectionError = true;\n    clearTimeout(this.connectionTimeoutHandle);\n\n    if (this._connectionCallback) {\n      return this._connectionCallback(err);\n    }\n\n    this.emit('error', err);\n  } // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n\n\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err);\n    }\n\n    this._queryable = false;\n\n    this._errorAllQueries(err);\n\n    this.emit('error', err);\n  } // handle error messages from the postgres backend\n\n\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg);\n    }\n\n    const activeQuery = this.activeQuery;\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg);\n\n      return;\n    }\n\n    this.activeQuery = null;\n    activeQuery.handleError(msg, this.connection);\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg);\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg);\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection);\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection);\n  }\n\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection);\n  }\n\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text;\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection);\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection);\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg);\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg);\n  }\n\n  getStartupConf() {\n    var params = this.connectionParameters;\n    var data = {\n      user: params.user,\n      database: params.database\n    };\n    var appName = params.application_name || params.fallback_application_name;\n\n    if (appName) {\n      data.application_name = appName;\n    }\n\n    if (params.replication) {\n      data.replication = '' + params.replication;\n    }\n\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10));\n    }\n\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10));\n    }\n\n    if (params.options) {\n      data.options = params.options;\n    }\n\n    return data;\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection;\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port);\n      } else {\n        con.connect(this.port, this.host);\n      } // once connection is established send cancel message\n\n\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey);\n      });\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1);\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn);\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format);\n  } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"';\n  } // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n\n\n  escapeLiteral(str) {\n    var hasBackslash = false;\n    var escaped = \"'\";\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i];\n\n      if (c === \"'\") {\n        escaped += c + c;\n      } else if (c === '\\\\') {\n        escaped += c + c;\n        hasBackslash = true;\n      } else {\n        escaped += c;\n      }\n    }\n\n    escaped += \"'\";\n\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped;\n    }\n\n    return escaped;\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift();\n\n      if (this.activeQuery) {\n        this.readyForQuery = false;\n        this.hasExecuted = true;\n        const queryError = this.activeQuery.submit(this.connection);\n\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection);\n            this.readyForQuery = true;\n\n            this._pulseQueryQueue();\n          });\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null;\n        this.emit('drain');\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query;\n    var result;\n    var readTimeout;\n    var readTimeoutTimer;\n    var queryCallback;\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query');\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout;\n      result = query = config;\n\n      if (typeof values === 'function') {\n        query.callback = query.callback || values;\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout;\n      query = new Query(config, values, callback);\n\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => err ? reject(err) : resolve(res);\n        });\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback;\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout');\n        process.nextTick(() => {\n          query.handleError(error, this.connection);\n        });\n        queryCallback(error); // we already returned an error,\n        // just do nothing if query completes\n\n        query.callback = () => {}; // Remove from queue\n\n\n        var index = this.queryQueue.indexOf(query);\n\n        if (index > -1) {\n          this.queryQueue.splice(index, 1);\n        }\n\n        this._pulseQueryQueue();\n      }, readTimeout);\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer);\n        queryCallback(err, res);\n      };\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true;\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types;\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection);\n      });\n      return result;\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection);\n      });\n      return result;\n    }\n\n    this.queryQueue.push(query);\n\n    this._pulseQueryQueue();\n\n    return result;\n  }\n\n  ref() {\n    this.connection.ref();\n  }\n\n  unref() {\n    this.connection.unref();\n  }\n\n  end(cb) {\n    this._ending = true; // if we have never connected, then end is a noop, callback immediately\n\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb();\n      } else {\n        return this._Promise.resolve();\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy();\n    } else {\n      this.connection.end();\n    }\n\n    if (cb) {\n      this.connection.once('end', cb);\n    } else {\n      return new this._Promise(resolve => {\n        this.connection.once('end', resolve);\n      });\n    }\n  }\n\n} // expose a Query constructor\n\n\nClient.Query = Query;\nmodule.exports = Client;","map":{"version":3,"names":["EventEmitter","require","util","utils","sasl","pgPass","TypeOverrides","ConnectionParameters","Query","defaults","Connection","Client","constructor","config","connectionParameters","user","database","port","host","Object","defineProperty","configurable","enumerable","writable","value","password","replication","c","_Promise","Promise","global","_types","types","_ending","_connecting","_connected","_connectionError","_queryable","connection","stream","ssl","keepAlive","keepAliveInitialDelayMillis","encoding","client_encoding","queryQueue","binary","processID","secretKey","key","_connectionTimeoutMillis","connectionTimeoutMillis","_errorAllQueries","err","enqueueError","query","process","nextTick","handleError","activeQuery","forEach","length","_connect","callback","self","con","_connectionCallback","Error","connectionTimeoutHandle","setTimeout","destroy","indexOf","connect","on","requestSsl","startup","getStartupConf","_attachListeners","once","error","clearTimeout","_handleErrorEvent","emit","resolve","reject","_handleAuthCleartextPassword","bind","_handleAuthMD5Password","_handleAuthSASL","_handleAuthSASLContinue","_handleAuthSASLFinal","_handleBackendKeyData","_handleErrorMessage","_handleReadyForQuery","_handleNotice","_handleRowDescription","_handleDataRow","_handlePortalSuspended","_handleEmptyQuery","_handleCommandComplete","_handleParseComplete","_handleCopyInResponse","_handleCopyData","_handleNotification","_checkPgPass","cb","then","pass","undefined","TypeError","catch","msg","hashedPassword","postgresMd5PasswordHash","salt","saslSession","startSession","mechanisms","sendSASLInitialResponseMessage","mechanism","response","continueSession","data","sendSCRAMClientFinalMessage","finalizeSession","readyForQuery","handleReadyForQuery","_pulseQueryQueue","_handleErrorWhileConnecting","handleRowDescription","handleDataRow","handlePortalSuspended","handleEmptyQuery","handleCommandComplete","name","parsedStatements","text","handleCopyInResponse","handleCopyData","params","appName","application_name","fallback_application_name","statement_timeout","String","parseInt","idle_in_transaction_session_timeout","options","cancel","client","splice","setTypeParser","oid","format","parseFn","getTypeParser","escapeIdentifier","str","replace","escapeLiteral","hasBackslash","escaped","i","shift","hasExecuted","queryError","submit","values","result","readTimeout","readTimeoutTimer","queryCallback","query_timeout","res","index","_result","push","ref","unref","end","module","exports"],"sources":["/home/brian/node_modules/pg/lib/client.js"],"sourcesContent":["'use strict'\n\nvar EventEmitter = require('events').EventEmitter\nvar util = require('util')\nvar utils = require('./utils')\nvar sasl = require('./sasl')\nvar pgPass = require('pgpass')\nvar TypeOverrides = require('./type-overrides')\n\nvar ConnectionParameters = require('./connection-parameters')\nvar Query = require('./query')\nvar defaults = require('./defaults')\nvar Connection = require('./connection')\n\nclass Client extends EventEmitter {\n  constructor(config) {\n    super()\n\n    this.connectionParameters = new ConnectionParameters(config)\n    this.user = this.connectionParameters.user\n    this.database = this.connectionParameters.database\n    this.port = this.connectionParameters.port\n    this.host = this.connectionParameters.host\n\n    // \"hiding\" the password so it doesn't show up in stack traces\n    // or if the client is console.logged\n    Object.defineProperty(this, 'password', {\n      configurable: true,\n      enumerable: false,\n      writable: true,\n      value: this.connectionParameters.password,\n    })\n\n    this.replication = this.connectionParameters.replication\n\n    var c = config || {}\n\n    this._Promise = c.Promise || global.Promise\n    this._types = new TypeOverrides(c.types)\n    this._ending = false\n    this._connecting = false\n    this._connected = false\n    this._connectionError = false\n    this._queryable = true\n\n    this.connection =\n      c.connection ||\n      new Connection({\n        stream: c.stream,\n        ssl: this.connectionParameters.ssl,\n        keepAlive: c.keepAlive || false,\n        keepAliveInitialDelayMillis: c.keepAliveInitialDelayMillis || 0,\n        encoding: this.connectionParameters.client_encoding || 'utf8',\n      })\n    this.queryQueue = []\n    this.binary = c.binary || defaults.binary\n    this.processID = null\n    this.secretKey = null\n    this.ssl = this.connectionParameters.ssl || false\n    // As with Password, make SSL->Key (the private key) non-enumerable.\n    // It won't show up in stack traces\n    // or if the client is console.logged\n    if (this.ssl && this.ssl.key) {\n      Object.defineProperty(this.ssl, 'key', {\n        enumerable: false,\n      })\n    }\n\n    this._connectionTimeoutMillis = c.connectionTimeoutMillis || 0\n  }\n\n  _errorAllQueries(err) {\n    const enqueueError = (query) => {\n      process.nextTick(() => {\n        query.handleError(err, this.connection)\n      })\n    }\n\n    if (this.activeQuery) {\n      enqueueError(this.activeQuery)\n      this.activeQuery = null\n    }\n\n    this.queryQueue.forEach(enqueueError)\n    this.queryQueue.length = 0\n  }\n\n  _connect(callback) {\n    var self = this\n    var con = this.connection\n    this._connectionCallback = callback\n\n    if (this._connecting || this._connected) {\n      const err = new Error('Client has already been connected. You cannot reuse a client.')\n      process.nextTick(() => {\n        callback(err)\n      })\n      return\n    }\n    this._connecting = true\n\n    this.connectionTimeoutHandle\n    if (this._connectionTimeoutMillis > 0) {\n      this.connectionTimeoutHandle = setTimeout(() => {\n        con._ending = true\n        con.stream.destroy(new Error('timeout expired'))\n      }, this._connectionTimeoutMillis)\n    }\n\n    if (this.host && this.host.indexOf('/') === 0) {\n      con.connect(this.host + '/.s.PGSQL.' + this.port)\n    } else {\n      con.connect(this.port, this.host)\n    }\n\n    // once connection is established send startup message\n    con.on('connect', function () {\n      if (self.ssl) {\n        con.requestSsl()\n      } else {\n        con.startup(self.getStartupConf())\n      }\n    })\n\n    con.on('sslconnect', function () {\n      con.startup(self.getStartupConf())\n    })\n\n    this._attachListeners(con)\n\n    con.once('end', () => {\n      const error = this._ending ? new Error('Connection terminated') : new Error('Connection terminated unexpectedly')\n\n      clearTimeout(this.connectionTimeoutHandle)\n      this._errorAllQueries(error)\n\n      if (!this._ending) {\n        // if the connection is ended without us calling .end()\n        // on this client then we have an unexpected disconnection\n        // treat this as an error unless we've already emitted an error\n        // during connection.\n        if (this._connecting && !this._connectionError) {\n          if (this._connectionCallback) {\n            this._connectionCallback(error)\n          } else {\n            this._handleErrorEvent(error)\n          }\n        } else if (!this._connectionError) {\n          this._handleErrorEvent(error)\n        }\n      }\n\n      process.nextTick(() => {\n        this.emit('end')\n      })\n    })\n  }\n\n  connect(callback) {\n    if (callback) {\n      this._connect(callback)\n      return\n    }\n\n    return new this._Promise((resolve, reject) => {\n      this._connect((error) => {\n        if (error) {\n          reject(error)\n        } else {\n          resolve()\n        }\n      })\n    })\n  }\n\n  _attachListeners(con) {\n    // password request handling\n    con.on('authenticationCleartextPassword', this._handleAuthCleartextPassword.bind(this))\n    // password request handling\n    con.on('authenticationMD5Password', this._handleAuthMD5Password.bind(this))\n    // password request handling (SASL)\n    con.on('authenticationSASL', this._handleAuthSASL.bind(this))\n    con.on('authenticationSASLContinue', this._handleAuthSASLContinue.bind(this))\n    con.on('authenticationSASLFinal', this._handleAuthSASLFinal.bind(this))\n    con.on('backendKeyData', this._handleBackendKeyData.bind(this))\n    con.on('error', this._handleErrorEvent.bind(this))\n    con.on('errorMessage', this._handleErrorMessage.bind(this))\n    con.on('readyForQuery', this._handleReadyForQuery.bind(this))\n    con.on('notice', this._handleNotice.bind(this))\n    con.on('rowDescription', this._handleRowDescription.bind(this))\n    con.on('dataRow', this._handleDataRow.bind(this))\n    con.on('portalSuspended', this._handlePortalSuspended.bind(this))\n    con.on('emptyQuery', this._handleEmptyQuery.bind(this))\n    con.on('commandComplete', this._handleCommandComplete.bind(this))\n    con.on('parseComplete', this._handleParseComplete.bind(this))\n    con.on('copyInResponse', this._handleCopyInResponse.bind(this))\n    con.on('copyData', this._handleCopyData.bind(this))\n    con.on('notification', this._handleNotification.bind(this))\n  }\n\n  // TODO(bmc): deprecate pgpass \"built in\" integration since this.password can be a function\n  // it can be supplied by the user if required - this is a breaking change!\n  _checkPgPass(cb) {\n    const con = this.connection\n    if (typeof this.password === 'function') {\n      this._Promise\n        .resolve()\n        .then(() => this.password())\n        .then((pass) => {\n          if (pass !== undefined) {\n            if (typeof pass !== 'string') {\n              con.emit('error', new TypeError('Password must be a string'))\n              return\n            }\n            this.connectionParameters.password = this.password = pass\n          } else {\n            this.connectionParameters.password = this.password = null\n          }\n          cb()\n        })\n        .catch((err) => {\n          con.emit('error', err)\n        })\n    } else if (this.password !== null) {\n      cb()\n    } else {\n      pgPass(this.connectionParameters, (pass) => {\n        if (undefined !== pass) {\n          this.connectionParameters.password = this.password = pass\n        }\n        cb()\n      })\n    }\n  }\n\n  _handleAuthCleartextPassword(msg) {\n    this._checkPgPass(() => {\n      this.connection.password(this.password)\n    })\n  }\n\n  _handleAuthMD5Password(msg) {\n    this._checkPgPass(() => {\n      const hashedPassword = utils.postgresMd5PasswordHash(this.user, this.password, msg.salt)\n      this.connection.password(hashedPassword)\n    })\n  }\n\n  _handleAuthSASL(msg) {\n    this._checkPgPass(() => {\n      this.saslSession = sasl.startSession(msg.mechanisms)\n      this.connection.sendSASLInitialResponseMessage(this.saslSession.mechanism, this.saslSession.response)\n    })\n  }\n\n  _handleAuthSASLContinue(msg) {\n    sasl.continueSession(this.saslSession, this.password, msg.data)\n    this.connection.sendSCRAMClientFinalMessage(this.saslSession.response)\n  }\n\n  _handleAuthSASLFinal(msg) {\n    sasl.finalizeSession(this.saslSession, msg.data)\n    this.saslSession = null\n  }\n\n  _handleBackendKeyData(msg) {\n    this.processID = msg.processID\n    this.secretKey = msg.secretKey\n  }\n\n  _handleReadyForQuery(msg) {\n    if (this._connecting) {\n      this._connecting = false\n      this._connected = true\n      clearTimeout(this.connectionTimeoutHandle)\n\n      // process possible callback argument to Client#connect\n      if (this._connectionCallback) {\n        this._connectionCallback(null, this)\n        // remove callback for proper error handling\n        // after the connect event\n        this._connectionCallback = null\n      }\n      this.emit('connect')\n    }\n    const { activeQuery } = this\n    this.activeQuery = null\n    this.readyForQuery = true\n    if (activeQuery) {\n      activeQuery.handleReadyForQuery(this.connection)\n    }\n    this._pulseQueryQueue()\n  }\n\n  // if we receieve an error event or error message\n  // during the connection process we handle it here\n  _handleErrorWhileConnecting(err) {\n    if (this._connectionError) {\n      // TODO(bmc): this is swallowing errors - we shouldn't do this\n      return\n    }\n    this._connectionError = true\n    clearTimeout(this.connectionTimeoutHandle)\n    if (this._connectionCallback) {\n      return this._connectionCallback(err)\n    }\n    this.emit('error', err)\n  }\n\n  // if we're connected and we receive an error event from the connection\n  // this means the socket is dead - do a hard abort of all queries and emit\n  // the socket error on the client as well\n  _handleErrorEvent(err) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(err)\n    }\n    this._queryable = false\n    this._errorAllQueries(err)\n    this.emit('error', err)\n  }\n\n  // handle error messages from the postgres backend\n  _handleErrorMessage(msg) {\n    if (this._connecting) {\n      return this._handleErrorWhileConnecting(msg)\n    }\n    const activeQuery = this.activeQuery\n\n    if (!activeQuery) {\n      this._handleErrorEvent(msg)\n      return\n    }\n\n    this.activeQuery = null\n    activeQuery.handleError(msg, this.connection)\n  }\n\n  _handleRowDescription(msg) {\n    // delegate rowDescription to active query\n    this.activeQuery.handleRowDescription(msg)\n  }\n\n  _handleDataRow(msg) {\n    // delegate dataRow to active query\n    this.activeQuery.handleDataRow(msg)\n  }\n\n  _handlePortalSuspended(msg) {\n    // delegate portalSuspended to active query\n    this.activeQuery.handlePortalSuspended(this.connection)\n  }\n\n  _handleEmptyQuery(msg) {\n    // delegate emptyQuery to active query\n    this.activeQuery.handleEmptyQuery(this.connection)\n  }\n\n  _handleCommandComplete(msg) {\n    // delegate commandComplete to active query\n    this.activeQuery.handleCommandComplete(msg, this.connection)\n  }\n\n  _handleParseComplete(msg) {\n    // if a prepared statement has a name and properly parses\n    // we track that its already been executed so we don't parse\n    // it again on the same client\n    if (this.activeQuery.name) {\n      this.connection.parsedStatements[this.activeQuery.name] = this.activeQuery.text\n    }\n  }\n\n  _handleCopyInResponse(msg) {\n    this.activeQuery.handleCopyInResponse(this.connection)\n  }\n\n  _handleCopyData(msg) {\n    this.activeQuery.handleCopyData(msg, this.connection)\n  }\n\n  _handleNotification(msg) {\n    this.emit('notification', msg)\n  }\n\n  _handleNotice(msg) {\n    this.emit('notice', msg)\n  }\n\n  getStartupConf() {\n    var params = this.connectionParameters\n\n    var data = {\n      user: params.user,\n      database: params.database,\n    }\n\n    var appName = params.application_name || params.fallback_application_name\n    if (appName) {\n      data.application_name = appName\n    }\n    if (params.replication) {\n      data.replication = '' + params.replication\n    }\n    if (params.statement_timeout) {\n      data.statement_timeout = String(parseInt(params.statement_timeout, 10))\n    }\n    if (params.idle_in_transaction_session_timeout) {\n      data.idle_in_transaction_session_timeout = String(parseInt(params.idle_in_transaction_session_timeout, 10))\n    }\n    if (params.options) {\n      data.options = params.options\n    }\n\n    return data\n  }\n\n  cancel(client, query) {\n    if (client.activeQuery === query) {\n      var con = this.connection\n\n      if (this.host && this.host.indexOf('/') === 0) {\n        con.connect(this.host + '/.s.PGSQL.' + this.port)\n      } else {\n        con.connect(this.port, this.host)\n      }\n\n      // once connection is established send cancel message\n      con.on('connect', function () {\n        con.cancel(client.processID, client.secretKey)\n      })\n    } else if (client.queryQueue.indexOf(query) !== -1) {\n      client.queryQueue.splice(client.queryQueue.indexOf(query), 1)\n    }\n  }\n\n  setTypeParser(oid, format, parseFn) {\n    return this._types.setTypeParser(oid, format, parseFn)\n  }\n\n  getTypeParser(oid, format) {\n    return this._types.getTypeParser(oid, format)\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeIdentifier(str) {\n    return '\"' + str.replace(/\"/g, '\"\"') + '\"'\n  }\n\n  // Ported from PostgreSQL 9.2.4 source code in src/interfaces/libpq/fe-exec.c\n  escapeLiteral(str) {\n    var hasBackslash = false\n    var escaped = \"'\"\n\n    for (var i = 0; i < str.length; i++) {\n      var c = str[i]\n      if (c === \"'\") {\n        escaped += c + c\n      } else if (c === '\\\\') {\n        escaped += c + c\n        hasBackslash = true\n      } else {\n        escaped += c\n      }\n    }\n\n    escaped += \"'\"\n\n    if (hasBackslash === true) {\n      escaped = ' E' + escaped\n    }\n\n    return escaped\n  }\n\n  _pulseQueryQueue() {\n    if (this.readyForQuery === true) {\n      this.activeQuery = this.queryQueue.shift()\n      if (this.activeQuery) {\n        this.readyForQuery = false\n        this.hasExecuted = true\n\n        const queryError = this.activeQuery.submit(this.connection)\n        if (queryError) {\n          process.nextTick(() => {\n            this.activeQuery.handleError(queryError, this.connection)\n            this.readyForQuery = true\n            this._pulseQueryQueue()\n          })\n        }\n      } else if (this.hasExecuted) {\n        this.activeQuery = null\n        this.emit('drain')\n      }\n    }\n  }\n\n  query(config, values, callback) {\n    // can take in strings, config object or query object\n    var query\n    var result\n    var readTimeout\n    var readTimeoutTimer\n    var queryCallback\n\n    if (config === null || config === undefined) {\n      throw new TypeError('Client was passed a null or undefined query')\n    } else if (typeof config.submit === 'function') {\n      readTimeout = config.query_timeout || this.connectionParameters.query_timeout\n      result = query = config\n      if (typeof values === 'function') {\n        query.callback = query.callback || values\n      }\n    } else {\n      readTimeout = this.connectionParameters.query_timeout\n      query = new Query(config, values, callback)\n      if (!query.callback) {\n        result = new this._Promise((resolve, reject) => {\n          query.callback = (err, res) => (err ? reject(err) : resolve(res))\n        })\n      }\n    }\n\n    if (readTimeout) {\n      queryCallback = query.callback\n\n      readTimeoutTimer = setTimeout(() => {\n        var error = new Error('Query read timeout')\n\n        process.nextTick(() => {\n          query.handleError(error, this.connection)\n        })\n\n        queryCallback(error)\n\n        // we already returned an error,\n        // just do nothing if query completes\n        query.callback = () => {}\n\n        // Remove from queue\n        var index = this.queryQueue.indexOf(query)\n        if (index > -1) {\n          this.queryQueue.splice(index, 1)\n        }\n\n        this._pulseQueryQueue()\n      }, readTimeout)\n\n      query.callback = (err, res) => {\n        clearTimeout(readTimeoutTimer)\n        queryCallback(err, res)\n      }\n    }\n\n    if (this.binary && !query.binary) {\n      query.binary = true\n    }\n\n    if (query._result && !query._result._types) {\n      query._result._types = this._types\n    }\n\n    if (!this._queryable) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client has encountered a connection error and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    if (this._ending) {\n      process.nextTick(() => {\n        query.handleError(new Error('Client was closed and is not queryable'), this.connection)\n      })\n      return result\n    }\n\n    this.queryQueue.push(query)\n    this._pulseQueryQueue()\n    return result\n  }\n\n  ref() {\n    this.connection.ref()\n  }\n\n  unref() {\n    this.connection.unref()\n  }\n\n  end(cb) {\n    this._ending = true\n\n    // if we have never connected, then end is a noop, callback immediately\n    if (!this.connection._connecting) {\n      if (cb) {\n        cb()\n      } else {\n        return this._Promise.resolve()\n      }\n    }\n\n    if (this.activeQuery || !this._queryable) {\n      // if we have an active query we need to force a disconnect\n      // on the socket - otherwise a hung query could block end forever\n      this.connection.stream.destroy()\n    } else {\n      this.connection.end()\n    }\n\n    if (cb) {\n      this.connection.once('end', cb)\n    } else {\n      return new this._Promise((resolve) => {\n        this.connection.once('end', resolve)\n      })\n    }\n  }\n}\n\n// expose a Query constructor\nClient.Query = Query\n\nmodule.exports = Client\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}