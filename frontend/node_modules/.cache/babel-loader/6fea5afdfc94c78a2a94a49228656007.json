{"ast":null,"code":"'use strict';\n\nconst Utils = require('./../utils');\n\nconst Helpers = require('./helpers');\n\nconst _ = require('lodash');\n\nconst Association = require('./base');\n\nconst Op = require('../operators');\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\n\n\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize([this.as, this.target.primaryKeyAttribute].join('_'));\n    }\n\n    this.identifier = this.foreignKey;\n\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (this.options.targetKey && !this.target.rawAttributes[this.options.targetKey]) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks; // Get singular name, trying to uppercase the first letter, unless the model forbids it\n\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  } // the id is in the source table\n\n\n  _injectAttributes() {\n    const newAttributes = {};\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n    this.source.refreshAttributes();\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n    Helpers.checkNamingCollision(this);\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n    Helpers.mixinMethods(this, obj, methods);\n  }\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {string}         [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n\n\n  get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ? {\n      [Op.and]: [where, options.where]\n    } : where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n\n        for (const instance of instances) {\n          result[instance.get(this.foreignKey, {\n            raw: true\n          })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.targetKey, {\n            raw: true\n          })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options={}] options passed to `this.save`\n   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   *\n   *  @returns {Promise}\n   */\n\n\n  set(sourceInstance, associatedInstance) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n    if (options.save === false) return;\n    options = Object.assign({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options); // passes the changed field to save, so only that field get updated.\n\n    return sourceInstance.save(options);\n  }\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options={}] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create}  for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n\n\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n    return this.target.create(values, options).then(newAssociatedObject => sourceInstance[this.accessors.set](newAssociatedObject, options).then(() => newAssociatedObject));\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;","map":{"version":3,"names":["Utils","require","Helpers","_","Association","Op","BelongsTo","constructor","source","target","options","associationType","isSingleAssociation","foreignKeyAttribute","as","isAliased","name","singular","isObject","foreignKey","fieldName","camelize","primaryKeyAttribute","join","identifier","rawAttributes","identifierField","field","targetKey","Error","targetKeyField","targetKeyIsPrimary","targetIdentifier","associationAccessor","useHooks","upperFirst","accessors","get","set","create","_injectAttributes","newAttributes","defaults","type","keyType","allowNull","constraints","onDelete","onUpdate","addForeignKeyConstraints","mergeDefaults","refreshAttributes","checkNamingCollision","mixin","obj","methods","mixinMethods","instances","where","Target","instance","cloneDeep","Object","prototype","hasOwnProperty","call","scope","unscoped","schema","schemaDelimiter","Array","isArray","undefined","in","map","findByPk","limit","and","findAll","then","results","result","raw","findOne","sourceInstance","associatedInstance","value","save","assign","fields","association","values","newAssociatedObject","verifyAssociationAlias","alias","module","exports","default"],"sources":["/home/brian/node_modules/sequelize/lib/associations/belongs-to.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('./../utils');\nconst Helpers = require('./helpers');\nconst _ = require('lodash');\nconst Association = require('./base');\nconst Op = require('../operators');\n\n/**\n * One-to-one association\n *\n * In the API reference below, add the name of the association to the method, e.g. for `User.belongsTo(Project)` the getter will be `user.getProject()`.\n *\n * @see {@link Model.belongsTo}\n */\nclass BelongsTo extends Association {\n  constructor(source, target, options) {\n    super(source, target, options);\n\n    this.associationType = 'BelongsTo';\n    this.isSingleAssociation = true;\n    this.foreignKeyAttribute = {};\n\n    if (this.as) {\n      this.isAliased = true;\n      this.options.name = {\n        singular: this.as\n      };\n    } else {\n      this.as = this.target.options.name.singular;\n      this.options.name = this.target.options.name;\n    }\n\n    if (_.isObject(this.options.foreignKey)) {\n      this.foreignKeyAttribute = this.options.foreignKey;\n      this.foreignKey = this.foreignKeyAttribute.name || this.foreignKeyAttribute.fieldName;\n    } else if (this.options.foreignKey) {\n      this.foreignKey = this.options.foreignKey;\n    }\n\n    if (!this.foreignKey) {\n      this.foreignKey = Utils.camelize(\n        [\n          this.as,\n          this.target.primaryKeyAttribute\n        ].join('_')\n      );\n    }\n\n    this.identifier = this.foreignKey;\n    if (this.source.rawAttributes[this.identifier]) {\n      this.identifierField = this.source.rawAttributes[this.identifier].field || this.identifier;\n    }\n\n    if (\n      this.options.targetKey\n      && !this.target.rawAttributes[this.options.targetKey]\n    ) {\n      throw new Error(`Unknown attribute \"${this.options.targetKey}\" passed as targetKey, define this attribute on model \"${this.target.name}\" first`);\n    }\n\n    this.targetKey = this.options.targetKey || this.target.primaryKeyAttribute;\n    this.targetKeyField = this.target.rawAttributes[this.targetKey].field || this.targetKey;\n    this.targetKeyIsPrimary = this.targetKey === this.target.primaryKeyAttribute;\n    this.targetIdentifier = this.targetKey;\n\n    this.associationAccessor = this.as;\n    this.options.useHooks = options.useHooks;\n\n    // Get singular name, trying to uppercase the first letter, unless the model forbids it\n    const singular = _.upperFirst(this.options.name.singular);\n\n    this.accessors = {\n      get: `get${singular}`,\n      set: `set${singular}`,\n      create: `create${singular}`\n    };\n  }\n\n  // the id is in the source table\n  _injectAttributes() {\n    const newAttributes = {};\n\n    newAttributes[this.foreignKey] = _.defaults({}, this.foreignKeyAttribute, {\n      type: this.options.keyType || this.target.rawAttributes[this.targetKey].type,\n      allowNull: true\n    });\n\n    if (this.options.constraints !== false) {\n      const source = this.source.rawAttributes[this.foreignKey] || newAttributes[this.foreignKey];\n      this.options.onDelete = this.options.onDelete || (source.allowNull ? 'SET NULL' : 'NO ACTION');\n      this.options.onUpdate = this.options.onUpdate || 'CASCADE';\n    }\n\n    Helpers.addForeignKeyConstraints(newAttributes[this.foreignKey], this.target, this.source, this.options, this.targetKeyField);\n    Utils.mergeDefaults(this.source.rawAttributes, newAttributes);\n\n    this.source.refreshAttributes();\n\n    this.identifierField = this.source.rawAttributes[this.foreignKey].field || this.foreignKey;\n\n    Helpers.checkNamingCollision(this);\n\n    return this;\n  }\n\n  mixin(obj) {\n    const methods = ['get', 'set', 'create'];\n\n    Helpers.mixinMethods(this, obj, methods);\n  }\n\n  /**\n   * Get the associated instance.\n   *\n   * @param {Model|Array<Model>} instances source instances\n   * @param {Object}         [options] find options\n   * @param {string|boolean} [options.scope]  Apply a scope on the related model, or remove its default scope by passing false.\n   * @param {string}         [options.schema] Apply a schema on the related model\n   *\n   * @see\n   * {@link Model.findOne} for a full explanation of options\n   *\n   * @returns {Promise<Model>}\n   */\n  get(instances, options) {\n    const where = {};\n    let Target = this.target;\n    let instance;\n\n    options = Utils.cloneDeep(options);\n\n    if (Object.prototype.hasOwnProperty.call(options, 'scope')) {\n      if (!options.scope) {\n        Target = Target.unscoped();\n      } else {\n        Target = Target.scope(options.scope);\n      }\n    }\n\n    if (Object.prototype.hasOwnProperty.call(options, 'schema')) {\n      Target = Target.schema(options.schema, options.schemaDelimiter);\n    }\n\n    if (!Array.isArray(instances)) {\n      instance = instances;\n      instances = undefined;\n    }\n\n    if (instances) {\n      where[this.targetKey] = {\n        [Op.in]: instances.map(instance => instance.get(this.foreignKey))\n      };\n    } else {\n      if (this.targetKeyIsPrimary && !options.where) {\n        return Target.findByPk(instance.get(this.foreignKey), options);\n      }\n      where[this.targetKey] = instance.get(this.foreignKey);\n      options.limit = null;\n    }\n\n    options.where = options.where ?\n      { [Op.and]: [where, options.where] } :\n      where;\n\n    if (instances) {\n      return Target.findAll(options).then(results => {\n        const result = {};\n        for (const instance of instances) {\n          result[instance.get(this.foreignKey, { raw: true })] = null;\n        }\n\n        for (const instance of results) {\n          result[instance.get(this.targetKey, { raw: true })] = instance;\n        }\n\n        return result;\n      });\n    }\n\n    return Target.findOne(options);\n  }\n\n  /**\n   * Set the associated model.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {?<Model>|string|number} [associatedInstance] An persisted instance or the primary key of an instance to associate with this. Pass `null` or `undefined` to remove the association.\n   * @param {Object} [options={}] options passed to `this.save`\n   * @param {boolean} [options.save=true] Skip saving this after setting the foreign key if false.\n   *\n   *  @returns {Promise}\n   */\n  set(sourceInstance, associatedInstance, options = {}) {\n    let value = associatedInstance;\n\n    if (associatedInstance instanceof this.target) {\n      value = associatedInstance[this.targetKey];\n    }\n\n    sourceInstance.set(this.foreignKey, value);\n\n    if (options.save === false) return;\n\n    options = Object.assign({\n      fields: [this.foreignKey],\n      allowNull: [this.foreignKey],\n      association: true\n    }, options);\n\n    // passes the changed field to save, so only that field get updated.\n    return sourceInstance.save(options);\n  }\n\n  /**\n   * Create a new instance of the associated model and associate it with this.\n   *\n   * @param {Model} sourceInstance the source instance\n   * @param {Object} [values={}] values to create associated model instance with\n   * @param {Object} [options={}] Options passed to `target.create` and setAssociation.\n   *\n   * @see\n   * {@link Model#create}  for a full explanation of options\n   *\n   * @returns {Promise<Model>} The created target model\n   */\n  create(sourceInstance, values, options) {\n    values = values || {};\n    options = options || {};\n\n    return this.target.create(values, options)\n      .then(newAssociatedObject => sourceInstance[this.accessors.set](newAssociatedObject, options)\n        .then(() => newAssociatedObject)\n      );\n  }\n\n  verifyAssociationAlias(alias) {\n    if (typeof alias === 'string') {\n      return this.as === alias;\n    }\n\n    if (alias && alias.singular) {\n      return this.as === alias.singular;\n    }\n\n    return !this.isAliased;\n  }\n}\n\nmodule.exports = BelongsTo;\nmodule.exports.BelongsTo = BelongsTo;\nmodule.exports.default = BelongsTo;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}