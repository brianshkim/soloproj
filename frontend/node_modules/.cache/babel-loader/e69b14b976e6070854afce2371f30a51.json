{"ast":null,"code":"'use strict';\n\nconst Promise = require('./promise');\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\n\n\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = []; // get dialect specific transaction options\n\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n    this.options = Object.assign({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n\n\n  commit() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`));\n    }\n\n    this._clearCls();\n\n    return this.sequelize.getQueryInterface().commitTransaction(this, this.options).finally(() => {\n      this.finished = 'commit';\n\n      if (!this.parent) {\n        return this.cleanup();\n      }\n\n      return null;\n    }).tap(() => Promise.each(this._afterCommitHooks, hook => Promise.resolve(hook.apply(this, [this]))));\n  }\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n\n\n  rollback() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`));\n    }\n\n    if (!this.connection) {\n      return Promise.reject(new Error('Transaction cannot be rolled back because it never started'));\n    }\n\n    this._clearCls();\n\n    return this.sequelize.getQueryInterface().rollbackTransaction(this, this.options).finally(() => {\n      if (!this.parent) {\n        return this.cleanup();\n      }\n\n      return this;\n    });\n  }\n\n  prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = {\n        uuid: this.id\n      };\n\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise.then(connection => {\n      this.connection = connection;\n      this.connection.uuid = this.id;\n    }).then(() => {\n      return this.begin().then(() => this.setDeferrable()).catch(setupErr => this.rollback().finally(() => {\n        throw setupErr;\n      }));\n    }).tap(() => {\n      if (useCLS && this.sequelize.constructor._cls) {\n        this.sequelize.constructor._cls.set('transaction', this);\n      }\n\n      return null;\n    });\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this.sequelize.getQueryInterface().deferConstraints(this, this.options);\n    }\n  }\n\n  begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if (this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction) {\n      return queryInterface.startTransaction(this, this.options).then(() => {\n        return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n      });\n    }\n\n    return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options).then(() => {\n      return queryInterface.startTransaction(this, this.options);\n    });\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n\n\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n\n    this._afterCommitHooks.push(fn);\n  }\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n\n\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n\n\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n\n\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n\n\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;","map":{"version":3,"names":["Promise","require","Transaction","constructor","sequelize","options","savepoints","_afterCommitHooks","generateTransactionId","dialect","QueryGenerator","Object","assign","type","transactionType","isolationLevel","readOnly","parent","transaction","id","push","name","length","commit","finished","reject","Error","_clearCls","getQueryInterface","commitTransaction","finally","cleanup","tap","each","hook","resolve","apply","rollback","connection","rollbackTransaction","prepareEnvironment","useCLS","connectionPromise","undefined","acquireOptions","uuid","connectionManager","getConnection","then","begin","setDeferrable","catch","setupErr","_cls","set","deferrable","deferConstraints","queryInterface","supports","settingIsolationLevelDuringTransaction","startTransaction","setIsolationLevel","res","releaseConnection","cls","get","afterCommit","fn","TYPES","DEFERRED","IMMEDIATE","EXCLUSIVE","ISOLATION_LEVELS","READ_UNCOMMITTED","READ_COMMITTED","REPEATABLE_READ","SERIALIZABLE","LOCK","UPDATE","SHARE","KEY_SHARE","NO_KEY_UPDATE","module","exports","default"],"sources":["/home/brian/node_modules/sequelize/lib/transaction.js"],"sourcesContent":["'use strict';\n\nconst Promise = require('./promise');\n\n/**\n * The transaction object is used to identify a running transaction.\n * It is created by calling `Sequelize.transaction()`.\n * To run a query under a transaction, you should pass the transaction in the options object.\n *\n * @class Transaction\n * @see {@link Sequelize.transaction}\n */\nclass Transaction {\n  /**\n   * Creates a new transaction instance\n   *\n   * @param {Sequelize} sequelize A configured sequelize Instance\n   * @param {Object} options An object with options\n   * @param {string} [options.type] Sets the type of the transaction. Sqlite only\n   * @param {string} [options.isolationLevel] Sets the isolation level of the transaction.\n   * @param {string} [options.deferrable] Sets the constraints to be deferred or immediately checked. PostgreSQL only\n   */\n  constructor(sequelize, options) {\n    this.sequelize = sequelize;\n    this.savepoints = [];\n    this._afterCommitHooks = [];\n\n    // get dialect specific transaction options\n    const generateTransactionId = this.sequelize.dialect.QueryGenerator.generateTransactionId;\n\n    this.options = Object.assign({\n      type: sequelize.options.transactionType,\n      isolationLevel: sequelize.options.isolationLevel,\n      readOnly: false\n    }, options || {});\n\n    this.parent = this.options.transaction;\n\n    if (this.parent) {\n      this.id = this.parent.id;\n      this.parent.savepoints.push(this);\n      this.name = `${this.id}-sp-${this.parent.savepoints.length}`;\n    } else {\n      this.id = this.name = generateTransactionId();\n    }\n\n    delete this.options.transaction;\n  }\n\n  /**\n   * Commit the transaction\n   *\n   * @returns {Promise}\n   */\n  commit() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be committed because it has been finished with state: ${this.finished}`));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .commitTransaction(this, this.options)\n      .finally(() => {\n        this.finished = 'commit';\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return null;\n      }).tap(\n        () => Promise.each(\n          this._afterCommitHooks,\n          hook => Promise.resolve(hook.apply(this, [this])))\n      );\n  }\n\n  /**\n   * Rollback (abort) the transaction\n   *\n   * @returns {Promise}\n   */\n  rollback() {\n    if (this.finished) {\n      return Promise.reject(new Error(`Transaction cannot be rolled back because it has been finished with state: ${this.finished}`));\n    }\n\n    if (!this.connection) {\n      return Promise.reject(new Error('Transaction cannot be rolled back because it never started'));\n    }\n\n    this._clearCls();\n\n    return this\n      .sequelize\n      .getQueryInterface()\n      .rollbackTransaction(this, this.options)\n      .finally(() => {\n        if (!this.parent) {\n          return this.cleanup();\n        }\n        return this;\n      });\n  }\n\n  prepareEnvironment(useCLS) {\n    let connectionPromise;\n\n    if (useCLS === undefined) {\n      useCLS = true;\n    }\n\n    if (this.parent) {\n      connectionPromise = Promise.resolve(this.parent.connection);\n    } else {\n      const acquireOptions = { uuid: this.id };\n      if (this.options.readOnly) {\n        acquireOptions.type = 'SELECT';\n      }\n      connectionPromise = this.sequelize.connectionManager.getConnection(acquireOptions);\n    }\n\n    return connectionPromise\n      .then(connection => {\n        this.connection = connection;\n        this.connection.uuid = this.id;\n      })\n      .then(() => {\n        return this.begin()\n          .then(() => this.setDeferrable())\n          .catch(setupErr => this.rollback().finally(() => {\n            throw setupErr;\n          }));\n      })\n      .tap(() => {\n        if (useCLS && this.sequelize.constructor._cls) {\n          this.sequelize.constructor._cls.set('transaction', this);\n        }\n        return null;\n      });\n  }\n\n  setDeferrable() {\n    if (this.options.deferrable) {\n      return this\n        .sequelize\n        .getQueryInterface()\n        .deferConstraints(this, this.options);\n    }\n  }\n\n  begin() {\n    const queryInterface = this.sequelize.getQueryInterface();\n\n    if ( this.sequelize.dialect.supports.settingIsolationLevelDuringTransaction ) {\n      return queryInterface.startTransaction(this, this.options).then(() => {\n        return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options);\n      });\n    }\n\n    return queryInterface.setIsolationLevel(this, this.options.isolationLevel, this.options).then(() => {\n      return queryInterface.startTransaction(this, this.options);\n    });\n  }\n\n  cleanup() {\n    const res = this.sequelize.connectionManager.releaseConnection(this.connection);\n    this.connection.uuid = undefined;\n    return res;\n  }\n\n  _clearCls() {\n    const cls = this.sequelize.constructor._cls;\n\n    if (cls) {\n      if (cls.get('transaction') === this) {\n        cls.set('transaction', null);\n      }\n    }\n  }\n\n  /**\n   * A hook that is run after a transaction is committed\n   *\n   * @param {Function} fn   A callback function that is called with the committed transaction\n   * @name afterCommit\n   * @memberof Sequelize.Transaction\n   */\n  afterCommit(fn) {\n    if (!fn || typeof fn !== 'function') {\n      throw new Error('\"fn\" must be a function');\n    }\n    this._afterCommitHooks.push(fn);\n  }\n\n  /**\n   * Types can be set per-transaction by passing `options.type` to `sequelize.transaction`.\n   * Default to `DEFERRED` but you can override the default type by passing `options.transactionType` in `new Sequelize`.\n   * Sqlite only.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({type: Sequelize.Transaction.TYPES.EXCLUSIVE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property DEFERRED\n   * @property IMMEDIATE\n   * @property EXCLUSIVE\n   */\n  static get TYPES() {\n    return {\n      DEFERRED: 'DEFERRED',\n      IMMEDIATE: 'IMMEDIATE',\n      EXCLUSIVE: 'EXCLUSIVE'\n    };\n  }\n\n  /**\n   * Isolation levels can be set per-transaction by passing `options.isolationLevel` to `sequelize.transaction`.\n   * Sequelize uses the default isolation level of the database, you can override this by passing `options.isolationLevel` in Sequelize constructor options.\n   *\n   * Pass in the desired level as the first argument:\n   *\n   * @example\n   * return sequelize.transaction({isolationLevel: Sequelize.Transaction.ISOLATION_LEVELS.SERIALIZABLE}, transaction => {\n   *   // your transactions\n   * }).then(result => {\n   *   // transaction has been committed. Do something after the commit if required.\n   * }).catch(err => {\n   *   // do something with the err.\n   * });\n   *\n   * @property READ_UNCOMMITTED\n   * @property READ_COMMITTED\n   * @property REPEATABLE_READ\n   * @property SERIALIZABLE\n   */\n  static get ISOLATION_LEVELS() {\n    return {\n      READ_UNCOMMITTED: 'READ UNCOMMITTED',\n      READ_COMMITTED: 'READ COMMITTED',\n      REPEATABLE_READ: 'REPEATABLE READ',\n      SERIALIZABLE: 'SERIALIZABLE'\n    };\n  }\n\n\n  /**\n   * Possible options for row locking. Used in conjunction with `find` calls:\n   *\n   * @example\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: t1.LOCK...\n   * });\n   *\n   * @example <caption>Postgres also supports specific locks while eager loading by using OF:</caption>\n   * UserModel.findAll({\n   *   where: ...,\n   *   include: [TaskModel, ...],\n   *   transaction: t1,\n   *   lock: {\n   *     level: t1.LOCK...,\n   *     of: UserModel\n   *   }\n   * });\n   *\n   * # UserModel will be locked but TaskModel won't!\n   *\n   * @example <caption>You can also skip locked rows:</caption>\n   * // t1 is a transaction\n   * Model.findAll({\n   *   where: ...,\n   *   transaction: t1,\n   *   lock: true,\n   *   skipLocked: true\n   * });\n   * # The query will now return any rows that aren't locked by another transaction\n   *\n   * @returns {Object}\n   * @property UPDATE\n   * @property SHARE\n   * @property KEY_SHARE Postgres 9.3+ only\n   * @property NO_KEY_UPDATE Postgres 9.3+ only\n   */\n  static get LOCK() {\n    return {\n      UPDATE: 'UPDATE',\n      SHARE: 'SHARE',\n      KEY_SHARE: 'KEY SHARE',\n      NO_KEY_UPDATE: 'NO KEY UPDATE'\n    };\n  }\n\n  /**\n   * Please see {@link Transaction.LOCK}\n   */\n  get LOCK() {\n    return Transaction.LOCK;\n  }\n}\n\nmodule.exports = Transaction;\nmodule.exports.Transaction = Transaction;\nmodule.exports.default = Transaction;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}