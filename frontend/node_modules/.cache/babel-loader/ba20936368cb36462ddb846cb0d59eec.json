{"ast":null,"code":"var parseInt64 = require('pg-int8');\n\nvar parseBits = function (data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n\n  callback = callback || function (lastValue, newValue, bits) {\n    return lastValue * Math.pow(2, bits) + newValue;\n  };\n\n  var offsetBytes = offset >> 3;\n\n  var inv = function (value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  }; // read first (maybe partial) byte\n\n\n  var mask = 0xff;\n  var firstBits = 8 - offset % 8;\n\n  if (bits < firstBits) {\n    mask = 0xff << 8 - bits & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> offset % 8;\n  }\n\n  var result = 0;\n\n  if (offset % 8 + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  } // read bytes\n\n\n  var bytes = bits + offset >> 3;\n\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  } // bits to read, that are not a complete byte\n\n\n  var lastBits = (bits + offset) % 8;\n\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> 8 - lastBits, lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function (data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  } // parse mantissa\n\n\n  var precisionBitsCounter = 1;\n\n  var parsePrecisionBits = function (lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n\n      if ((newValue & 0x1 << bits - i) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits); // special cases\n\n  if (exponent == Math.pow(2, exponentBits + 1) - 1) {\n    if (mantissa === 0) {\n      return sign === 0 ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  } // normale number\n\n\n  return (sign === 0 ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function (value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function (value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function (value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function (value) {\n  var sign = parseBits(value, 16, 32);\n\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + 16 * i) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return (sign === 0 ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function (isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1); // discard usecs and shift from 2000 to 1970\n\n  var result = new Date((sign === 0 ? 1 : -1) * rawValue / 1000 + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  } // add microseconds to the date\n\n\n  result.usec = rawValue % 1000;\n\n  result.getMicroSeconds = function () {\n    return this.usec;\n  };\n\n  result.setMicroSeconds = function (value) {\n    this.usec = value;\n  };\n\n  result.getUTCMicroSeconds = function () {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function (value) {\n  var dim = parseBits(value, 32);\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n  var offset = 96;\n  var dims = [];\n\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32; // ignore lower bounds\n\n    offset += 32;\n  }\n\n  var parseElement = function (elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32; // parse null values\n\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n\n    if (elementType == 0x17 || elementType == 0x14) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    } else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += length << 3) >> 3);\n      return result;\n    } else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function (dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n\n      dimension.unshift(count);\n    } else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function (value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function (value) {\n  if (value === null) return null;\n  return parseBits(value, 8) > 0;\n};\n\nvar init = function (register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};","map":{"version":3,"names":["parseInt64","require","parseBits","data","bits","offset","invert","callback","lastValue","newValue","Math","pow","offsetBytes","inv","value","mask","firstBits","result","bytes","i","lastBits","parseFloatFromBits","precisionBits","exponentBits","bias","sign","exponent","precisionBitsCounter","parsePrecisionBits","mantissa","Infinity","NaN","parseInt16","parseInt32","parseFloat32","parseFloat64","parseNumeric","weight","digits","ndigits","scale","round","parseDate","isUTC","rawValue","Date","setTime","getTime","getTimezoneOffset","usec","getMicroSeconds","setMicroSeconds","getUTCMicroSeconds","parseArray","dim","flags","elementType","dims","parseElement","length","toString","encoding","console","log","parse","dimension","array","count","shift","unshift","parseText","parseBool","init","register","bind","module","exports"],"sources":["/home/brian/node_modules/pg-types/lib/binaryParsers.js"],"sourcesContent":["var parseInt64 = require('pg-int8');\n\nvar parseBits = function(data, bits, offset, invert, callback) {\n  offset = offset || 0;\n  invert = invert || false;\n  callback = callback || function(lastValue, newValue, bits) { return (lastValue * Math.pow(2, bits)) + newValue; };\n  var offsetBytes = offset >> 3;\n\n  var inv = function(value) {\n    if (invert) {\n      return ~value & 0xff;\n    }\n\n    return value;\n  };\n\n  // read first (maybe partial) byte\n  var mask = 0xff;\n  var firstBits = 8 - (offset % 8);\n  if (bits < firstBits) {\n    mask = (0xff << (8 - bits)) & 0xff;\n    firstBits = bits;\n  }\n\n  if (offset) {\n    mask = mask >> (offset % 8);\n  }\n\n  var result = 0;\n  if ((offset % 8) + bits >= 8) {\n    result = callback(0, inv(data[offsetBytes]) & mask, firstBits);\n  }\n\n  // read bytes\n  var bytes = (bits + offset) >> 3;\n  for (var i = offsetBytes + 1; i < bytes; i++) {\n    result = callback(result, inv(data[i]), 8);\n  }\n\n  // bits to read, that are not a complete byte\n  var lastBits = (bits + offset) % 8;\n  if (lastBits > 0) {\n    result = callback(result, inv(data[bytes]) >> (8 - lastBits), lastBits);\n  }\n\n  return result;\n};\n\nvar parseFloatFromBits = function(data, precisionBits, exponentBits) {\n  var bias = Math.pow(2, exponentBits - 1) - 1;\n  var sign = parseBits(data, 1);\n  var exponent = parseBits(data, exponentBits, 1);\n\n  if (exponent === 0) {\n    return 0;\n  }\n\n  // parse mantissa\n  var precisionBitsCounter = 1;\n  var parsePrecisionBits = function(lastValue, newValue, bits) {\n    if (lastValue === 0) {\n      lastValue = 1;\n    }\n\n    for (var i = 1; i <= bits; i++) {\n      precisionBitsCounter /= 2;\n      if ((newValue & (0x1 << (bits - i))) > 0) {\n        lastValue += precisionBitsCounter;\n      }\n    }\n\n    return lastValue;\n  };\n\n  var mantissa = parseBits(data, precisionBits, exponentBits + 1, false, parsePrecisionBits);\n\n  // special cases\n  if (exponent == (Math.pow(2, exponentBits + 1) - 1)) {\n    if (mantissa === 0) {\n      return (sign === 0) ? Infinity : -Infinity;\n    }\n\n    return NaN;\n  }\n\n  // normale number\n  return ((sign === 0) ? 1 : -1) * Math.pow(2, exponent - bias) * mantissa;\n};\n\nvar parseInt16 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 15, 1, true) + 1);\n  }\n\n  return parseBits(value, 15, 1);\n};\n\nvar parseInt32 = function(value) {\n  if (parseBits(value, 1) == 1) {\n    return -1 * (parseBits(value, 31, 1, true) + 1);\n  }\n\n  return parseBits(value, 31, 1);\n};\n\nvar parseFloat32 = function(value) {\n  return parseFloatFromBits(value, 23, 8);\n};\n\nvar parseFloat64 = function(value) {\n  return parseFloatFromBits(value, 52, 11);\n};\n\nvar parseNumeric = function(value) {\n  var sign = parseBits(value, 16, 32);\n  if (sign == 0xc000) {\n    return NaN;\n  }\n\n  var weight = Math.pow(10000, parseBits(value, 16, 16));\n  var result = 0;\n\n  var digits = [];\n  var ndigits = parseBits(value, 16);\n  for (var i = 0; i < ndigits; i++) {\n    result += parseBits(value, 16, 64 + (16 * i)) * weight;\n    weight /= 10000;\n  }\n\n  var scale = Math.pow(10, parseBits(value, 16, 48));\n  return ((sign === 0) ? 1 : -1) * Math.round(result * scale) / scale;\n};\n\nvar parseDate = function(isUTC, value) {\n  var sign = parseBits(value, 1);\n  var rawValue = parseBits(value, 63, 1);\n\n  // discard usecs and shift from 2000 to 1970\n  var result = new Date((((sign === 0) ? 1 : -1) * rawValue / 1000) + 946684800000);\n\n  if (!isUTC) {\n    result.setTime(result.getTime() + result.getTimezoneOffset() * 60000);\n  }\n\n  // add microseconds to the date\n  result.usec = rawValue % 1000;\n  result.getMicroSeconds = function() {\n    return this.usec;\n  };\n  result.setMicroSeconds = function(value) {\n    this.usec = value;\n  };\n  result.getUTCMicroSeconds = function() {\n    return this.usec;\n  };\n\n  return result;\n};\n\nvar parseArray = function(value) {\n  var dim = parseBits(value, 32);\n\n  var flags = parseBits(value, 32, 32);\n  var elementType = parseBits(value, 32, 64);\n\n  var offset = 96;\n  var dims = [];\n  for (var i = 0; i < dim; i++) {\n    // parse dimension\n    dims[i] = parseBits(value, 32, offset);\n    offset += 32;\n\n    // ignore lower bounds\n    offset += 32;\n  }\n\n  var parseElement = function(elementType) {\n    // parse content length\n    var length = parseBits(value, 32, offset);\n    offset += 32;\n\n    // parse null values\n    if (length == 0xffffffff) {\n      return null;\n    }\n\n    var result;\n    if ((elementType == 0x17) || (elementType == 0x14)) {\n      // int/bigint\n      result = parseBits(value, length * 8, offset);\n      offset += length * 8;\n      return result;\n    }\n    else if (elementType == 0x19) {\n      // string\n      result = value.toString(this.encoding, offset >> 3, (offset += (length << 3)) >> 3);\n      return result;\n    }\n    else {\n      console.log(\"ERROR: ElementType not implemented: \" + elementType);\n    }\n  };\n\n  var parse = function(dimension, elementType) {\n    var array = [];\n    var i;\n\n    if (dimension.length > 1) {\n      var count = dimension.shift();\n      for (i = 0; i < count; i++) {\n        array[i] = parse(dimension, elementType);\n      }\n      dimension.unshift(count);\n    }\n    else {\n      for (i = 0; i < dimension[0]; i++) {\n        array[i] = parseElement(elementType);\n      }\n    }\n\n    return array;\n  };\n\n  return parse(dims, elementType);\n};\n\nvar parseText = function(value) {\n  return value.toString('utf8');\n};\n\nvar parseBool = function(value) {\n  if(value === null) return null;\n  return (parseBits(value, 8) > 0);\n};\n\nvar init = function(register) {\n  register(20, parseInt64);\n  register(21, parseInt16);\n  register(23, parseInt32);\n  register(26, parseInt32);\n  register(1700, parseNumeric);\n  register(700, parseFloat32);\n  register(701, parseFloat64);\n  register(16, parseBool);\n  register(1114, parseDate.bind(null, false));\n  register(1184, parseDate.bind(null, true));\n  register(1000, parseArray);\n  register(1007, parseArray);\n  register(1016, parseArray);\n  register(1008, parseArray);\n  register(1009, parseArray);\n  register(25, parseText);\n};\n\nmodule.exports = {\n  init: init\n};\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}