{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Parser = void 0;\n\nconst messages_1 = require(\"./messages\");\n\nconst buffer_reader_1 = require(\"./buffer-reader\");\n\nconst assert_1 = __importDefault(require(\"assert\")); // every message is prefixed with a single bye\n\n\nconst CODE_LENGTH = 1; // every message has an int32 length which includes itself but does\n// NOT include the code in the length\n\nconst LEN_LENGTH = 4;\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH;\nconst emptyBuffer = Buffer.allocUnsafe(0);\n\nclass Parser {\n  constructor(opts) {\n    this.buffer = emptyBuffer;\n    this.bufferLength = 0;\n    this.bufferOffset = 0;\n    this.reader = new buffer_reader_1.BufferReader();\n\n    if ((opts === null || opts === void 0 ? void 0 : opts.mode) === 'binary') {\n      throw new Error('Binary mode not supported yet');\n    }\n\n    this.mode = (opts === null || opts === void 0 ? void 0 : opts.mode) || 'text';\n  }\n\n  parse(buffer, callback) {\n    this.mergeBuffer(buffer);\n    const bufferFullLength = this.bufferOffset + this.bufferLength;\n    let offset = this.bufferOffset;\n\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]; // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH);\n      const fullMessageLength = CODE_LENGTH + length;\n\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer);\n        callback(message);\n        offset += fullMessageLength;\n      } else {\n        break;\n      }\n    }\n\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer;\n      this.bufferLength = 0;\n      this.bufferOffset = 0;\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset;\n      this.bufferOffset = offset;\n    }\n  }\n\n  mergeBuffer(buffer) {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength;\n      const newFullLength = newLength + this.bufferOffset;\n\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer;\n\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer;\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2;\n\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2;\n          }\n\n          newBuffer = Buffer.allocUnsafe(newBufferLength);\n        } // Move the remaining buffer to the new one\n\n\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength);\n        this.buffer = newBuffer;\n        this.bufferOffset = 0;\n      } // Concat the new buffer with the remaining one\n\n\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength);\n      this.bufferLength = newLength;\n    } else {\n      this.buffer = buffer;\n      this.bufferOffset = 0;\n      this.bufferLength = buffer.byteLength;\n    }\n  }\n\n  handlePacket(offset, code, length, bytes) {\n    switch (code) {\n      case 50\n      /* BindComplete */\n      :\n        return messages_1.bindComplete;\n\n      case 49\n      /* ParseComplete */\n      :\n        return messages_1.parseComplete;\n\n      case 51\n      /* CloseComplete */\n      :\n        return messages_1.closeComplete;\n\n      case 110\n      /* NoData */\n      :\n        return messages_1.noData;\n\n      case 115\n      /* PortalSuspended */\n      :\n        return messages_1.portalSuspended;\n\n      case 99\n      /* CopyDone */\n      :\n        return messages_1.copyDone;\n\n      case 87\n      /* ReplicationStart */\n      :\n        return messages_1.replicationStart;\n\n      case 73\n      /* EmptyQuery */\n      :\n        return messages_1.emptyQuery;\n\n      case 68\n      /* DataRow */\n      :\n        return this.parseDataRowMessage(offset, length, bytes);\n\n      case 67\n      /* CommandComplete */\n      :\n        return this.parseCommandCompleteMessage(offset, length, bytes);\n\n      case 90\n      /* ReadyForQuery */\n      :\n        return this.parseReadyForQueryMessage(offset, length, bytes);\n\n      case 65\n      /* NotificationResponse */\n      :\n        return this.parseNotificationMessage(offset, length, bytes);\n\n      case 82\n      /* AuthenticationResponse */\n      :\n        return this.parseAuthenticationResponse(offset, length, bytes);\n\n      case 83\n      /* ParameterStatus */\n      :\n        return this.parseParameterStatusMessage(offset, length, bytes);\n\n      case 75\n      /* BackendKeyData */\n      :\n        return this.parseBackendKeyData(offset, length, bytes);\n\n      case 69\n      /* ErrorMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, 'error');\n\n      case 78\n      /* NoticeMessage */\n      :\n        return this.parseErrorMessage(offset, length, bytes, 'notice');\n\n      case 84\n      /* RowDescriptionMessage */\n      :\n        return this.parseRowDescriptionMessage(offset, length, bytes);\n\n      case 116\n      /* ParameterDescriptionMessage */\n      :\n        return this.parseParameterDescriptionMessage(offset, length, bytes);\n\n      case 71\n      /* CopyIn */\n      :\n        return this.parseCopyInMessage(offset, length, bytes);\n\n      case 72\n      /* CopyOut */\n      :\n        return this.parseCopyOutMessage(offset, length, bytes);\n\n      case 100\n      /* CopyData */\n      :\n        return this.parseCopyData(offset, length, bytes);\n\n      default:\n        assert_1.default.fail(`unknown message code: ${code.toString(16)}`);\n    }\n  }\n\n  parseReadyForQueryMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const status = this.reader.string(1);\n    return new messages_1.ReadyForQueryMessage(length, status);\n  }\n\n  parseCommandCompleteMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const text = this.reader.cstring();\n    return new messages_1.CommandCompleteMessage(length, text);\n  }\n\n  parseCopyData(offset, length, bytes) {\n    const chunk = bytes.slice(offset, offset + (length - 4));\n    return new messages_1.CopyDataMessage(length, chunk);\n  }\n\n  parseCopyInMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse');\n  }\n\n  parseCopyOutMessage(offset, length, bytes) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse');\n  }\n\n  parseCopyMessage(offset, length, bytes, messageName) {\n    this.reader.setBuffer(offset, bytes);\n    const isBinary = this.reader.byte() !== 0;\n    const columnCount = this.reader.int16();\n    const message = new messages_1.CopyResponse(length, messageName, isBinary, columnCount);\n\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16();\n    }\n\n    return message;\n  }\n\n  parseNotificationMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processId = this.reader.int32();\n    const channel = this.reader.cstring();\n    const payload = this.reader.cstring();\n    return new messages_1.NotificationResponseMessage(length, processId, channel, payload);\n  }\n\n  parseRowDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const message = new messages_1.RowDescriptionMessage(length, fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField();\n    }\n\n    return message;\n  }\n\n  parseField() {\n    const name = this.reader.cstring();\n    const tableID = this.reader.int32();\n    const columnID = this.reader.int16();\n    const dataTypeID = this.reader.int32();\n    const dataTypeSize = this.reader.int16();\n    const dataTypeModifier = this.reader.int32();\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary';\n    return new messages_1.Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode);\n  }\n\n  parseParameterDescriptionMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const parameterCount = this.reader.int16();\n    const message = new messages_1.ParameterDescriptionMessage(length, parameterCount);\n\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32();\n    }\n\n    return message;\n  }\n\n  parseDataRowMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const fieldCount = this.reader.int16();\n    const fields = new Array(fieldCount);\n\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32(); // a -1 for length means the value of the field is null\n\n      fields[i] = len === -1 ? null : this.reader.string(len);\n    }\n\n    return new messages_1.DataRowMessage(length, fields);\n  }\n\n  parseParameterStatusMessage(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const name = this.reader.cstring();\n    const value = this.reader.cstring();\n    return new messages_1.ParameterStatusMessage(length, name, value);\n  }\n\n  parseBackendKeyData(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const processID = this.reader.int32();\n    const secretKey = this.reader.int32();\n    return new messages_1.BackendKeyDataMessage(length, processID, secretKey);\n  }\n\n  parseAuthenticationResponse(offset, length, bytes) {\n    this.reader.setBuffer(offset, bytes);\n    const code = this.reader.int32(); // TODO(bmc): maybe better types here\n\n    const message = {\n      name: 'authenticationOk',\n      length\n    };\n\n    switch (code) {\n      case 0:\n        // AuthenticationOk\n        break;\n\n      case 3:\n        // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword';\n        }\n\n        break;\n\n      case 5:\n        // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password';\n          const salt = this.reader.bytes(4);\n          return new messages_1.AuthenticationMD5Password(length, salt);\n        }\n\n        break;\n\n      case 10:\n        // AuthenticationSASL\n        message.name = 'authenticationSASL';\n        message.mechanisms = [];\n        let mechanism;\n\n        do {\n          mechanism = this.reader.cstring();\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism);\n          }\n        } while (mechanism);\n\n        break;\n\n      case 11:\n        // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue';\n        message.data = this.reader.string(length - 8);\n        break;\n\n      case 12:\n        // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal';\n        message.data = this.reader.string(length - 8);\n        break;\n\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code);\n    }\n\n    return message;\n  }\n\n  parseErrorMessage(offset, length, bytes, name) {\n    this.reader.setBuffer(offset, bytes);\n    const fields = {};\n    let fieldType = this.reader.string(1);\n\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring();\n      fieldType = this.reader.string(1);\n    }\n\n    const messageValue = fields.M;\n    const message = name === 'notice' ? new messages_1.NoticeMessage(length, messageValue) : new messages_1.DatabaseError(messageValue, length, name);\n    message.severity = fields.S;\n    message.code = fields.C;\n    message.detail = fields.D;\n    message.hint = fields.H;\n    message.position = fields.P;\n    message.internalPosition = fields.p;\n    message.internalQuery = fields.q;\n    message.where = fields.W;\n    message.schema = fields.s;\n    message.table = fields.t;\n    message.column = fields.c;\n    message.dataType = fields.d;\n    message.constraint = fields.n;\n    message.file = fields.F;\n    message.line = fields.L;\n    message.routine = fields.R;\n    return message;\n  }\n\n}\n\nexports.Parser = Parser;","map":{"version":3,"mappings":";;;;;;;;;;;;;AACA;;AA2BA;;AACA,oD,CAEA;;;AACA,MAAMA,WAAW,GAAG,CAApB,C,CACA;AACA;;AACA,MAAMC,UAAU,GAAG,CAAnB;AAEA,MAAMC,aAAa,GAAGF,WAAW,GAAGC,UAApC;AAOA,MAAME,WAAW,GAAGC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAApB;;AAiCA,MAAaC,MAAb,CAAmB;EAOjBC,YAAYC,IAAZ,EAAgC;IANxB,cAAiBL,WAAjB;IACA,oBAAuB,CAAvB;IACA,oBAAuB,CAAvB;IACA,cAAS,IAAIM,4BAAJ,EAAT;;IAIN,IAAI,KAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEC,IAAN,MAAe,QAAnB,EAA6B;MAC3B,MAAM,IAAIC,KAAJ,CAAU,+BAAV,CAAN;IACD;;IACD,KAAKD,IAAL,GAAY,KAAI,SAAJ,QAAI,WAAJ,GAAI,MAAJ,OAAI,CAAEA,IAAN,KAAc,MAA1B;EACD;;EAEME,KAAK,CAACC,MAAD,EAAiBC,QAAjB,EAA0C;IACpD,KAAKC,WAAL,CAAiBF,MAAjB;IACA,MAAMG,gBAAgB,GAAG,KAAKC,YAAL,GAAoB,KAAKC,YAAlD;IACA,IAAIC,MAAM,GAAG,KAAKF,YAAlB;;IACA,OAAOE,MAAM,GAAGjB,aAAT,IAA0Bc,gBAAjC,EAAmD;MACjD;MACA,MAAMI,IAAI,GAAG,KAAKP,MAAL,CAAYM,MAAZ,CAAb,CAFiD,CAGjD;;MACA,MAAME,MAAM,GAAG,KAAKR,MAAL,CAAYS,YAAZ,CAAyBH,MAAM,GAAGnB,WAAlC,CAAf;MACA,MAAMuB,iBAAiB,GAAGvB,WAAW,GAAGqB,MAAxC;;MACA,IAAIE,iBAAiB,GAAGJ,MAApB,IAA8BH,gBAAlC,EAAoD;QAClD,MAAMQ,OAAO,GAAG,KAAKC,YAAL,CAAkBN,MAAM,GAAGjB,aAA3B,EAA0CkB,IAA1C,EAAgDC,MAAhD,EAAwD,KAAKR,MAA7D,CAAhB;QACAC,QAAQ,CAACU,OAAD,CAAR;QACAL,MAAM,IAAII,iBAAV;MACD,CAJD,MAIO;QACL;MACD;IACF;;IACD,IAAIJ,MAAM,KAAKH,gBAAf,EAAiC;MAC/B;MACA,KAAKH,MAAL,GAAcV,WAAd;MACA,KAAKe,YAAL,GAAoB,CAApB;MACA,KAAKD,YAAL,GAAoB,CAApB;IACD,CALD,MAKO;MACL;MACA,KAAKC,YAAL,GAAoBF,gBAAgB,GAAGG,MAAvC;MACA,KAAKF,YAAL,GAAoBE,MAApB;IACD;EACF;;EAEOJ,WAAW,CAACF,MAAD,EAAe;IAChC,IAAI,KAAKK,YAAL,GAAoB,CAAxB,EAA2B;MACzB,MAAMQ,SAAS,GAAG,KAAKR,YAAL,GAAoBL,MAAM,CAACc,UAA7C;MACA,MAAMC,aAAa,GAAGF,SAAS,GAAG,KAAKT,YAAvC;;MACA,IAAIW,aAAa,GAAG,KAAKf,MAAL,CAAYc,UAAhC,EAA4C;QAC1C;QACA,IAAIE,SAAJ;;QACA,IAAIH,SAAS,IAAI,KAAKb,MAAL,CAAYc,UAAzB,IAAuC,KAAKV,YAAL,IAAqB,KAAKC,YAArE,EAAmF;UACjF;UACAW,SAAS,GAAG,KAAKhB,MAAjB;QACD,CAHD,MAGO;UACL;UACA,IAAIiB,eAAe,GAAG,KAAKjB,MAAL,CAAYc,UAAZ,GAAyB,CAA/C;;UACA,OAAOD,SAAS,IAAII,eAApB,EAAqC;YACnCA,eAAe,IAAI,CAAnB;UACD;;UACDD,SAAS,GAAGzB,MAAM,CAACC,WAAP,CAAmByB,eAAnB,CAAZ;QACD,CAbyC,CAc1C;;;QACA,KAAKjB,MAAL,CAAYkB,IAAZ,CAAiBF,SAAjB,EAA4B,CAA5B,EAA+B,KAAKZ,YAApC,EAAkD,KAAKA,YAAL,GAAoB,KAAKC,YAA3E;QACA,KAAKL,MAAL,GAAcgB,SAAd;QACA,KAAKZ,YAAL,GAAoB,CAApB;MACD,CArBwB,CAsBzB;;;MACAJ,MAAM,CAACkB,IAAP,CAAY,KAAKlB,MAAjB,EAAyB,KAAKI,YAAL,GAAoB,KAAKC,YAAlD;MACA,KAAKA,YAAL,GAAoBQ,SAApB;IACD,CAzBD,MAyBO;MACL,KAAKb,MAAL,GAAcA,MAAd;MACA,KAAKI,YAAL,GAAoB,CAApB;MACA,KAAKC,YAAL,GAAoBL,MAAM,CAACc,UAA3B;IACD;EACF;;EAEOF,YAAY,CAACN,MAAD,EAAiBC,IAAjB,EAA+BC,MAA/B,EAA+CW,KAA/C,EAA4D;IAC9E,QAAQZ,IAAR;MACE;MAAA;MAAA;QACE,OAAOa,uBAAP;;MACF;MAAA;MAAA;QACE,OAAOA,wBAAP;;MACF;MAAA;MAAA;QACE,OAAOA,wBAAP;;MACF;MAAA;MAAA;QACE,OAAOA,iBAAP;;MACF;MAAA;MAAA;QACE,OAAOA,0BAAP;;MACF;MAAA;MAAA;QACE,OAAOA,mBAAP;;MACF;MAAA;MAAA;QACE,OAAOA,2BAAP;;MACF;MAAA;MAAA;QACE,OAAOA,qBAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKC,mBAAL,CAAyBf,MAAzB,EAAiCE,MAAjC,EAAyCW,KAAzC,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKG,2BAAL,CAAiChB,MAAjC,EAAyCE,MAAzC,EAAiDW,KAAjD,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKI,yBAAL,CAA+BjB,MAA/B,EAAuCE,MAAvC,EAA+CW,KAA/C,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKK,wBAAL,CAA8BlB,MAA9B,EAAsCE,MAAtC,EAA8CW,KAA9C,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKM,2BAAL,CAAiCnB,MAAjC,EAAyCE,MAAzC,EAAiDW,KAAjD,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKO,2BAAL,CAAiCpB,MAAjC,EAAyCE,MAAzC,EAAiDW,KAAjD,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKQ,mBAAL,CAAyBrB,MAAzB,EAAiCE,MAAjC,EAAyCW,KAAzC,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKS,iBAAL,CAAuBtB,MAAvB,EAA+BE,MAA/B,EAAuCW,KAAvC,EAA8C,OAA9C,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKS,iBAAL,CAAuBtB,MAAvB,EAA+BE,MAA/B,EAAuCW,KAAvC,EAA8C,QAA9C,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKU,0BAAL,CAAgCvB,MAAhC,EAAwCE,MAAxC,EAAgDW,KAAhD,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKW,gCAAL,CAAsCxB,MAAtC,EAA8CE,MAA9C,EAAsDW,KAAtD,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKY,kBAAL,CAAwBzB,MAAxB,EAAgCE,MAAhC,EAAwCW,KAAxC,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKa,mBAAL,CAAyB1B,MAAzB,EAAiCE,MAAjC,EAAyCW,KAAzC,CAAP;;MACF;MAAA;MAAA;QACE,OAAO,KAAKc,aAAL,CAAmB3B,MAAnB,EAA2BE,MAA3B,EAAmCW,KAAnC,CAAP;;MACF;QACEe,iBAAOC,IAAP,CAAY,yBAAyB5B,IAAI,CAAC6B,QAAL,CAAc,EAAd,CAAiB,EAAtD;IA9CJ;EAgDD;;EAEOb,yBAAyB,CAACjB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC7E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMoB,MAAM,GAAG,KAAKF,MAAL,CAAYG,MAAZ,CAAmB,CAAnB,CAAf;IACA,OAAO,IAAIpB,+BAAJ,CAAyBZ,MAAzB,EAAiC+B,MAAjC,CAAP;EACD;;EAEOjB,2BAA2B,CAAChB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC/E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMsB,IAAI,GAAG,KAAKJ,MAAL,CAAYK,OAAZ,EAAb;IACA,OAAO,IAAItB,iCAAJ,CAA2BZ,MAA3B,EAAmCiC,IAAnC,CAAP;EACD;;EAEOR,aAAa,CAAC3B,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACjE,MAAMwB,KAAK,GAAGxB,KAAK,CAACyB,KAAN,CAAYtC,MAAZ,EAAoBA,MAAM,IAAIE,MAAM,GAAG,CAAb,CAA1B,CAAd;IACA,OAAO,IAAIY,0BAAJ,CAAoBZ,MAApB,EAA4BmC,KAA5B,CAAP;EACD;;EAEOZ,kBAAkB,CAACzB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACtE,OAAO,KAAK0B,gBAAL,CAAsBvC,MAAtB,EAA8BE,MAA9B,EAAsCW,KAAtC,EAA6C,gBAA7C,CAAP;EACD;;EAEOa,mBAAmB,CAAC1B,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACvE,OAAO,KAAK0B,gBAAL,CAAsBvC,MAAtB,EAA8BE,MAA9B,EAAsCW,KAAtC,EAA6C,iBAA7C,CAAP;EACD;;EAEO0B,gBAAgB,CAACvC,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAAgD2B,WAAhD,EAAwE;IAC9F,KAAKT,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAM4B,QAAQ,GAAG,KAAKV,MAAL,CAAYW,IAAZ,OAAuB,CAAxC;IACA,MAAMC,WAAW,GAAG,KAAKZ,MAAL,CAAYa,KAAZ,EAApB;IACA,MAAMvC,OAAO,GAAG,IAAIS,uBAAJ,CAAiBZ,MAAjB,EAAyBsC,WAAzB,EAAsCC,QAAtC,EAAgDE,WAAhD,CAAhB;;IACA,KAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGF,WAApB,EAAiCE,CAAC,EAAlC,EAAsC;MACpCxC,OAAO,CAACyC,WAAR,CAAoBD,CAApB,IAAyB,KAAKd,MAAL,CAAYa,KAAZ,EAAzB;IACD;;IACD,OAAOvC,OAAP;EACD;;EAEOa,wBAAwB,CAAClB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC5E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMkC,SAAS,GAAG,KAAKhB,MAAL,CAAYiB,KAAZ,EAAlB;IACA,MAAMC,OAAO,GAAG,KAAKlB,MAAL,CAAYK,OAAZ,EAAhB;IACA,MAAMc,OAAO,GAAG,KAAKnB,MAAL,CAAYK,OAAZ,EAAhB;IACA,OAAO,IAAItB,sCAAJ,CAAgCZ,MAAhC,EAAwC6C,SAAxC,EAAmDE,OAAnD,EAA4DC,OAA5D,CAAP;EACD;;EAEO3B,0BAA0B,CAACvB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC9E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMsC,UAAU,GAAG,KAAKpB,MAAL,CAAYa,KAAZ,EAAnB;IACA,MAAMvC,OAAO,GAAG,IAAIS,gCAAJ,CAA0BZ,MAA1B,EAAkCiD,UAAlC,CAAhB;;IACA,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,UAApB,EAAgCN,CAAC,EAAjC,EAAqC;MACnCxC,OAAO,CAAC+C,MAAR,CAAeP,CAAf,IAAoB,KAAKQ,UAAL,EAApB;IACD;;IACD,OAAOhD,OAAP;EACD;;EAEOgD,UAAU;IAChB,MAAMC,IAAI,GAAG,KAAKvB,MAAL,CAAYK,OAAZ,EAAb;IACA,MAAMmB,OAAO,GAAG,KAAKxB,MAAL,CAAYiB,KAAZ,EAAhB;IACA,MAAMQ,QAAQ,GAAG,KAAKzB,MAAL,CAAYa,KAAZ,EAAjB;IACA,MAAMa,UAAU,GAAG,KAAK1B,MAAL,CAAYiB,KAAZ,EAAnB;IACA,MAAMU,YAAY,GAAG,KAAK3B,MAAL,CAAYa,KAAZ,EAArB;IACA,MAAMe,gBAAgB,GAAG,KAAK5B,MAAL,CAAYiB,KAAZ,EAAzB;IACA,MAAMzD,IAAI,GAAG,KAAKwC,MAAL,CAAYa,KAAZ,OAAwB,CAAxB,GAA4B,MAA5B,GAAqC,QAAlD;IACA,OAAO,IAAI9B,gBAAJ,CAAUwC,IAAV,EAAgBC,OAAhB,EAAyBC,QAAzB,EAAmCC,UAAnC,EAA+CC,YAA/C,EAA6DC,gBAA7D,EAA+EpE,IAA/E,CAAP;EACD;;EAEOiC,gCAAgC,CAACxB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACpF,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAM+C,cAAc,GAAG,KAAK7B,MAAL,CAAYa,KAAZ,EAAvB;IACA,MAAMvC,OAAO,GAAG,IAAIS,sCAAJ,CAAgCZ,MAAhC,EAAwC0D,cAAxC,CAAhB;;IACA,KAAK,IAAIf,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGe,cAApB,EAAoCf,CAAC,EAArC,EAAyC;MACvCxC,OAAO,CAACwD,WAAR,CAAoBhB,CAApB,IAAyB,KAAKd,MAAL,CAAYiB,KAAZ,EAAzB;IACD;;IACD,OAAO3C,OAAP;EACD;;EAEOU,mBAAmB,CAACf,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACvE,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMsC,UAAU,GAAG,KAAKpB,MAAL,CAAYa,KAAZ,EAAnB;IACA,MAAMQ,MAAM,GAAU,IAAIU,KAAJ,CAAUX,UAAV,CAAtB;;IACA,KAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGM,UAApB,EAAgCN,CAAC,EAAjC,EAAqC;MACnC,MAAMkB,GAAG,GAAG,KAAKhC,MAAL,CAAYiB,KAAZ,EAAZ,CADmC,CAEnC;;MACAI,MAAM,CAACP,CAAD,CAAN,GAAYkB,GAAG,KAAK,CAAC,CAAT,GAAa,IAAb,GAAoB,KAAKhC,MAAL,CAAYG,MAAZ,CAAmB6B,GAAnB,CAAhC;IACD;;IACD,OAAO,IAAIjD,yBAAJ,CAAmBZ,MAAnB,EAA2BkD,MAA3B,CAAP;EACD;;EAEOhC,2BAA2B,CAACpB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC/E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMyC,IAAI,GAAG,KAAKvB,MAAL,CAAYK,OAAZ,EAAb;IACA,MAAM4B,KAAK,GAAG,KAAKjC,MAAL,CAAYK,OAAZ,EAAd;IACA,OAAO,IAAItB,iCAAJ,CAA2BZ,MAA3B,EAAmCoD,IAAnC,EAAyCU,KAAzC,CAAP;EACD;;EAEO3C,mBAAmB,CAACrB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IACvE,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMoD,SAAS,GAAG,KAAKlC,MAAL,CAAYiB,KAAZ,EAAlB;IACA,MAAMkB,SAAS,GAAG,KAAKnC,MAAL,CAAYiB,KAAZ,EAAlB;IACA,OAAO,IAAIlC,gCAAJ,CAA0BZ,MAA1B,EAAkC+D,SAAlC,EAA6CC,SAA7C,CAAP;EACD;;EAEM/C,2BAA2B,CAACnB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAA8C;IAC9E,KAAKkB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMZ,IAAI,GAAG,KAAK8B,MAAL,CAAYiB,KAAZ,EAAb,CAF8E,CAG9E;;IACA,MAAM3C,OAAO,GAAyB;MACpCiD,IAAI,EAAE,kBAD8B;MAEpCpD;IAFoC,CAAtC;;IAKA,QAAQD,IAAR;MACE,KAAK,CAAL;QAAQ;QACN;;MACF,KAAK,CAAL;QAAQ;QACN,IAAII,OAAO,CAACH,MAAR,KAAmB,CAAvB,EAA0B;UACxBG,OAAO,CAACiD,IAAR,GAAe,iCAAf;QACD;;QACD;;MACF,KAAK,CAAL;QAAQ;QACN,IAAIjD,OAAO,CAACH,MAAR,KAAmB,EAAvB,EAA2B;UACzBG,OAAO,CAACiD,IAAR,GAAe,2BAAf;UACA,MAAMa,IAAI,GAAG,KAAKpC,MAAL,CAAYlB,KAAZ,CAAkB,CAAlB,CAAb;UACA,OAAO,IAAIC,oCAAJ,CAA8BZ,MAA9B,EAAsCiE,IAAtC,CAAP;QACD;;QACD;;MACF,KAAK,EAAL;QAAS;QACP9D,OAAO,CAACiD,IAAR,GAAe,oBAAf;QACAjD,OAAO,CAAC+D,UAAR,GAAqB,EAArB;QACA,IAAIC,SAAJ;;QACA,GAAG;UACDA,SAAS,GAAG,KAAKtC,MAAL,CAAYK,OAAZ,EAAZ;;UAEA,IAAIiC,SAAJ,EAAe;YACbhE,OAAO,CAAC+D,UAAR,CAAmBE,IAAnB,CAAwBD,SAAxB;UACD;QACF,CAND,QAMSA,SANT;;QAOA;;MACF,KAAK,EAAL;QAAS;QACPhE,OAAO,CAACiD,IAAR,GAAe,4BAAf;QACAjD,OAAO,CAACkE,IAAR,GAAe,KAAKxC,MAAL,CAAYG,MAAZ,CAAmBhC,MAAM,GAAG,CAA5B,CAAf;QACA;;MACF,KAAK,EAAL;QAAS;QACPG,OAAO,CAACiD,IAAR,GAAe,yBAAf;QACAjD,OAAO,CAACkE,IAAR,GAAe,KAAKxC,MAAL,CAAYG,MAAZ,CAAmBhC,MAAM,GAAG,CAA5B,CAAf;QACA;;MACF;QACE,MAAM,IAAIV,KAAJ,CAAU,2CAA2CS,IAArD,CAAN;IApCJ;;IAsCA,OAAOI,OAAP;EACD;;EAEOiB,iBAAiB,CAACtB,MAAD,EAAiBE,MAAjB,EAAiCW,KAAjC,EAAgDyC,IAAhD,EAAiE;IACxF,KAAKvB,MAAL,CAAYC,SAAZ,CAAsBhC,MAAtB,EAA8Ba,KAA9B;IACA,MAAMuC,MAAM,GAA2B,EAAvC;IACA,IAAIoB,SAAS,GAAG,KAAKzC,MAAL,CAAYG,MAAZ,CAAmB,CAAnB,CAAhB;;IACA,OAAOsC,SAAS,KAAK,IAArB,EAA2B;MACzBpB,MAAM,CAACoB,SAAD,CAAN,GAAoB,KAAKzC,MAAL,CAAYK,OAAZ,EAApB;MACAoC,SAAS,GAAG,KAAKzC,MAAL,CAAYG,MAAZ,CAAmB,CAAnB,CAAZ;IACD;;IAED,MAAMuC,YAAY,GAAGrB,MAAM,CAACsB,CAA5B;IAEA,MAAMrE,OAAO,GACXiD,IAAI,KAAK,QAAT,GAAoB,IAAIxC,wBAAJ,CAAkBZ,MAAlB,EAA0BuE,YAA1B,CAApB,GAA8D,IAAI3D,wBAAJ,CAAkB2D,YAAlB,EAAgCvE,MAAhC,EAAwCoD,IAAxC,CADhE;IAGAjD,OAAO,CAACsE,QAAR,GAAmBvB,MAAM,CAACwB,CAA1B;IACAvE,OAAO,CAACJ,IAAR,GAAemD,MAAM,CAACyB,CAAtB;IACAxE,OAAO,CAACyE,MAAR,GAAiB1B,MAAM,CAAC2B,CAAxB;IACA1E,OAAO,CAAC2E,IAAR,GAAe5B,MAAM,CAAC6B,CAAtB;IACA5E,OAAO,CAAC6E,QAAR,GAAmB9B,MAAM,CAAC+B,CAA1B;IACA9E,OAAO,CAAC+E,gBAAR,GAA2BhC,MAAM,CAACiC,CAAlC;IACAhF,OAAO,CAACiF,aAAR,GAAwBlC,MAAM,CAACmC,CAA/B;IACAlF,OAAO,CAACmF,KAAR,GAAgBpC,MAAM,CAACqC,CAAvB;IACApF,OAAO,CAACqF,MAAR,GAAiBtC,MAAM,CAACuC,CAAxB;IACAtF,OAAO,CAACuF,KAAR,GAAgBxC,MAAM,CAACyC,CAAvB;IACAxF,OAAO,CAACyF,MAAR,GAAiB1C,MAAM,CAAC2C,CAAxB;IACA1F,OAAO,CAAC2F,QAAR,GAAmB5C,MAAM,CAAC6C,CAA1B;IACA5F,OAAO,CAAC6F,UAAR,GAAqB9C,MAAM,CAAC+C,CAA5B;IACA9F,OAAO,CAAC+F,IAAR,GAAehD,MAAM,CAACiD,CAAtB;IACAhG,OAAO,CAACiG,IAAR,GAAelD,MAAM,CAACmD,CAAtB;IACAlG,OAAO,CAACmG,OAAR,GAAkBpD,MAAM,CAACqD,CAAzB;IACA,OAAOpG,OAAP;EACD;;AAtTgB;;AAAnBqG","names":["CODE_LENGTH","LEN_LENGTH","HEADER_LENGTH","emptyBuffer","Buffer","allocUnsafe","Parser","constructor","opts","buffer_reader_1","mode","Error","parse","buffer","callback","mergeBuffer","bufferFullLength","bufferOffset","bufferLength","offset","code","length","readUInt32BE","fullMessageLength","message","handlePacket","newLength","byteLength","newFullLength","newBuffer","newBufferLength","copy","bytes","messages_1","parseDataRowMessage","parseCommandCompleteMessage","parseReadyForQueryMessage","parseNotificationMessage","parseAuthenticationResponse","parseParameterStatusMessage","parseBackendKeyData","parseErrorMessage","parseRowDescriptionMessage","parseParameterDescriptionMessage","parseCopyInMessage","parseCopyOutMessage","parseCopyData","assert_1","fail","toString","reader","setBuffer","status","string","text","cstring","chunk","slice","parseCopyMessage","messageName","isBinary","byte","columnCount","int16","i","columnTypes","processId","int32","channel","payload","fieldCount","fields","parseField","name","tableID","columnID","dataTypeID","dataTypeSize","dataTypeModifier","parameterCount","dataTypeIDs","Array","len","value","processID","secretKey","salt","mechanisms","mechanism","push","data","fieldType","messageValue","M","severity","S","C","detail","D","hint","H","position","P","internalPosition","p","internalQuery","q","where","W","schema","s","table","t","column","c","dataType","d","constraint","n","file","F","line","L","routine","R","exports"],"sources":["/home/brian/node_modules/pg-protocol/src/parser.ts"],"sourcesContent":["import { TransformOptions } from 'stream'\nimport {\n  Mode,\n  bindComplete,\n  parseComplete,\n  closeComplete,\n  noData,\n  portalSuspended,\n  copyDone,\n  replicationStart,\n  emptyQuery,\n  ReadyForQueryMessage,\n  CommandCompleteMessage,\n  CopyDataMessage,\n  CopyResponse,\n  NotificationResponseMessage,\n  RowDescriptionMessage,\n  ParameterDescriptionMessage,\n  Field,\n  DataRowMessage,\n  ParameterStatusMessage,\n  BackendKeyDataMessage,\n  DatabaseError,\n  BackendMessage,\n  MessageName,\n  AuthenticationMD5Password,\n  NoticeMessage,\n} from './messages'\nimport { BufferReader } from './buffer-reader'\nimport assert from 'assert'\n\n// every message is prefixed with a single bye\nconst CODE_LENGTH = 1\n// every message has an int32 length which includes itself but does\n// NOT include the code in the length\nconst LEN_LENGTH = 4\n\nconst HEADER_LENGTH = CODE_LENGTH + LEN_LENGTH\n\nexport type Packet = {\n  code: number\n  packet: Buffer\n}\n\nconst emptyBuffer = Buffer.allocUnsafe(0)\n\ntype StreamOptions = TransformOptions & {\n  mode: Mode\n}\n\nconst enum MessageCodes {\n  DataRow = 0x44, // D\n  ParseComplete = 0x31, // 1\n  BindComplete = 0x32, // 2\n  CloseComplete = 0x33, // 3\n  CommandComplete = 0x43, // C\n  ReadyForQuery = 0x5a, // Z\n  NoData = 0x6e, // n\n  NotificationResponse = 0x41, // A\n  AuthenticationResponse = 0x52, // R\n  ParameterStatus = 0x53, // S\n  BackendKeyData = 0x4b, // K\n  ErrorMessage = 0x45, // E\n  NoticeMessage = 0x4e, // N\n  RowDescriptionMessage = 0x54, // T\n  ParameterDescriptionMessage = 0x74, // t\n  PortalSuspended = 0x73, // s\n  ReplicationStart = 0x57, // W\n  EmptyQuery = 0x49, // I\n  CopyIn = 0x47, // G\n  CopyOut = 0x48, // H\n  CopyDone = 0x63, // c\n  CopyData = 0x64, // d\n}\n\nexport type MessageCallback = (msg: BackendMessage) => void\n\nexport class Parser {\n  private buffer: Buffer = emptyBuffer\n  private bufferLength: number = 0\n  private bufferOffset: number = 0\n  private reader = new BufferReader()\n  private mode: Mode\n\n  constructor(opts?: StreamOptions) {\n    if (opts?.mode === 'binary') {\n      throw new Error('Binary mode not supported yet')\n    }\n    this.mode = opts?.mode || 'text'\n  }\n\n  public parse(buffer: Buffer, callback: MessageCallback) {\n    this.mergeBuffer(buffer)\n    const bufferFullLength = this.bufferOffset + this.bufferLength\n    let offset = this.bufferOffset\n    while (offset + HEADER_LENGTH <= bufferFullLength) {\n      // code is 1 byte long - it identifies the message type\n      const code = this.buffer[offset]\n      // length is 1 Uint32BE - it is the length of the message EXCLUDING the code\n      const length = this.buffer.readUInt32BE(offset + CODE_LENGTH)\n      const fullMessageLength = CODE_LENGTH + length\n      if (fullMessageLength + offset <= bufferFullLength) {\n        const message = this.handlePacket(offset + HEADER_LENGTH, code, length, this.buffer)\n        callback(message)\n        offset += fullMessageLength\n      } else {\n        break\n      }\n    }\n    if (offset === bufferFullLength) {\n      // No more use for the buffer\n      this.buffer = emptyBuffer\n      this.bufferLength = 0\n      this.bufferOffset = 0\n    } else {\n      // Adjust the cursors of remainingBuffer\n      this.bufferLength = bufferFullLength - offset\n      this.bufferOffset = offset\n    }\n  }\n\n  private mergeBuffer(buffer: Buffer): void {\n    if (this.bufferLength > 0) {\n      const newLength = this.bufferLength + buffer.byteLength\n      const newFullLength = newLength + this.bufferOffset\n      if (newFullLength > this.buffer.byteLength) {\n        // We can't concat the new buffer with the remaining one\n        let newBuffer: Buffer\n        if (newLength <= this.buffer.byteLength && this.bufferOffset >= this.bufferLength) {\n          // We can move the relevant part to the beginning of the buffer instead of allocating a new buffer\n          newBuffer = this.buffer\n        } else {\n          // Allocate a new larger buffer\n          let newBufferLength = this.buffer.byteLength * 2\n          while (newLength >= newBufferLength) {\n            newBufferLength *= 2\n          }\n          newBuffer = Buffer.allocUnsafe(newBufferLength)\n        }\n        // Move the remaining buffer to the new one\n        this.buffer.copy(newBuffer, 0, this.bufferOffset, this.bufferOffset + this.bufferLength)\n        this.buffer = newBuffer\n        this.bufferOffset = 0\n      }\n      // Concat the new buffer with the remaining one\n      buffer.copy(this.buffer, this.bufferOffset + this.bufferLength)\n      this.bufferLength = newLength\n    } else {\n      this.buffer = buffer\n      this.bufferOffset = 0\n      this.bufferLength = buffer.byteLength\n    }\n  }\n\n  private handlePacket(offset: number, code: number, length: number, bytes: Buffer): BackendMessage {\n    switch (code) {\n      case MessageCodes.BindComplete:\n        return bindComplete\n      case MessageCodes.ParseComplete:\n        return parseComplete\n      case MessageCodes.CloseComplete:\n        return closeComplete\n      case MessageCodes.NoData:\n        return noData\n      case MessageCodes.PortalSuspended:\n        return portalSuspended\n      case MessageCodes.CopyDone:\n        return copyDone\n      case MessageCodes.ReplicationStart:\n        return replicationStart\n      case MessageCodes.EmptyQuery:\n        return emptyQuery\n      case MessageCodes.DataRow:\n        return this.parseDataRowMessage(offset, length, bytes)\n      case MessageCodes.CommandComplete:\n        return this.parseCommandCompleteMessage(offset, length, bytes)\n      case MessageCodes.ReadyForQuery:\n        return this.parseReadyForQueryMessage(offset, length, bytes)\n      case MessageCodes.NotificationResponse:\n        return this.parseNotificationMessage(offset, length, bytes)\n      case MessageCodes.AuthenticationResponse:\n        return this.parseAuthenticationResponse(offset, length, bytes)\n      case MessageCodes.ParameterStatus:\n        return this.parseParameterStatusMessage(offset, length, bytes)\n      case MessageCodes.BackendKeyData:\n        return this.parseBackendKeyData(offset, length, bytes)\n      case MessageCodes.ErrorMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'error')\n      case MessageCodes.NoticeMessage:\n        return this.parseErrorMessage(offset, length, bytes, 'notice')\n      case MessageCodes.RowDescriptionMessage:\n        return this.parseRowDescriptionMessage(offset, length, bytes)\n      case MessageCodes.ParameterDescriptionMessage:\n        return this.parseParameterDescriptionMessage(offset, length, bytes)\n      case MessageCodes.CopyIn:\n        return this.parseCopyInMessage(offset, length, bytes)\n      case MessageCodes.CopyOut:\n        return this.parseCopyOutMessage(offset, length, bytes)\n      case MessageCodes.CopyData:\n        return this.parseCopyData(offset, length, bytes)\n      default:\n        assert.fail(`unknown message code: ${code.toString(16)}`)\n    }\n  }\n\n  private parseReadyForQueryMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const status = this.reader.string(1)\n    return new ReadyForQueryMessage(length, status)\n  }\n\n  private parseCommandCompleteMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const text = this.reader.cstring()\n    return new CommandCompleteMessage(length, text)\n  }\n\n  private parseCopyData(offset: number, length: number, bytes: Buffer) {\n    const chunk = bytes.slice(offset, offset + (length - 4))\n    return new CopyDataMessage(length, chunk)\n  }\n\n  private parseCopyInMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyInResponse')\n  }\n\n  private parseCopyOutMessage(offset: number, length: number, bytes: Buffer) {\n    return this.parseCopyMessage(offset, length, bytes, 'copyOutResponse')\n  }\n\n  private parseCopyMessage(offset: number, length: number, bytes: Buffer, messageName: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const isBinary = this.reader.byte() !== 0\n    const columnCount = this.reader.int16()\n    const message = new CopyResponse(length, messageName, isBinary, columnCount)\n    for (let i = 0; i < columnCount; i++) {\n      message.columnTypes[i] = this.reader.int16()\n    }\n    return message\n  }\n\n  private parseNotificationMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processId = this.reader.int32()\n    const channel = this.reader.cstring()\n    const payload = this.reader.cstring()\n    return new NotificationResponseMessage(length, processId, channel, payload)\n  }\n\n  private parseRowDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const message = new RowDescriptionMessage(length, fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      message.fields[i] = this.parseField()\n    }\n    return message\n  }\n\n  private parseField(): Field {\n    const name = this.reader.cstring()\n    const tableID = this.reader.int32()\n    const columnID = this.reader.int16()\n    const dataTypeID = this.reader.int32()\n    const dataTypeSize = this.reader.int16()\n    const dataTypeModifier = this.reader.int32()\n    const mode = this.reader.int16() === 0 ? 'text' : 'binary'\n    return new Field(name, tableID, columnID, dataTypeID, dataTypeSize, dataTypeModifier, mode)\n  }\n\n  private parseParameterDescriptionMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const parameterCount = this.reader.int16()\n    const message = new ParameterDescriptionMessage(length, parameterCount)\n    for (let i = 0; i < parameterCount; i++) {\n      message.dataTypeIDs[i] = this.reader.int32()\n    }\n    return message\n  }\n\n  private parseDataRowMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const fieldCount = this.reader.int16()\n    const fields: any[] = new Array(fieldCount)\n    for (let i = 0; i < fieldCount; i++) {\n      const len = this.reader.int32()\n      // a -1 for length means the value of the field is null\n      fields[i] = len === -1 ? null : this.reader.string(len)\n    }\n    return new DataRowMessage(length, fields)\n  }\n\n  private parseParameterStatusMessage(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const name = this.reader.cstring()\n    const value = this.reader.cstring()\n    return new ParameterStatusMessage(length, name, value)\n  }\n\n  private parseBackendKeyData(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const processID = this.reader.int32()\n    const secretKey = this.reader.int32()\n    return new BackendKeyDataMessage(length, processID, secretKey)\n  }\n\n  public parseAuthenticationResponse(offset: number, length: number, bytes: Buffer) {\n    this.reader.setBuffer(offset, bytes)\n    const code = this.reader.int32()\n    // TODO(bmc): maybe better types here\n    const message: BackendMessage & any = {\n      name: 'authenticationOk',\n      length,\n    }\n\n    switch (code) {\n      case 0: // AuthenticationOk\n        break\n      case 3: // AuthenticationCleartextPassword\n        if (message.length === 8) {\n          message.name = 'authenticationCleartextPassword'\n        }\n        break\n      case 5: // AuthenticationMD5Password\n        if (message.length === 12) {\n          message.name = 'authenticationMD5Password'\n          const salt = this.reader.bytes(4)\n          return new AuthenticationMD5Password(length, salt)\n        }\n        break\n      case 10: // AuthenticationSASL\n        message.name = 'authenticationSASL'\n        message.mechanisms = []\n        let mechanism: string\n        do {\n          mechanism = this.reader.cstring()\n\n          if (mechanism) {\n            message.mechanisms.push(mechanism)\n          }\n        } while (mechanism)\n        break\n      case 11: // AuthenticationSASLContinue\n        message.name = 'authenticationSASLContinue'\n        message.data = this.reader.string(length - 8)\n        break\n      case 12: // AuthenticationSASLFinal\n        message.name = 'authenticationSASLFinal'\n        message.data = this.reader.string(length - 8)\n        break\n      default:\n        throw new Error('Unknown authenticationOk message type ' + code)\n    }\n    return message\n  }\n\n  private parseErrorMessage(offset: number, length: number, bytes: Buffer, name: MessageName) {\n    this.reader.setBuffer(offset, bytes)\n    const fields: Record<string, string> = {}\n    let fieldType = this.reader.string(1)\n    while (fieldType !== '\\0') {\n      fields[fieldType] = this.reader.cstring()\n      fieldType = this.reader.string(1)\n    }\n\n    const messageValue = fields.M\n\n    const message =\n      name === 'notice' ? new NoticeMessage(length, messageValue) : new DatabaseError(messageValue, length, name)\n\n    message.severity = fields.S\n    message.code = fields.C\n    message.detail = fields.D\n    message.hint = fields.H\n    message.position = fields.P\n    message.internalPosition = fields.p\n    message.internalQuery = fields.q\n    message.where = fields.W\n    message.schema = fields.s\n    message.table = fields.t\n    message.column = fields.c\n    message.dataType = fields.d\n    message.constraint = fields.n\n    message.file = fields.F\n    message.line = fields.L\n    message.routine = fields.R\n    return message\n  }\n}\n"]},"metadata":{},"sourceType":"script"}