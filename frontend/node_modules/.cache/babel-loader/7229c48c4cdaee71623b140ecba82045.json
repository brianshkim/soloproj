{"ast":null,"code":"'use strict';\n/*\n * cls-bluebird\n * Function to shim `Promise.prototype._resolveFromExecutor`\n * in order to patch `onCancel` handler in `new Promise()`.\n */\n// Modules\n\nvar shimmer = require('shimmer'); // Exports\n\n/**\n * Patch `_resolveFromExecutor` proto method to run `onCancel` callbacks in current CLS context.\n *\n * @param {Function} Promise - Bluebird Promise constructor to patch\n * @param {Object} ns - CLS namespace to bind callbacks to\n * @returns {undefined}\n */\n\n\nmodule.exports = function (Promise, ns) {\n  // Patch method\n  shimmer.wrap(Promise.prototype, '_resolveFromExecutor', function (_resolveFromExecutorOriginal) {\n    return function (executor) {\n      // Patch executor\n      var executorPatched = function () {\n        var onCancel = arguments[2];\n\n        if (onCancel) {\n          // Patch onCancel function\n          arguments[2] = function (fn) {\n            // Bind onCancel handler to current CLS context\n            if (typeof fn === 'function') fn = ns.bind(fn);\n            return onCancel.call(this, fn);\n          };\n        }\n\n        return executor.apply(this, arguments);\n      }; // Call original method\n\n\n      return _resolveFromExecutorOriginal.call(this, executorPatched);\n    };\n  });\n};","map":{"version":3,"names":["shimmer","require","module","exports","Promise","ns","wrap","prototype","_resolveFromExecutorOriginal","executor","executorPatched","onCancel","arguments","fn","bind","call","apply"],"sources":["/home/brian/node_modules/cls-bluebird/lib/shimOnCancel.js"],"sourcesContent":["'use strict';\n\n/*\n * cls-bluebird\n * Function to shim `Promise.prototype._resolveFromExecutor`\n * in order to patch `onCancel` handler in `new Promise()`.\n */\n\n// Modules\nvar shimmer = require('shimmer');\n\n// Exports\n\n/**\n * Patch `_resolveFromExecutor` proto method to run `onCancel` callbacks in current CLS context.\n *\n * @param {Function} Promise - Bluebird Promise constructor to patch\n * @param {Object} ns - CLS namespace to bind callbacks to\n * @returns {undefined}\n */\nmodule.exports = function(Promise, ns) {\n\t// Patch method\n\tshimmer.wrap(Promise.prototype, '_resolveFromExecutor', function(_resolveFromExecutorOriginal) {\n\t\treturn function(executor) {\n\t\t\t// Patch executor\n\t\t\tvar executorPatched = function() {\n\t\t\t\tvar onCancel = arguments[2];\n\t\t\t\tif (onCancel) {\n\t\t\t\t\t// Patch onCancel function\n\t\t\t\t\targuments[2] = function(fn) {\n\t\t\t\t\t\t// Bind onCancel handler to current CLS context\n\t\t\t\t\t\tif (typeof fn === 'function') fn = ns.bind(fn);\n\t\t\t\t\t\treturn onCancel.call(this, fn);\n\t\t\t\t\t};\n\t\t\t\t}\n\n\t\t\t\treturn executor.apply(this, arguments);\n\t\t\t};\n\n\t\t\t// Call original method\n\t\t\treturn _resolveFromExecutorOriginal.call(this, executorPatched);\n\t\t};\n\t});\n};\n"],"mappings":"AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AACA,IAAIA,OAAO,GAAGC,OAAO,CAAC,SAAD,CAArB,C,CAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAC,MAAM,CAACC,OAAP,GAAiB,UAASC,OAAT,EAAkBC,EAAlB,EAAsB;EACtC;EACAL,OAAO,CAACM,IAAR,CAAaF,OAAO,CAACG,SAArB,EAAgC,sBAAhC,EAAwD,UAASC,4BAAT,EAAuC;IAC9F,OAAO,UAASC,QAAT,EAAmB;MACzB;MACA,IAAIC,eAAe,GAAG,YAAW;QAChC,IAAIC,QAAQ,GAAGC,SAAS,CAAC,CAAD,CAAxB;;QACA,IAAID,QAAJ,EAAc;UACb;UACAC,SAAS,CAAC,CAAD,CAAT,GAAe,UAASC,EAAT,EAAa;YAC3B;YACA,IAAI,OAAOA,EAAP,KAAc,UAAlB,EAA8BA,EAAE,GAAGR,EAAE,CAACS,IAAH,CAAQD,EAAR,CAAL;YAC9B,OAAOF,QAAQ,CAACI,IAAT,CAAc,IAAd,EAAoBF,EAApB,CAAP;UACA,CAJD;QAKA;;QAED,OAAOJ,QAAQ,CAACO,KAAT,CAAe,IAAf,EAAqBJ,SAArB,CAAP;MACA,CAZD,CAFyB,CAgBzB;;;MACA,OAAOJ,4BAA4B,CAACO,IAA7B,CAAkC,IAAlC,EAAwCL,eAAxC,CAAP;IACA,CAlBD;EAmBA,CApBD;AAqBA,CAvBD"},"metadata":{},"sourceType":"script"}