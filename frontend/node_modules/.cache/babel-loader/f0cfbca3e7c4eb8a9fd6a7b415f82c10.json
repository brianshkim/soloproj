{"ast":null,"code":"'use strict';\n\nconst BaseError = require('./base-error');\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors {ValidationErrorItems[]}\n */\n\n\nclass ValidationError extends BaseError {\n  constructor(message, errors) {\n    super(message);\n    this.name = 'SequelizeValidationError';\n    this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n\n    this.errors = errors || []; // Use provided error message if available...\n\n    if (message) {\n      this.message = message; // ... otherwise create a concatenated message out of existing errors.\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\\n');\n    }\n\n    Error.captureStackTrace(this, this.constructor);\n  }\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   *\n   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path\n   */\n\n\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n\n      return reduced;\n    }, []);\n  }\n\n}\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n */\n\n\nclass ValidationErrorItem {\n  /**\n   * Creates new validation error item\n   *\n   * @param {string} message An error message\n   * @param {string} type The type/origin of the validation error\n   * @param {string} path The field that triggered the validation error\n   * @param {string} value The value that generated the error\n   * @param {Object} [inst] the DAO instance that caused the validation error\n   * @param {Object} [validatorKey] a validation \"key\", used for identification\n   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n   * @param {string} [fnArgs] parameters used with the BUILT-IN validator function, if applicable\n   */\n  constructor(message, type, path, value, inst, validatorKey, fnName, fnArgs) {\n    /**\n     * An error message\n     *\n     * @type {string} message\n     */\n    this.message = message || '';\n    /**\n     * The type/origin of the validation error\n     *\n     * @type {string}\n     */\n\n    this.type = null;\n    /**\n     * The field that triggered the validation error\n     *\n     * @type {string}\n     */\n\n    this.path = path || null;\n    /**\n     * The value that generated the error\n     *\n     * @type {string}\n     */\n\n    this.value = value !== undefined ? value : null;\n    this.origin = null;\n    /**\n     * The DAO instance that caused the validation error\n     *\n     * @type {Model}\n     */\n\n    this.instance = inst || null;\n    /**\n     * A validation \"key\", used for identification\n     *\n     * @type {string}\n     */\n\n    this.validatorKey = validatorKey || null;\n    /**\n     * Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n     *\n     * @type {string}\n     */\n\n    this.validatorName = fnName || null;\n    /**\n     * Parameters used with the BUILT-IN validator function, if applicable\n     *\n     * @type {string}\n     */\n\n    this.validatorArgs = fnArgs || [];\n\n    if (type) {\n      if (ValidationErrorItem.Origins[type]) {\n        this.origin = type;\n      } else {\n        const lowercaseType = `${type}`.toLowerCase().trim();\n        const realType = ValidationErrorItem.TypeStringMap[lowercaseType];\n\n        if (realType && ValidationErrorItem.Origins[realType]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    } // This doesn't need captureStackTrace because it's not a subclass of Error\n\n  }\n  /**\n   * return a lowercase, trimmed string \"key\" that identifies the validator.\n   *\n   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property\n   *\n   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is \"namespace\",\n   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins\n   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,\n   *                                            defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE.\n   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.\n   * @returns  {string}\n   *\n   * @private\n   */\n\n\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;\n    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItem.Origins[type];\n\n    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {\n      throw new Error('Invalid namespace separator given, must be a non-empty string');\n    }\n\n    if (!(typeof key === 'string' && key.length)) {\n      return '';\n    }\n\n    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();\n  }\n\n}\n/**\n * An enum that defines valid ValidationErrorItem `origin` values\n *\n * @type {Object}\n * @property CORE       {string}  specifies errors that originate from the sequelize \"core\"\n * @property DB         {string}  specifies validation errors that originate from the storage engine\n * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute\n */\n\n\nValidationErrorItem.Origins = {\n  CORE: 'CORE',\n  DB: 'DB',\n  FUNCTION: 'FUNCTION'\n};\n/**\n * An object that is used internally by the `ValidationErrorItem` class\n * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to\n * our new `origin` values.\n *\n * @type {Object}\n */\n\nValidationErrorItem.TypeStringMap = {\n  'notnull violation': 'CORE',\n  'string violation': 'CORE',\n  'unique violation': 'DB',\n  'validation error': 'FUNCTION'\n};\nmodule.exports = ValidationError;\nmodule.exports.ValidationErrorItem = ValidationErrorItem;","map":{"version":3,"names":["BaseError","require","ValidationError","constructor","message","errors","name","length","map","err","type","origin","join","Error","captureStackTrace","get","path","reduce","reduced","error","push","ValidationErrorItem","value","inst","validatorKey","fnName","fnArgs","undefined","instance","validatorName","validatorArgs","Origins","lowercaseType","toLowerCase","trim","realType","TypeStringMap","getValidatorKey","useTypeAsNS","NSSeparator","useTANS","NSSep","key","useNS","CORE","DB","FUNCTION","module","exports"],"sources":["/home/brian/node_modules/sequelize/lib/errors/validation-error.js"],"sourcesContent":["'use strict';\n\nconst BaseError = require('./base-error');\n\n/**\n * Validation Error. Thrown when the sequelize validation has failed. The error contains an `errors` property,\n * which is an array with 1 or more ValidationErrorItems, one for each validation that failed.\n *\n * @param {string} message Error message\n * @param {Array} [errors] Array of ValidationErrorItem objects describing the validation errors\n *\n * @property errors {ValidationErrorItems[]}\n */\nclass ValidationError extends BaseError {\n  constructor(message, errors) {\n    super(message);\n    this.name = 'SequelizeValidationError';\n    this.message = 'Validation Error';\n    /**\n     *\n     * @type {ValidationErrorItem[]}\n     */\n    this.errors = errors || [];\n\n    // Use provided error message if available...\n    if (message) {\n      this.message = message;\n\n      // ... otherwise create a concatenated message out of existing errors.\n    } else if (this.errors.length > 0 && this.errors[0].message) {\n      this.message = this.errors.map(err => `${err.type || err.origin}: ${err.message}`).join(',\\n');\n    }\n    Error.captureStackTrace(this, this.constructor);\n  }\n\n  /**\n   * Gets all validation error items for the path / field specified.\n   *\n   * @param {string} path The path to be checked for error items\n   *\n   * @returns {Array<ValidationErrorItem>} Validation error items for the specified path\n   */\n  get(path) {\n    return this.errors.reduce((reduced, error) => {\n      if (error.path === path) {\n        reduced.push(error);\n      }\n      return reduced;\n    }, []);\n  }\n}\n\n/**\n * Validation Error Item\n * Instances of this class are included in the `ValidationError.errors` property.\n */\nclass ValidationErrorItem {\n  /**\n   * Creates new validation error item\n   *\n   * @param {string} message An error message\n   * @param {string} type The type/origin of the validation error\n   * @param {string} path The field that triggered the validation error\n   * @param {string} value The value that generated the error\n   * @param {Object} [inst] the DAO instance that caused the validation error\n   * @param {Object} [validatorKey] a validation \"key\", used for identification\n   * @param {string} [fnName] property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n   * @param {string} [fnArgs] parameters used with the BUILT-IN validator function, if applicable\n   */\n  constructor(message, type, path, value, inst, validatorKey, fnName, fnArgs) {\n    /**\n     * An error message\n     *\n     * @type {string} message\n     */\n    this.message = message || '';\n\n    /**\n     * The type/origin of the validation error\n     *\n     * @type {string}\n     */\n    this.type = null;\n\n    /**\n     * The field that triggered the validation error\n     *\n     * @type {string}\n     */\n    this.path = path || null;\n\n    /**\n     * The value that generated the error\n     *\n     * @type {string}\n     */\n    this.value = value !== undefined ? value : null;\n\n    this.origin = null;\n\n    /**\n     * The DAO instance that caused the validation error\n     *\n     * @type {Model}\n     */\n    this.instance = inst || null;\n\n    /**\n     * A validation \"key\", used for identification\n     *\n     * @type {string}\n     */\n    this.validatorKey = validatorKey || null;\n\n    /**\n     * Property name of the BUILT-IN validator function that caused the validation error (e.g. \"in\" or \"len\"), if applicable\n     *\n     * @type {string}\n     */\n    this.validatorName = fnName || null;\n\n    /**\n     * Parameters used with the BUILT-IN validator function, if applicable\n     *\n     * @type {string}\n     */\n    this.validatorArgs = fnArgs || [];\n\n    if (type) {\n      if (ValidationErrorItem.Origins[ type ]) {\n        this.origin = type;\n      } else {\n        const lowercaseType = `${type}`.toLowerCase().trim();\n        const realType = ValidationErrorItem.TypeStringMap[ lowercaseType ];\n\n        if (realType && ValidationErrorItem.Origins[ realType ]) {\n          this.origin = realType;\n          this.type = type;\n        }\n      }\n    }\n\n    // This doesn't need captureStackTrace because it's not a subclass of Error\n  }\n\n  /**\n   * return a lowercase, trimmed string \"key\" that identifies the validator.\n   *\n   * Note: the string will be empty if the instance has neither a valid `validatorKey` property nor a valid `validatorName` property\n   *\n   * @param   {boolean} [useTypeAsNS=true]      controls whether the returned value is \"namespace\",\n   *                                            this parameter is ignored if the validator's `type` is not one of ValidationErrorItem.Origins\n   * @param   {string}  [NSSeparator='.']       a separator string for concatenating the namespace, must be not be empty,\n   *                                            defaults to \".\" (fullstop). only used and validated if useTypeAsNS is TRUE.\n   * @throws  {Error}                           thrown if NSSeparator is found to be invalid.\n   * @returns  {string}\n   *\n   * @private\n   */\n  getValidatorKey(useTypeAsNS, NSSeparator) {\n    const useTANS = useTypeAsNS === undefined || !!useTypeAsNS;\n    const NSSep = NSSeparator === undefined ? '.' : NSSeparator;\n\n    const type = this.origin;\n    const key = this.validatorKey || this.validatorName;\n    const useNS = useTANS && type && ValidationErrorItem.Origins[ type ];\n\n    if (useNS && (typeof NSSep !== 'string' || !NSSep.length)) {\n      throw new Error('Invalid namespace separator given, must be a non-empty string');\n    }\n\n    if (!(typeof key === 'string' && key.length)) {\n      return '';\n    }\n\n    return (useNS ? [type, key].join(NSSep) : key).toLowerCase().trim();\n  }\n}\n\n/**\n * An enum that defines valid ValidationErrorItem `origin` values\n *\n * @type {Object}\n * @property CORE       {string}  specifies errors that originate from the sequelize \"core\"\n * @property DB         {string}  specifies validation errors that originate from the storage engine\n * @property FUNCTION   {string}  specifies validation errors that originate from validator functions (both built-in and custom) defined for a given attribute\n */\nValidationErrorItem.Origins = {\n  CORE: 'CORE',\n  DB: 'DB',\n  FUNCTION: 'FUNCTION'\n};\n\n/**\n * An object that is used internally by the `ValidationErrorItem` class\n * that maps current `type` strings (as given to ValidationErrorItem.constructor()) to\n * our new `origin` values.\n *\n * @type {Object}\n */\nValidationErrorItem.TypeStringMap = {\n  'notnull violation': 'CORE',\n  'string violation': 'CORE',\n  'unique violation': 'DB',\n  'validation error': 'FUNCTION'\n};\n\nmodule.exports = ValidationError;\nmodule.exports.ValidationErrorItem = ValidationErrorItem;\n"],"mappings":"AAAA;;AAEA,MAAMA,SAAS,GAAGC,OAAO,CAAC,cAAD,CAAzB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,MAAMC,eAAN,SAA8BF,SAA9B,CAAwC;EACtCG,WAAW,CAACC,OAAD,EAAUC,MAAV,EAAkB;IAC3B,MAAMD,OAAN;IACA,KAAKE,IAAL,GAAY,0BAAZ;IACA,KAAKF,OAAL,GAAe,kBAAf;IACA;AACJ;AACA;AACA;;IACI,KAAKC,MAAL,GAAcA,MAAM,IAAI,EAAxB,CAR2B,CAU3B;;IACA,IAAID,OAAJ,EAAa;MACX,KAAKA,OAAL,GAAeA,OAAf,CADW,CAGX;IACD,CAJD,MAIO,IAAI,KAAKC,MAAL,CAAYE,MAAZ,GAAqB,CAArB,IAA0B,KAAKF,MAAL,CAAY,CAAZ,EAAeD,OAA7C,EAAsD;MAC3D,KAAKA,OAAL,GAAe,KAAKC,MAAL,CAAYG,GAAZ,CAAgBC,GAAG,IAAK,GAAEA,GAAG,CAACC,IAAJ,IAAYD,GAAG,CAACE,MAAO,KAAIF,GAAG,CAACL,OAAQ,EAAjE,EAAoEQ,IAApE,CAAyE,KAAzE,CAAf;IACD;;IACDC,KAAK,CAACC,iBAAN,CAAwB,IAAxB,EAA8B,KAAKX,WAAnC;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;;;EACEY,GAAG,CAACC,IAAD,EAAO;IACR,OAAO,KAAKX,MAAL,CAAYY,MAAZ,CAAmB,CAACC,OAAD,EAAUC,KAAV,KAAoB;MAC5C,IAAIA,KAAK,CAACH,IAAN,KAAeA,IAAnB,EAAyB;QACvBE,OAAO,CAACE,IAAR,CAAaD,KAAb;MACD;;MACD,OAAOD,OAAP;IACD,CALM,EAKJ,EALI,CAAP;EAMD;;AApCqC;AAuCxC;AACA;AACA;AACA;;;AACA,MAAMG,mBAAN,CAA0B;EACxB;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EACElB,WAAW,CAACC,OAAD,EAAUM,IAAV,EAAgBM,IAAhB,EAAsBM,KAAtB,EAA6BC,IAA7B,EAAmCC,YAAnC,EAAiDC,MAAjD,EAAyDC,MAAzD,EAAiE;IAC1E;AACJ;AACA;AACA;AACA;IACI,KAAKtB,OAAL,GAAeA,OAAO,IAAI,EAA1B;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKM,IAAL,GAAY,IAAZ;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKM,IAAL,GAAYA,IAAI,IAAI,IAApB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKM,KAAL,GAAaA,KAAK,KAAKK,SAAV,GAAsBL,KAAtB,GAA8B,IAA3C;IAEA,KAAKX,MAAL,GAAc,IAAd;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKiB,QAAL,GAAgBL,IAAI,IAAI,IAAxB;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKC,YAAL,GAAoBA,YAAY,IAAI,IAApC;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKK,aAAL,GAAqBJ,MAAM,IAAI,IAA/B;IAEA;AACJ;AACA;AACA;AACA;;IACI,KAAKK,aAAL,GAAqBJ,MAAM,IAAI,EAA/B;;IAEA,IAAIhB,IAAJ,EAAU;MACR,IAAIW,mBAAmB,CAACU,OAApB,CAA6BrB,IAA7B,CAAJ,EAAyC;QACvC,KAAKC,MAAL,GAAcD,IAAd;MACD,CAFD,MAEO;QACL,MAAMsB,aAAa,GAAI,GAAEtB,IAAK,EAAR,CAAUuB,WAAV,GAAwBC,IAAxB,EAAtB;QACA,MAAMC,QAAQ,GAAGd,mBAAmB,CAACe,aAApB,CAAmCJ,aAAnC,CAAjB;;QAEA,IAAIG,QAAQ,IAAId,mBAAmB,CAACU,OAApB,CAA6BI,QAA7B,CAAhB,EAAyD;UACvD,KAAKxB,MAAL,GAAcwB,QAAd;UACA,KAAKzB,IAAL,GAAYA,IAAZ;QACD;MACF;IACF,CAvEyE,CAyE1E;;EACD;EAED;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;EACE2B,eAAe,CAACC,WAAD,EAAcC,WAAd,EAA2B;IACxC,MAAMC,OAAO,GAAGF,WAAW,KAAKX,SAAhB,IAA6B,CAAC,CAACW,WAA/C;IACA,MAAMG,KAAK,GAAGF,WAAW,KAAKZ,SAAhB,GAA4B,GAA5B,GAAkCY,WAAhD;IAEA,MAAM7B,IAAI,GAAG,KAAKC,MAAlB;IACA,MAAM+B,GAAG,GAAG,KAAKlB,YAAL,IAAqB,KAAKK,aAAtC;IACA,MAAMc,KAAK,GAAGH,OAAO,IAAI9B,IAAX,IAAmBW,mBAAmB,CAACU,OAApB,CAA6BrB,IAA7B,CAAjC;;IAEA,IAAIiC,KAAK,KAAK,OAAOF,KAAP,KAAiB,QAAjB,IAA6B,CAACA,KAAK,CAAClC,MAAzC,CAAT,EAA2D;MACzD,MAAM,IAAIM,KAAJ,CAAU,+DAAV,CAAN;IACD;;IAED,IAAI,EAAE,OAAO6B,GAAP,KAAe,QAAf,IAA2BA,GAAG,CAACnC,MAAjC,CAAJ,EAA8C;MAC5C,OAAO,EAAP;IACD;;IAED,OAAO,CAACoC,KAAK,GAAG,CAACjC,IAAD,EAAOgC,GAAP,EAAY9B,IAAZ,CAAiB6B,KAAjB,CAAH,GAA6BC,GAAnC,EAAwCT,WAAxC,GAAsDC,IAAtD,EAAP;EACD;;AAxHuB;AA2H1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAb,mBAAmB,CAACU,OAApB,GAA8B;EAC5Ba,IAAI,EAAE,MADsB;EAE5BC,EAAE,EAAE,IAFwB;EAG5BC,QAAQ,EAAE;AAHkB,CAA9B;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;;AACAzB,mBAAmB,CAACe,aAApB,GAAoC;EAClC,qBAAqB,MADa;EAElC,oBAAoB,MAFc;EAGlC,oBAAoB,IAHc;EAIlC,oBAAoB;AAJc,CAApC;AAOAW,MAAM,CAACC,OAAP,GAAiB9C,eAAjB;AACA6C,MAAM,CAACC,OAAP,CAAe3B,mBAAf,GAAqCA,mBAArC"},"metadata":{},"sourceType":"script"}