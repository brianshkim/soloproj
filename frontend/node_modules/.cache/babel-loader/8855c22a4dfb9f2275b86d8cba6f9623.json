{"ast":null,"code":"'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(`Naming collision between attribute '${association.as}'` + ` and association '${association.as}' on model ${association.source.name}` + '. To remedy this, change either foreignKey or as in your association definition');\n  }\n}\n\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys).map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = {\n          model: source.tableName\n        };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\n\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {Object} association instance\n * @param {Object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {Object} aliases Mapping between model and association method names\n *\n */\n\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function () {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\n\nexports.mixinMethods = mixinMethods;","map":{"version":3,"names":["checkNamingCollision","association","Object","prototype","hasOwnProperty","call","source","rawAttributes","as","Error","name","exports","addForeignKeyConstraints","newAttribute","target","options","key","foreignKeyConstraint","onDelete","onUpdate","primaryKeys","keys","map","primaryKeyAttribute","field","length","includes","_schema","references","model","sequelize","getQueryInterface","QueryGenerator","addSchema","tableName","_schemaDelimiter","mixinMethods","obj","methods","aliases","method","accessors","realMethod","Array","from","arguments"],"sources":["/home/brian/node_modules/sequelize/lib/associations/helpers.js"],"sourcesContent":["'use strict';\n\nfunction checkNamingCollision(association) {\n  if (Object.prototype.hasOwnProperty.call(association.source.rawAttributes, association.as)) {\n    throw new Error(\n      `Naming collision between attribute '${association.as}'` +\n      ` and association '${association.as}' on model ${association.source.name}` +\n      '. To remedy this, change either foreignKey or as in your association definition'\n    );\n  }\n}\nexports.checkNamingCollision = checkNamingCollision;\n\nfunction addForeignKeyConstraints(newAttribute, source, target, options, key) {\n  // FK constraints are opt-in: users must either set `foreignKeyConstraints`\n  // on the association, or request an `onDelete` or `onUpdate` behavior\n\n  if (options.foreignKeyConstraint || options.onDelete || options.onUpdate) {\n    // Find primary keys: composite keys not supported with this approach\n    const primaryKeys = Object.keys(source.primaryKeys)\n      .map(primaryKeyAttribute => source.rawAttributes[primaryKeyAttribute].field || primaryKeyAttribute);\n\n    if (primaryKeys.length === 1 || !primaryKeys.includes(key)) {\n      if (source._schema) {\n        newAttribute.references = {\n          model: source.sequelize.getQueryInterface().QueryGenerator.addSchema({\n            tableName: source.tableName,\n            _schema: source._schema,\n            _schemaDelimiter: source._schemaDelimiter\n          })\n        };\n      } else {\n        newAttribute.references = { model: source.tableName };\n      }\n\n      newAttribute.references.key = key || primaryKeys[0];\n      newAttribute.onDelete = options.onDelete;\n      newAttribute.onUpdate = options.onUpdate;\n    }\n  }\n}\nexports.addForeignKeyConstraints = addForeignKeyConstraints;\n\n/**\n * Mixin (inject) association methods to model prototype\n *\n * @private\n *\n * @param {Object} association instance\n * @param {Object} obj Model prototype\n * @param {Array} methods Method names to inject\n * @param {Object} aliases Mapping between model and association method names\n *\n */\nfunction mixinMethods(association, obj, methods, aliases) {\n  aliases = aliases || {};\n\n  for (const method of methods) {\n    // don't override custom methods\n    if (!Object.prototype.hasOwnProperty.call(obj, association.accessors[method])) {\n      const realMethod = aliases[method] || method;\n\n      obj[association.accessors[method]] = function() {\n        return association[realMethod](this, ...Array.from(arguments));\n      };\n    }\n  }\n}\nexports.mixinMethods = mixinMethods;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}