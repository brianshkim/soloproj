{"ast":null,"code":"'use strict';\n\nconst DataTypes = require('./data-types');\n\nconst SqlString = require('./sql-string');\n\nconst _ = require('lodash');\n\nconst uuidv1 = require('uuid').v1;\n\nconst uuidv4 = require('uuid').v4;\n\nconst Promise = require('./promise');\n\nconst operators = require('./operators');\n\nconst operatorsSet = new Set(_.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/classToInvokable').classToInvokable;\nexports.Promise = Promise;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\n\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\n\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\n\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\n\nexports.isPrimitive = isPrimitive; // Same concept as _.merge, but don't overwrite properties that have already been assigned\n\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\n\nexports.mergeDefaults = mergeDefaults; // An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\n\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\n\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\n\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\n\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\n\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\n\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null; // Make a clone of the array beacuse format modifies the passed args\n\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\n\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\n\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    } // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n\n\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    } // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n\n\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\n\nexports.cloneDeep = cloneDeep;\n/* Expand and normalize finder options */\n\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n  return options;\n}\n\nexports.mapFinderOptions = mapFinderOptions;\n/* Used to map field names in attributes and where conditions */\n\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr; // Map attributes to aliased syntax attributes\n\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\n\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute]) && !(rawAttribute && (rawAttribute.type instanceof DataTypes.HSTORE || rawAttribute.type instanceof DataTypes.JSON))) {\n        // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n    });\n  }\n\n  return attributes;\n}\n\nexports.mapWhereFieldNames = mapWhereFieldNames;\n/* Used to map field names in values */\n\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\n\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\n\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\n\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\n\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n\n    return tmp;\n  }\n\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n\n  if (_.isPlainObject(value) || Array.isArray(value)) {\n    return _.clone(value);\n  }\n\n  return value;\n}\n\nexports.toDefaultValue = toDefaultValue;\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\n\nfunction defaultValueSchemable(value) {\n  if (value === undefined) {\n    return false;\n  } // TODO this will be schemable when all supported db\n  // have been normalized for this case\n\n\n  if (value instanceof DataTypes.NOW) {\n    return false;\n  }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) {\n    return false;\n  }\n\n  return typeof value !== 'function';\n}\n\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\n\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n\n  Error.prepareStackTrace = (_, stack) => stack;\n\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\n\nexports.stack = stack;\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);\n\nfunction now(dialect) {\n  const d = new Date();\n\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n\n  return d;\n}\n\nexports.now = now; // Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\n\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\n\nexports.removeTicks = removeTicks;\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {Object} value an Object\n * @returns {Object} a flattened object\n * @private\n */\n\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\n\nexports.flattenObjectDeep = flattenObjectDeep;\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\n\nclass SequelizeMethod {}\n\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n\n}\n\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col) {\n    super();\n\n    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      args[_key - 1] = arguments[_key];\n    }\n\n    if (args.length > 0) {\n      col = args;\n    }\n\n    this.col = col;\n  }\n\n}\n\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n\n}\n\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n\n}\n\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n\n}\n\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n\n}\n\nexports.Where = Where; //Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {Object} obj\n * @returns {Array<Symbol>} All operators properties of obj\n * @private\n */\n\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\n\nexports.getOperators = getOperators;\n/**\n * getComplexKeys\n *\n * @param  {Object} obj\n * @returns {Array<string|Symbol>} All keys including operators\n * @private\n */\n\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\n\nexports.getComplexKeys = getComplexKeys;\n/**\n * getComplexSize\n *\n * @param  {Object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\n\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\n\nexports.getComplexSize = getComplexSize;\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {Object} obj\n * @returns {boolean}\n * @private\n */\n\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\n\nexports.isWhereEmpty = isWhereEmpty;\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\n\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\n\nexports.generateEnumName = generateEnumName;\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {Object} obj\n * @returns {string}\n * @private\n */\n\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\n\nexports.camelizeObjectKeys = camelizeObjectKeys;\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @private\n */\n\nfunction defaults(object) {\n  object = Object(object);\n\n  for (var _len2 = arguments.length, sources = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n    sources[_key2 - 1] = arguments[_key2];\n  }\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n\n        if (value === undefined || _.eq(value, Object.prototype[key]) && !Object.prototype.hasOwnProperty.call(object, key)) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n  return object;\n}\n\nexports.defaults = defaults;\n/**\n *\n * @param {Object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|Object} tableName\n *\n * @returns {Object}\n * @private\n */\n\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(field => typeof field === 'string' ? field : field.name || field.attribute);\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\n\nexports.nameIndex = nameIndex;\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\n\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\n\nexports.intersects = intersects;","map":{"version":3,"names":["DataTypes","require","SqlString","_","uuidv1","v1","uuidv4","v4","Promise","operators","operatorsSet","Set","values","inflection","exports","classToInvokable","useInflection","_inflection","camelizeIf","str","condition","result","camelize","underscoredIf","underscore","isPrimitive","val","type","mergeDefaults","a","b","mergeWith","objectValue","isPlainObject","undefined","merge","obj","arguments","forOwn","value","key","Array","isArray","concat","spliceStr","index","count","add","slice","trim","replace","match","c","toUpperCase","singularize","pluralize","format","arr","dialect","timeZone","formatNamedParameters","sql","parameters","cloneDeep","onlyPlain","cloneDeepWith","elem","clone","mapFinderOptions","options","Model","attributes","_injectDependentVirtualAttributes","filter","v","_virtualAttributes","has","mapOptionFieldNames","map","attr","rawAttributes","field","where","mapWhereFieldNames","getComplexKeys","forEach","attribute","rawAttribute","fieldName","HSTORE","JSON","mapValueFieldNames","dataValues","fields","isColString","length","canTreatArrayAsAnd","some","arg","Where","combineTableNames","tableName1","tableName2","toLowerCase","toDefaultValue","tmp","ABSTRACT","toSql","UUIDV1","UUIDV4","NOW","now","defaultValueSchemable","removeNullValuesFromHash","hash","omitNull","allowNull","_hash","forIn","includes","endsWith","stack","orig","Error","prepareStackTrace","err","captureStackTrace","errStack","dialects","d","Date","setMilliseconds","TICK_CHAR","addTicks","s","tickChar","removeTicks","RegExp","flattenObjectDeep","flattenedObj","flattenObject","subPath","Object","keys","pathToProperty","get","SequelizeMethod","Fn","constructor","fn","args","Col","col","Cast","json","Literal","Json","conditionsOrPath","isObject","conditions","path","comparator","logic","getOperators","getOwnPropertySymbols","getComplexSize","isWhereEmpty","isEmpty","generateEnumName","tableName","columnName","camelizeObjectKeys","newObj","defaults","object","sources","source","eq","prototype","hasOwnProperty","call","nameIndex","name","join","intersects","arr1","arr2"],"sources":["/home/brian/node_modules/sequelize/lib/utils.js"],"sourcesContent":["'use strict';\n\nconst DataTypes = require('./data-types');\nconst SqlString = require('./sql-string');\nconst _ = require('lodash');\nconst uuidv1 = require('uuid').v1;\nconst uuidv4 = require('uuid').v4;\nconst Promise = require('./promise');\nconst operators = require('./operators');\nconst operatorsSet = new Set(_.values(operators));\n\nlet inflection = require('inflection');\n\nexports.classToInvokable = require('./utils/classToInvokable').classToInvokable;\n\nexports.Promise = Promise;\n\nfunction useInflection(_inflection) {\n  inflection = _inflection;\n}\nexports.useInflection = useInflection;\n\nfunction camelizeIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = camelize(str);\n  }\n\n  return result;\n}\nexports.camelizeIf = camelizeIf;\n\nfunction underscoredIf(str, condition) {\n  let result = str;\n\n  if (condition) {\n    result = underscore(str);\n  }\n\n  return result;\n}\nexports.underscoredIf = underscoredIf;\n\nfunction isPrimitive(val) {\n  const type = typeof val;\n  return type === 'string' || type === 'number' || type === 'boolean';\n}\nexports.isPrimitive = isPrimitive;\n\n// Same concept as _.merge, but don't overwrite properties that have already been assigned\nfunction mergeDefaults(a, b) {\n  return _.mergeWith(a, b, objectValue => {\n    // If it's an object, let _ handle it this time, we will be called again for each property\n    if (!_.isPlainObject(objectValue) && objectValue !== undefined) {\n      return objectValue;\n    }\n  });\n}\nexports.mergeDefaults = mergeDefaults;\n\n// An alternative to _.merge, which doesn't clone its arguments\n// Cloning is a bad idea because options arguments may contain references to sequelize\n// models - which again reference database libs which don't like to be cloned (in particular pg-native)\nfunction merge() {\n  const result = {};\n\n  for (const obj of arguments) {\n    _.forOwn(obj, (value, key) => {\n      if (value !== undefined) {\n        if (!result[key]) {\n          result[key] = value;\n        } else if (_.isPlainObject(value) && _.isPlainObject(result[key])) {\n          result[key] = merge(result[key], value);\n        } else if (Array.isArray(value) && Array.isArray(result[key])) {\n          result[key] = value.concat(result[key]);\n        } else {\n          result[key] = value;\n        }\n      }\n    });\n  }\n\n  return result;\n}\nexports.merge = merge;\n\nfunction spliceStr(str, index, count, add) {\n  return str.slice(0, index) + add + str.slice(index + count);\n}\nexports.spliceStr = spliceStr;\n\nfunction camelize(str) {\n  return str.trim().replace(/[-_\\s]+(.)?/g, (match, c) => c.toUpperCase());\n}\nexports.camelize = camelize;\n\nfunction underscore(str) {\n  return inflection.underscore(str);\n}\nexports.underscore = underscore;\n\nfunction singularize(str) {\n  return inflection.singularize(str);\n}\nexports.singularize = singularize;\n\nfunction pluralize(str) {\n  return inflection.pluralize(str);\n}\nexports.pluralize = pluralize;\n\nfunction format(arr, dialect) {\n  const timeZone = null;\n  // Make a clone of the array beacuse format modifies the passed args\n  return SqlString.format(arr[0], arr.slice(1), timeZone, dialect);\n}\nexports.format = format;\n\nfunction formatNamedParameters(sql, parameters, dialect) {\n  const timeZone = null;\n  return SqlString.formatNamedParameters(sql, parameters, timeZone, dialect);\n}\nexports.formatNamedParameters = formatNamedParameters;\n\nfunction cloneDeep(obj, onlyPlain) {\n  obj = obj || {};\n  return _.cloneDeepWith(obj, elem => {\n    // Do not try to customize cloning of arrays or POJOs\n    if (Array.isArray(elem) || _.isPlainObject(elem)) {\n      return undefined;\n    }\n\n    // If we specified to clone only plain objects & arrays, we ignore everyhing else\n    // In any case, don't clone stuff that's an object, but not a plain one - fx example sequelize models and instances\n    if (onlyPlain || typeof elem === 'object') {\n      return elem;\n    }\n\n    // Preserve special data-types like `fn` across clones. _.get() is used for checking up the prototype chain\n    if (elem && typeof elem.clone === 'function') {\n      return elem.clone();\n    }\n  });\n}\nexports.cloneDeep = cloneDeep;\n\n/* Expand and normalize finder options */\nfunction mapFinderOptions(options, Model) {\n  if (options.attributes && Array.isArray(options.attributes)) {\n    options.attributes = Model._injectDependentVirtualAttributes(options.attributes);\n    options.attributes = options.attributes.filter(v => !Model._virtualAttributes.has(v));\n  }\n\n  mapOptionFieldNames(options, Model);\n\n  return options;\n}\nexports.mapFinderOptions = mapFinderOptions;\n\n/* Used to map field names in attributes and where conditions */\nfunction mapOptionFieldNames(options, Model) {\n  if (Array.isArray(options.attributes)) {\n    options.attributes = options.attributes.map(attr => {\n      // Object lookups will force any variable to strings, we don't want that for special objects etc\n      if (typeof attr !== 'string') return attr;\n      // Map attributes to aliased syntax attributes\n      if (Model.rawAttributes[attr] && attr !== Model.rawAttributes[attr].field) {\n        return [Model.rawAttributes[attr].field, attr];\n      }\n      return attr;\n    });\n  }\n\n  if (options.where && _.isPlainObject(options.where)) {\n    options.where = mapWhereFieldNames(options.where, Model);\n  }\n\n  return options;\n}\nexports.mapOptionFieldNames = mapOptionFieldNames;\n\nfunction mapWhereFieldNames(attributes, Model) {\n  if (attributes) {\n    getComplexKeys(attributes).forEach(attribute => {\n      const rawAttribute = Model.rawAttributes[attribute];\n\n      if (rawAttribute && rawAttribute.field !== rawAttribute.fieldName) {\n        attributes[rawAttribute.field] = attributes[attribute];\n        delete attributes[attribute];\n      }\n\n      if (_.isPlainObject(attributes[attribute])\n        && !(rawAttribute && (\n          rawAttribute.type instanceof DataTypes.HSTORE\n          || rawAttribute.type instanceof DataTypes.JSON))) { // Prevent renaming of HSTORE & JSON fields\n        attributes[attribute] = mapOptionFieldNames({\n          where: attributes[attribute]\n        }, Model).where;\n      }\n\n      if (Array.isArray(attributes[attribute])) {\n        attributes[attribute].forEach((where, index) => {\n          if (_.isPlainObject(where)) {\n            attributes[attribute][index] = mapWhereFieldNames(where, Model);\n          }\n        });\n      }\n\n    });\n  }\n\n  return attributes;\n}\nexports.mapWhereFieldNames = mapWhereFieldNames;\n\n/* Used to map field names in values */\nfunction mapValueFieldNames(dataValues, fields, Model) {\n  const values = {};\n\n  for (const attr of fields) {\n    if (dataValues[attr] !== undefined && !Model._virtualAttributes.has(attr)) {\n      // Field name mapping\n      if (Model.rawAttributes[attr] && Model.rawAttributes[attr].field && Model.rawAttributes[attr].field !== attr) {\n        values[Model.rawAttributes[attr].field] = dataValues[attr];\n      } else {\n        values[attr] = dataValues[attr];\n      }\n    }\n  }\n\n  return values;\n}\nexports.mapValueFieldNames = mapValueFieldNames;\n\nfunction isColString(value) {\n  return typeof value === 'string' && value[0] === '$' && value[value.length - 1] === '$';\n}\nexports.isColString = isColString;\n\nfunction canTreatArrayAsAnd(arr) {\n  return arr.some(arg => _.isPlainObject(arg) || arg instanceof Where);\n}\nexports.canTreatArrayAsAnd = canTreatArrayAsAnd;\n\nfunction combineTableNames(tableName1, tableName2) {\n  return tableName1.toLowerCase() < tableName2.toLowerCase() ? tableName1 + tableName2 : tableName2 + tableName1;\n}\nexports.combineTableNames = combineTableNames;\n\nfunction toDefaultValue(value, dialect) {\n  if (typeof value === 'function') {\n    const tmp = value();\n    if (tmp instanceof DataTypes.ABSTRACT) {\n      return tmp.toSql();\n    }\n    return tmp;\n  }\n  if (value instanceof DataTypes.UUIDV1) {\n    return uuidv1();\n  }\n  if (value instanceof DataTypes.UUIDV4) {\n    return uuidv4();\n  }\n  if (value instanceof DataTypes.NOW) {\n    return now(dialect);\n  }\n  if (_.isPlainObject(value) || Array.isArray(value)) {\n    return _.clone(value);\n  }\n  return value;\n}\nexports.toDefaultValue = toDefaultValue;\n\n/**\n * Determine if the default value provided exists and can be described\n * in a db schema using the DEFAULT directive.\n *\n * @param  {*} value Any default value.\n * @returns {boolean} yes / no.\n * @private\n */\nfunction defaultValueSchemable(value) {\n  if (value === undefined) { return false; }\n\n  // TODO this will be schemable when all supported db\n  // have been normalized for this case\n  if (value instanceof DataTypes.NOW) { return false; }\n\n  if (value instanceof DataTypes.UUIDV1 || value instanceof DataTypes.UUIDV4) { return false; }\n\n  return typeof value !== 'function';\n}\nexports.defaultValueSchemable = defaultValueSchemable;\n\nfunction removeNullValuesFromHash(hash, omitNull, options) {\n  let result = hash;\n\n  options = options || {};\n  options.allowNull = options.allowNull || [];\n\n  if (omitNull) {\n    const _hash = {};\n\n    _.forIn(hash, (val, key) => {\n      if (options.allowNull.includes(key) || key.endsWith('Id') || val !== null && val !== undefined) {\n        _hash[key] = val;\n      }\n    });\n\n    result = _hash;\n  }\n\n  return result;\n}\nexports.removeNullValuesFromHash = removeNullValuesFromHash;\n\nfunction stack() {\n  const orig = Error.prepareStackTrace;\n  Error.prepareStackTrace = (_, stack) => stack;\n  const err = new Error();\n  Error.captureStackTrace(err, stack);\n  const errStack = err.stack;\n  Error.prepareStackTrace = orig;\n  return errStack;\n}\nexports.stack = stack;\n\nconst dialects = new Set(['mariadb', 'mysql', 'postgres', 'sqlite', 'mssql']);\n\nfunction now(dialect) {\n  const d = new Date();\n  if (!dialects.has(dialect)) {\n    d.setMilliseconds(0);\n  }\n  return d;\n}\nexports.now = now;\n\n// Note: Use the `quoteIdentifier()` and `escape()` methods on the\n// `QueryInterface` instead for more portable code.\n\nconst TICK_CHAR = '`';\nexports.TICK_CHAR = TICK_CHAR;\n\nfunction addTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return tickChar + removeTicks(s, tickChar) + tickChar;\n}\nexports.addTicks = addTicks;\n\nfunction removeTicks(s, tickChar) {\n  tickChar = tickChar || TICK_CHAR;\n  return s.replace(new RegExp(tickChar, 'g'), '');\n}\nexports.removeTicks = removeTicks;\n\n/**\n * Receives a tree-like object and returns a plain object which depth is 1.\n *\n * - Input:\n *\n *  {\n *    name: 'John',\n *    address: {\n *      street: 'Fake St. 123',\n *      coordinates: {\n *        longitude: 55.6779627,\n *        latitude: 12.5964313\n *      }\n *    }\n *  }\n *\n * - Output:\n *\n *  {\n *    name: 'John',\n *    address.street: 'Fake St. 123',\n *    address.coordinates.latitude: 55.6779627,\n *    address.coordinates.longitude: 12.5964313\n *  }\n *\n * @param {Object} value an Object\n * @returns {Object} a flattened object\n * @private\n */\nfunction flattenObjectDeep(value) {\n  if (!_.isPlainObject(value)) return value;\n  const flattenedObj = {};\n\n  function flattenObject(obj, subPath) {\n    Object.keys(obj).forEach(key => {\n      const pathToProperty = subPath ? `${subPath}.${key}` : key;\n      if (typeof obj[key] === 'object' && obj[key] !== null) {\n        flattenObject(obj[key], pathToProperty);\n      } else {\n        flattenedObj[pathToProperty] = _.get(obj, key);\n      }\n    });\n    return flattenedObj;\n  }\n\n  return flattenObject(value, undefined);\n}\nexports.flattenObjectDeep = flattenObjectDeep;\n\n/**\n * Utility functions for representing SQL functions, and columns that should be escaped.\n * Please do not use these functions directly, use Sequelize.fn and Sequelize.col instead.\n * @private\n */\nclass SequelizeMethod {}\nexports.SequelizeMethod = SequelizeMethod;\n\nclass Fn extends SequelizeMethod {\n  constructor(fn, args) {\n    super();\n    this.fn = fn;\n    this.args = args;\n  }\n  clone() {\n    return new Fn(this.fn, this.args);\n  }\n}\nexports.Fn = Fn;\n\nclass Col extends SequelizeMethod {\n  constructor(col, ...args) {\n    super();\n    if (args.length > 0) {\n      col = args;\n    }\n    this.col = col;\n  }\n}\nexports.Col = Col;\n\nclass Cast extends SequelizeMethod {\n  constructor(val, type, json) {\n    super();\n    this.val = val;\n    this.type = (type || '').trim();\n    this.json = json || false;\n  }\n}\nexports.Cast = Cast;\n\nclass Literal extends SequelizeMethod {\n  constructor(val) {\n    super();\n    this.val = val;\n  }\n}\nexports.Literal = Literal;\n\nclass Json extends SequelizeMethod {\n  constructor(conditionsOrPath, value) {\n    super();\n    if (_.isObject(conditionsOrPath)) {\n      this.conditions = conditionsOrPath;\n    } else {\n      this.path = conditionsOrPath;\n      if (value) {\n        this.value = value;\n      }\n    }\n  }\n}\nexports.Json = Json;\n\nclass Where extends SequelizeMethod {\n  constructor(attribute, comparator, logic) {\n    super();\n    if (logic === undefined) {\n      logic = comparator;\n      comparator = '=';\n    }\n\n    this.attribute = attribute;\n    this.comparator = comparator;\n    this.logic = logic;\n  }\n}\nexports.Where = Where;\n\n//Collection of helper methods to make it easier to work with symbol operators\n\n/**\n * getOperators\n *\n * @param  {Object} obj\n * @returns {Array<Symbol>} All operators properties of obj\n * @private\n */\nfunction getOperators(obj) {\n  return Object.getOwnPropertySymbols(obj).filter(s => operatorsSet.has(s));\n}\nexports.getOperators = getOperators;\n\n/**\n * getComplexKeys\n *\n * @param  {Object} obj\n * @returns {Array<string|Symbol>} All keys including operators\n * @private\n */\nfunction getComplexKeys(obj) {\n  return getOperators(obj).concat(Object.keys(obj));\n}\nexports.getComplexKeys = getComplexKeys;\n\n/**\n * getComplexSize\n *\n * @param  {Object|Array} obj\n * @returns {number}      Length of object properties including operators if obj is array returns its length\n * @private\n */\nfunction getComplexSize(obj) {\n  return Array.isArray(obj) ? obj.length : getComplexKeys(obj).length;\n}\nexports.getComplexSize = getComplexSize;\n\n/**\n * Returns true if a where clause is empty, even with Symbols\n *\n * @param  {Object} obj\n * @returns {boolean}\n * @private\n */\nfunction isWhereEmpty(obj) {\n  return !!obj && _.isEmpty(obj) && getOperators(obj).length === 0;\n}\nexports.isWhereEmpty = isWhereEmpty;\n\n/**\n * Returns ENUM name by joining table and column name\n *\n * @param {string} tableName\n * @param {string} columnName\n * @returns {string}\n * @private\n */\nfunction generateEnumName(tableName, columnName) {\n  return `enum_${tableName}_${columnName}`;\n}\nexports.generateEnumName = generateEnumName;\n\n/**\n * Returns an new Object which keys are camelized\n *\n * @param {Object} obj\n * @returns {string}\n * @private\n */\nfunction camelizeObjectKeys(obj) {\n  const newObj = new Object();\n  Object.keys(obj).forEach(key => {\n    newObj[camelize(key)] = obj[key];\n  });\n  return newObj;\n}\nexports.camelizeObjectKeys = camelizeObjectKeys;\n\n/**\n * Assigns own and inherited enumerable string and symbol keyed properties of source\n * objects to the destination object.\n *\n * https://lodash.com/docs/4.17.4#defaults\n *\n * **Note:** This method mutates `object`.\n *\n * @param {Object} object The destination object.\n * @param {...Object} [sources] The source objects.\n * @returns {Object} Returns `object`.\n * @private\n */\nfunction defaults(object, ...sources) {\n  object = Object(object);\n\n  sources.forEach(source => {\n    if (source) {\n      source = Object(source);\n\n      getComplexKeys(source).forEach(key => {\n        const value = object[key];\n        if (\n          value === undefined ||\n            _.eq(value, Object.prototype[key]) &&\n            !Object.prototype.hasOwnProperty.call(object, key)\n\n        ) {\n          object[key] = source[key];\n        }\n      });\n    }\n  });\n\n  return object;\n}\nexports.defaults = defaults;\n\n/**\n *\n * @param {Object} index\n * @param {Array}  index.fields\n * @param {string} [index.name]\n * @param {string|Object} tableName\n *\n * @returns {Object}\n * @private\n */\nfunction nameIndex(index, tableName) {\n  if (tableName.tableName) tableName = tableName.tableName;\n\n  if (!Object.prototype.hasOwnProperty.call(index, 'name')) {\n    const fields = index.fields.map(\n      field => typeof field === 'string' ? field : field.name || field.attribute\n    );\n    index.name = underscore(`${tableName}_${fields.join('_')}`);\n  }\n\n  return index;\n}\nexports.nameIndex = nameIndex;\n\n/**\n * Checks if 2 arrays intersect.\n *\n * @param {Array} arr1\n * @param {Array} arr2\n * @private\n */\nfunction intersects(arr1, arr2) {\n  return arr1.some(v => arr2.includes(v));\n}\nexports.intersects = intersects;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}