{"ast":null,"code":"'use strict';\n\nclass AbstractDialect {}\n\nAbstractDialect.prototype.supports = {\n  'DEFAULT': true,\n  'DEFAULT VALUES': false,\n  'VALUES ()': false,\n  'LIMIT ON UPDATE': false,\n  'ON DUPLICATE KEY': true,\n  'ORDER NULLS': false,\n  'UNION': true,\n  'UNION ALL': true,\n  'RIGHT JOIN': true,\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false,\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: false,\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: true,\n\n    /* does the dialect support updating autoincrement fields */\n    update: true\n  },\n\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: '',\n\n    /* dialect specific words for INSERT IGNORE or DO NOTHING */\n    updateOnDuplicate: false,\n\n    /* whether dialect supports ON DUPLICATE KEY UPDATE */\n    onConflictDoNothing: ''\n    /* dialect specific words for ON CONFLICT DO NOTHING */\n\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false\n  },\n  joinTableDependent: true,\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false\n};\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports.default = AbstractDialect;","map":{"version":3,"names":["AbstractDialect","prototype","supports","returnValues","autoIncrement","identityInsert","defaultValue","update","bulkDefault","schemas","transactions","settingIsolationLevelDuringTransaction","transactionOptions","type","migrations","upserts","inserts","ignoreDuplicates","updateOnDuplicate","onConflictDoNothing","constraints","restrict","addConstraint","dropConstraint","unique","default","check","foreignKey","primaryKey","index","collate","length","parser","concurrently","using","functionBased","joinTableDependent","groupedLimit","indexViaAlter","JSON","deferrableConstraints","module","exports"],"sources":["/home/brian/node_modules/sequelize/lib/dialects/abstract/index.js"],"sourcesContent":["'use strict';\n\nclass AbstractDialect {}\n\nAbstractDialect.prototype.supports = {\n  'DEFAULT': true,\n  'DEFAULT VALUES': false,\n  'VALUES ()': false,\n  'LIMIT ON UPDATE': false,\n  'ON DUPLICATE KEY': true,\n  'ORDER NULLS': false,\n  'UNION': true,\n  'UNION ALL': true,\n  'RIGHT JOIN': true,\n\n  /* does the dialect support returning values for inserted/updated fields */\n  returnValues: false,\n\n  /* features specific to autoIncrement values */\n  autoIncrement: {\n    /* does the dialect require modification of insert queries when inserting auto increment fields */\n    identityInsert: false,\n\n    /* does the dialect support inserting default/null values for autoincrement fields */\n    defaultValue: true,\n\n    /* does the dialect support updating autoincrement fields */\n    update: true\n  },\n  /* Do we need to say DEFAULT for bulk insert */\n  bulkDefault: false,\n  schemas: false,\n  transactions: true,\n  settingIsolationLevelDuringTransaction: true,\n  transactionOptions: {\n    type: false\n  },\n  migrations: true,\n  upserts: true,\n  inserts: {\n    ignoreDuplicates: '', /* dialect specific words for INSERT IGNORE or DO NOTHING */\n    updateOnDuplicate: false, /* whether dialect supports ON DUPLICATE KEY UPDATE */\n    onConflictDoNothing: '' /* dialect specific words for ON CONFLICT DO NOTHING */\n  },\n  constraints: {\n    restrict: true,\n    addConstraint: true,\n    dropConstraint: true,\n    unique: true,\n    default: false,\n    check: true,\n    foreignKey: true,\n    primaryKey: true\n  },\n  index: {\n    collate: true,\n    length: false,\n    parser: false,\n    concurrently: false,\n    type: false,\n    using: true,\n    functionBased: false\n  },\n  joinTableDependent: true,\n  groupedLimit: true,\n  indexViaAlter: false,\n  JSON: false,\n  deferrableConstraints: false\n};\n\nmodule.exports = AbstractDialect;\nmodule.exports.AbstractDialect = AbstractDialect;\nmodule.exports.default = AbstractDialect;\n"],"mappings":"AAAA;;AAEA,MAAMA,eAAN,CAAsB;;AAEtBA,eAAe,CAACC,SAAhB,CAA0BC,QAA1B,GAAqC;EACnC,WAAW,IADwB;EAEnC,kBAAkB,KAFiB;EAGnC,aAAa,KAHsB;EAInC,mBAAmB,KAJgB;EAKnC,oBAAoB,IALe;EAMnC,eAAe,KANoB;EAOnC,SAAS,IAP0B;EAQnC,aAAa,IARsB;EASnC,cAAc,IATqB;;EAWnC;EACAC,YAAY,EAAE,KAZqB;;EAcnC;EACAC,aAAa,EAAE;IACb;IACAC,cAAc,EAAE,KAFH;;IAIb;IACAC,YAAY,EAAE,IALD;;IAOb;IACAC,MAAM,EAAE;EARK,CAfoB;;EAyBnC;EACAC,WAAW,EAAE,KA1BsB;EA2BnCC,OAAO,EAAE,KA3B0B;EA4BnCC,YAAY,EAAE,IA5BqB;EA6BnCC,sCAAsC,EAAE,IA7BL;EA8BnCC,kBAAkB,EAAE;IAClBC,IAAI,EAAE;EADY,CA9Be;EAiCnCC,UAAU,EAAE,IAjCuB;EAkCnCC,OAAO,EAAE,IAlC0B;EAmCnCC,OAAO,EAAE;IACPC,gBAAgB,EAAE,EADX;;IACe;IACtBC,iBAAiB,EAAE,KAFZ;;IAEmB;IAC1BC,mBAAmB,EAAE;IAAG;;EAHjB,CAnC0B;EAwCnCC,WAAW,EAAE;IACXC,QAAQ,EAAE,IADC;IAEXC,aAAa,EAAE,IAFJ;IAGXC,cAAc,EAAE,IAHL;IAIXC,MAAM,EAAE,IAJG;IAKXC,OAAO,EAAE,KALE;IAMXC,KAAK,EAAE,IANI;IAOXC,UAAU,EAAE,IAPD;IAQXC,UAAU,EAAE;EARD,CAxCsB;EAkDnCC,KAAK,EAAE;IACLC,OAAO,EAAE,IADJ;IAELC,MAAM,EAAE,KAFH;IAGLC,MAAM,EAAE,KAHH;IAILC,YAAY,EAAE,KAJT;IAKLpB,IAAI,EAAE,KALD;IAMLqB,KAAK,EAAE,IANF;IAOLC,aAAa,EAAE;EAPV,CAlD4B;EA2DnCC,kBAAkB,EAAE,IA3De;EA4DnCC,YAAY,EAAE,IA5DqB;EA6DnCC,aAAa,EAAE,KA7DoB;EA8DnCC,IAAI,EAAE,KA9D6B;EA+DnCC,qBAAqB,EAAE;AA/DY,CAArC;AAkEAC,MAAM,CAACC,OAAP,GAAiB1C,eAAjB;AACAyC,MAAM,CAACC,OAAP,CAAe1C,eAAf,GAAiCA,eAAjC;AACAyC,MAAM,CAACC,OAAP,CAAejB,OAAf,GAAyBzB,eAAzB"},"metadata":{},"sourceType":"script"}