{"ast":null,"code":"import { ValidationError } from \"../utils/validationError\";\nconst LOAD = \"song/LOAD\";\nconst LOAD_TYPES = \"song/LOAD_TYPES\";\nconst ADD_ONE = \"song/ADD_ONE\";\n\nconst load = list => ({\n  type: LOAD,\n  list\n});\n\nexport const getSongs = () => async dispatch => {\n  const response = await fetch(`/api/songs`);\n\n  if (response.ok) {\n    const list = await response.json();\n    dispatch(load(list));\n  }\n};\n\nconst addsong = song => {\n  console.log('IN ADD_ONE_POKEMON ACTION - POKEMON -> ', song);\n  return {\n    type: ADD_ONE,\n    song: song\n  };\n};\n\nexport const createSong = data => async dispatch => {\n  console.log(\"TOP OF THUNK IN STORE - data -> \", data);\n\n  try {\n    const response = await fetch(`/api/songs`, {\n      method: \"post\",\n      headers: {\n        \"Content-Type\": \"application/json\"\n      },\n      body: JSON.stringify(data)\n    });\n\n    if (!response.ok) {\n      let error;\n\n      if (response.status === 422) {\n        error = await response.json();\n        throw new ValidationError(error.errors, response.statusText);\n      } else {\n        let errorJSON;\n        error = await response.text();\n\n        try {\n          // Check if the error is JSON, i.e., from the Pokemon server. If so,\n          // don't throw error yet or it will be caught by the following catch\n          errorJSON = JSON.parse(error);\n        } catch {\n          // Case if server could not be reached\n          throw new Error(error);\n        }\n\n        throw new Error(`${errorJSON.title}: ${errorJSON.message}`);\n      }\n    }\n\n    const song = await response.json();\n    dispatch(addOnePokemon(pokemon));\n    return pokemon;\n  } catch (error) {\n    throw error;\n  }\n};\n\nconst sortList = list => {\n  return list.sort((a, b) => {\n    return a - b;\n  }).map(song => song.id);\n};\n\nconst initialState = {\n  list: []\n};\n\nconst songReducer = function () {\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case LOAD:\n      const Songs = {};\n      action.list.forEach(song => {\n        Songs[song.id] = song;\n      });\n      return { ...Songs,\n        ...state,\n        list: sortList(action.list)\n      };\n\n    case LOAD_TYPES:\n      return { ...state,\n        types: action.types\n      };\n\n    default:\n      return state;\n  }\n};","map":{"version":3,"names":["ValidationError","LOAD","LOAD_TYPES","ADD_ONE","load","list","type","getSongs","dispatch","response","fetch","ok","json","addsong","song","console","log","createSong","data","method","headers","body","JSON","stringify","error","status","errors","statusText","errorJSON","text","parse","Error","title","message","addOnePokemon","pokemon","sortList","sort","a","b","map","id","initialState","songReducer","state","action","Songs","forEach","types"],"sources":["/home/brian/w15/practice-for-week-15-react-redux-authenticate-me-long-practice-main/authenticate-me/frontend/src/store/songs.js"],"sourcesContent":["import { ValidationError } from \"../utils/validationError\";\nconst LOAD = \"song/LOAD\";\nconst LOAD_TYPES = \"song/LOAD_TYPES\";\nconst ADD_ONE = \"song/ADD_ONE\";\n\n\n\nconst load = (list) => ({\n    type: LOAD,\n    list,\n  });\n\n  export const getSongs = () => async (dispatch) => {\n    const response = await fetch(`/api/songs`);\n\n    if (response.ok) {\n      const list = await response.json();\n      dispatch(load(list));\n    }\n  };\n\n  const addsong= (song) => {\n    console.log('IN ADD_ONE_POKEMON ACTION - POKEMON -> ', song)\n    return {\n      type: ADD_ONE,\n      song:song,\n    };\n  };\n\n  export const createSong = (data) => async (dispatch) => {\n    console.log(\"TOP OF THUNK IN STORE - data -> \", data);\n    try {\n      const response = await fetch(`/api/songs`, {\n        method: \"post\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n        },\n        body: JSON.stringify(data),\n      });\n\n\n    if (!response.ok) {\n        let error;\n        if (response.status === 422) {\n          error = await response.json();\n          throw new ValidationError(error.errors, response.statusText);\n        } else {\n          let errorJSON;\n          error = await response.text();\n          try {\n            // Check if the error is JSON, i.e., from the Pokemon server. If so,\n            // don't throw error yet or it will be caught by the following catch\n            errorJSON = JSON.parse(error);\n          } catch {\n            // Case if server could not be reached\n            throw new Error(error);\n          }\n          throw new Error(`${errorJSON.title}: ${errorJSON.message}`);\n        }\n      }\n      const song = await response.json();\n\n\n\n    dispatch(addOnePokemon(pokemon));\n    return pokemon;\n  } catch (error) {\n    throw error;\n  }\n};\n\n\n  const sortList = (list) => {\n    return list\n      .sort((a, b) => {\n        return a - b;\n      })\n      .map((song) => song.id);\n  };\n\n\n  const initialState = {list:[]}\n\n\nconst songReducer = (state = initialState, action) => {\n    switch (action.type) {\n        case LOAD:\n            const Songs = {};\n            action.list.forEach((song) => {\n              Songs[song.id] = song\n            });\n            return {\n              ...Songs,\n              ...state,\n              list: sortList(action.list),\n            };\n          case LOAD_TYPES:\n            return {\n              ...state,\n              types: action.types,\n            };\n        default:\n            return state;\n    }\n}\n"],"mappings":"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"},"metadata":{},"sourceType":"module"}