{"ast":null,"code":"'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\n\nconst SequelizeErrors = require('../../errors');\n\nconst Promise = require('../../promise');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst DataTypes = require('../../data-types').mysql;\n\nconst momentTz = require('moment-timezone');\n\nconst debug = logger.debugContext('connection:mysql');\n\nconst parserStore = require('../parserStore')('mysql');\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @returns Class<ConnectionManager>\n * @private\n */\n\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n\n    return next();\n  }\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {Object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n\n\n  connect(config) {\n    const connectionConfig = Object.assign({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n    return new Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect & error event if there is error\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('error', connectHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        // clean up error event if connected\n        connection.removeListener('error', errorHandler);\n        resolve(connection);\n      }; // don't use connection.once for error event handling here\n      // mysql2 emit error two times in case handshake was failed\n      // first error is protocol_lost and second is timeout\n      // if we will use `once.error` node process will crash on 2nd error emit\n\n\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    }).tap(() => {\n      debug('connection acquired');\n    }).then(connection => {\n      connection.on('error', error => {\n        switch (error.code) {\n          case 'ESOCKET':\n          case 'ECONNRESET':\n          case 'EPIPE':\n          case 'PROTOCOL_CONNECTION_LOST':\n            this.pool.destroy(connection);\n        }\n      });\n      return new Promise((resolve, reject) => {\n        if (!this.sequelize.config.keepDefaultTimezone) {\n          // set timezone for this connection\n          // but named timezone are not directly supported in mysql, so get its offset first\n          let tzOffset = this.sequelize.options.timezone;\n          tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n          return connection.query(`SET time_zone = '${tzOffset}'`, err => {\n            if (err) {\n              reject(err);\n            } else {\n              resolve(connection);\n            }\n          });\n        } // return connection without executing SET time_zone query\n\n\n        resolve(connection);\n      });\n    }).catch(err => {\n      switch (err.code) {\n        case 'ECONNREFUSED':\n          throw new SequelizeErrors.ConnectionRefusedError(err);\n\n        case 'ER_ACCESS_DENIED_ERROR':\n          throw new SequelizeErrors.AccessDeniedError(err);\n\n        case 'ENOTFOUND':\n          throw new SequelizeErrors.HostNotFoundError(err);\n\n        case 'EHOSTUNREACH':\n          throw new SequelizeErrors.HostNotReachableError(err);\n\n        case 'EINVAL':\n          throw new SequelizeErrors.InvalidConnectionError(err);\n\n        default:\n          throw new SequelizeErrors.ConnectionError(err);\n      }\n    });\n  }\n\n  disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return connection && !connection._fatalError && !connection._protocolError && !connection._closing && !connection.stream.destroyed;\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["AbstractConnectionManager","require","SequelizeErrors","Promise","logger","DataTypes","mysql","momentTz","debug","debugContext","parserStore","ConnectionManager","constructor","dialect","sequelize","config","port","lib","_loadDialectModule","refreshTypeParser","_refreshTypeParser","dataType","refresh","_clearTypeParser","clear","_typecast","field","next","get","type","options","connect","connectionConfig","Object","assign","host","user","username","flags","password","database","timezone","typeCast","bind","bigNumberStrings","supportBigNumbers","dialectOptions","resolve","reject","connection","createConnection","errorHandler","e","removeListener","connectHandler","on","once","tap","then","error","code","pool","destroy","keepDefaultTimezone","tzOffset","test","tz","format","query","err","catch","ConnectionRefusedError","AccessDeniedError","HostNotFoundError","HostNotReachableError","InvalidConnectionError","ConnectionError","disconnect","_closing","fromCallback","callback","end","validate","_fatalError","_protocolError","stream","destroyed","module","exports","default"],"sources":["/home/brian/node_modules/sequelize/lib/dialects/mysql/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst AbstractConnectionManager = require('../abstract/connection-manager');\nconst SequelizeErrors = require('../../errors');\nconst Promise = require('../../promise');\nconst { logger } = require('../../utils/logger');\nconst DataTypes = require('../../data-types').mysql;\nconst momentTz = require('moment-timezone');\nconst debug = logger.debugContext('connection:mysql');\nconst parserStore = require('../parserStore')('mysql');\n\n/**\n * MySQL Connection Manager\n *\n * Get connections, validate and disconnect them.\n * AbstractConnectionManager pooling use it to handle MySQL specific connections\n * Use https://github.com/sidorares/node-mysql2 to connect with MySQL server\n *\n * @extends AbstractConnectionManager\n * @returns Class<ConnectionManager>\n * @private\n */\n\nclass ConnectionManager extends AbstractConnectionManager {\n  constructor(dialect, sequelize) {\n    sequelize.config.port = sequelize.config.port || 3306;\n    super(dialect, sequelize);\n    this.lib = this._loadDialectModule('mysql2');\n    this.refreshTypeParser(DataTypes);\n  }\n\n  _refreshTypeParser(dataType) {\n    parserStore.refresh(dataType);\n  }\n\n  _clearTypeParser() {\n    parserStore.clear();\n  }\n\n  static _typecast(field, next) {\n    if (parserStore.get(field.type)) {\n      return parserStore.get(field.type)(field, this.sequelize.options, next);\n    }\n    return next();\n  }\n\n  /**\n   * Connect with MySQL database based on config, Handle any errors in connection\n   * Set the pool handlers on connection.error\n   * Also set proper timezone once connection is connected.\n   *\n   * @param {Object} config\n   * @returns {Promise<Connection>}\n   * @private\n   */\n  connect(config) {\n    const connectionConfig = Object.assign({\n      host: config.host,\n      port: config.port,\n      user: config.username,\n      flags: '-FOUND_ROWS',\n      password: config.password,\n      database: config.database,\n      timezone: this.sequelize.options.timezone,\n      typeCast: ConnectionManager._typecast.bind(this),\n      bigNumberStrings: false,\n      supportBigNumbers: true\n    }, config.dialectOptions);\n\n    return new Promise((resolve, reject) => {\n      const connection = this.lib.createConnection(connectionConfig);\n\n      const errorHandler = e => {\n        // clean up connect & error event if there is error\n        connection.removeListener('connect', connectHandler);\n        connection.removeListener('error', connectHandler);\n        reject(e);\n      };\n\n      const connectHandler = () => {\n        // clean up error event if connected\n        connection.removeListener('error', errorHandler);\n        resolve(connection);\n      };\n\n      // don't use connection.once for error event handling here\n      // mysql2 emit error two times in case handshake was failed\n      // first error is protocol_lost and second is timeout\n      // if we will use `once.error` node process will crash on 2nd error emit\n      connection.on('error', errorHandler);\n      connection.once('connect', connectHandler);\n    })\n      .tap(() => { debug('connection acquired'); })\n      .then(connection => {\n        connection.on('error', error => {\n          switch (error.code) {\n            case 'ESOCKET':\n            case 'ECONNRESET':\n            case 'EPIPE':\n            case 'PROTOCOL_CONNECTION_LOST':\n              this.pool.destroy(connection);\n          }\n        });\n\n        return new Promise((resolve, reject) => {\n          if (!this.sequelize.config.keepDefaultTimezone) {\n            // set timezone for this connection\n            // but named timezone are not directly supported in mysql, so get its offset first\n            let tzOffset = this.sequelize.options.timezone;\n            tzOffset = /\\//.test(tzOffset) ? momentTz.tz(tzOffset).format('Z') : tzOffset;\n            return connection.query(`SET time_zone = '${tzOffset}'`, err => {\n              if (err) { reject(err); } else { resolve(connection); }\n            });\n          }\n\n          // return connection without executing SET time_zone query\n          resolve(connection);\n        });\n      })\n      .catch(err => {\n        switch (err.code) {\n          case 'ECONNREFUSED':\n            throw new SequelizeErrors.ConnectionRefusedError(err);\n          case 'ER_ACCESS_DENIED_ERROR':\n            throw new SequelizeErrors.AccessDeniedError(err);\n          case 'ENOTFOUND':\n            throw new SequelizeErrors.HostNotFoundError(err);\n          case 'EHOSTUNREACH':\n            throw new SequelizeErrors.HostNotReachableError(err);\n          case 'EINVAL':\n            throw new SequelizeErrors.InvalidConnectionError(err);\n          default:\n            throw new SequelizeErrors.ConnectionError(err);\n        }\n      });\n  }\n\n  disconnect(connection) {\n    // Don't disconnect connections with CLOSED state\n    if (connection._closing) {\n      debug('connection tried to disconnect but was already at CLOSED state');\n      return Promise.resolve();\n    }\n\n    return Promise.fromCallback(callback => connection.end(callback));\n  }\n\n  validate(connection) {\n    return connection\n      && !connection._fatalError\n      && !connection._protocolError\n      && !connection._closing\n      && !connection.stream.destroyed;\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}