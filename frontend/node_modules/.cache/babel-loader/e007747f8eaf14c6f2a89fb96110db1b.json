{"ast":null,"code":"'use strict';\n\nconst Utils = require('../../utils');\n\nconst util = require('util');\n\nconst DataTypes = require('../../data-types');\n\nconst AbstractQueryGenerator = require('../abstract/query-generator');\n\nconst semver = require('semver');\n\nconst _ = require('lodash');\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      encoding: null,\n      collate: null\n    }, options || {});\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''\n    };\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({}, options || {}); //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  }\n\n  describeTableQuery(tableName, schema) {\n    if (!schema) schema = 'public';\n    return 'SELECT ' + 'pk.constraint_type as \"Constraint\",' + 'c.column_name as \"Field\", ' + 'c.column_default as \"Default\",' + 'c.is_nullable as \"Null\", ' + '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' + '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", ' + '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" ' + 'FROM information_schema.columns c ' + 'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' + 'cu.column_name, tc.constraint_type ' + 'FROM information_schema.TABLE_CONSTRAINTS tc ' + 'JOIN information_schema.KEY_COLUMN_USAGE  cu ' + 'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' + 'and tc.constraint_name=cu.constraint_name ' + 'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' + 'ON pk.table_schema=c.table_schema ' + 'AND pk.table_name=c.table_name ' + 'AND pk.column_name=c.column_name ' + `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;\n  }\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n\n\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    } // https://www.postgresql.org/docs/current/static/functions-json.html\n\n\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    } // Check invalid json statement\n\n\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    } // return true if the statement has valid json function\n\n\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition => `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`);\n        return conditions.join(' AND ');\n      }\n\n      if (smth.path) {\n        let str; // Allow specifying conditions using the postgres json syntax\n\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n    const dbDataType = this.attributeToSQL(dataType, {\n      context: 'addColumn',\n      table,\n      key\n    });\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType.type && dataType.type instanceof DataTypes.ENUM || dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n\n    const sql = [];\n\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, {\n          schema: false\n        }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  exceptionFn(fnName, tableName, parameters, main, then, when, returns, language) {\n    when = when || 'unique_violation';\n    const body = `${main} EXCEPTION WHEN ${when} THEN ${then};`;\n    return this.fn(fnName, tableName, parameters, body, returns, language);\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const primaryField = this.quoteIdentifier(model.primaryKeyField);\n\n    const upsertOptions = _.defaults({\n      bindParam: false\n    }, options);\n\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    if (options.returning) {\n      const returningRegex = /RETURNING \\*(?![\\s\\S]*RETURNING \\*)/;\n      insert.query = insert.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n      update.query = update.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n    }\n\n    return this.exceptionFn('sequelize_upsert', tableName, 'OUT created boolean, OUT primary_key text', `${insert.query} created := true;`, `${update.query}; created := false`);\n  }\n\n  truncateTableQuery(tableName) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return [`TRUNCATE ${this.quoteTable(tableName)}`, options.restartIdentity ? ' RESTART IDENTITY' : '', options.cascade ? ' CASCADE' : ''].join('');\n  }\n\n  deleteQuery(tableName, where) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let model = arguments.length > 3 ? arguments[3] : undefined;\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = _.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n\n    if (typeof tableName !== 'string') {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    } // This is ARCANE!\n\n\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' + 'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' + `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` + 'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' + `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` + 'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  }\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return ['SELECT constraint_catalog AS \"constraintCatalog\",', 'constraint_schema AS \"constraintSchema\",', 'constraint_name AS \"constraintName\",', 'table_catalog AS \"tableCatalog\",', 'table_schema AS \"tableSchema\",', 'table_name AS \"tableName\",', 'constraint_type AS \"constraintType\",', 'is_deferrable AS \"isDeferrable\",', 'initially_deferred AS \"initiallyDeferred\"', 'from INFORMATION_SCHEMA.table_constraints', `WHERE table_name='${tableName}';`].join(' ');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n\n    if (attribute.type instanceof DataTypes.ENUM || attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if ((!attribute.references.model || typeof attribute.references.model == 'string') && options.table && options.table.schema) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (attribute.references.key) {\n        referencesKey = this.quoteIdentifiers(attribute.references.key);\n      } else {\n        referencesKey = this.quoteIdentifier('id');\n      }\n\n      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n      if (attribute.onDelete) {\n        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n\n      if (attribute.references.deferrable) {\n        sql += ` ${attribute.references.deferrable.toString(this)}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, Object.assign({\n        key\n      }, options || {}));\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this.expandFunctionParamList(functionParams);\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n    const paramList = this.expandFunctionParamList(params);\n    const variableList = options && options.variables ? this.expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName'); // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n\n    const paramList = this.expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this.expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  databaseConnectionUri(config) {\n    let uri = `${config.protocol}://${config.user}:${config.password}@${config.host}`;\n\n    if (config.port) {\n      uri += `:${config.port}`;\n    }\n\n    uri += `/${config.database}`;\n\n    if (config.ssl) {\n      uri += `?ssl=${config.ssl}`;\n    }\n\n    return uri;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n\n      if (curParam.type) {\n        if (curParam.direction) {\n          paramDef.push(curParam.direction);\n        }\n\n        if (curParam.name) {\n          paramDef.push(curParam.name);\n        }\n\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n    });\n    return paramList.join(', ');\n  }\n\n  expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error('expandFunctionVariableList: function variables must be an array');\n    }\n\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || _.isEmpty(options) ? '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n\n      if (eventSpec === 'UPDATE') {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(', ')}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"'); // pgListEnums requires the enum name only, without the schema\n\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, {\n        schema: false\n      }).replace(/\"/g, \"'\")}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' + 'JOIN pg_enum e ON t.oid = e.enumtypid ' + 'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' + `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/g, ''));\n    return matches.slice(0, -1);\n  }\n\n  padInt(i) {\n    return i < 10 ? `0${i.toString()}` : i.toString();\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' + `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n  /**\n   * Generate common SQL prefix for getForeignKeyReferencesQuery.\n   *\n   * @returns {string}\n   */\n\n\n  _getForeignKeyReferencesQueryPrefix() {\n    return 'SELECT ' + 'DISTINCT tc.constraint_name as constraint_name, ' + 'tc.constraint_schema as constraint_schema, ' + 'tc.constraint_catalog as constraint_catalog, ' + 'tc.table_name as table_name,' + 'tc.table_schema as table_schema,' + 'tc.table_catalog as table_catalog,' + 'kcu.column_name as column_name,' + 'ccu.table_schema  AS referenced_table_schema,' + 'ccu.table_catalog  AS referenced_table_catalog,' + 'ccu.table_name  AS referenced_table_name,' + 'ccu.column_name AS referenced_column_name ' + 'FROM information_schema.table_constraints AS tc ' + 'JOIN information_schema.key_column_usage AS kcu ' + 'ON tc.constraint_name = kcu.constraint_name ' + 'JOIN information_schema.constraint_column_usage AS ccu ' + 'ON ccu.constraint_name = tc.constraint_name ';\n  }\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.\n   *\n   * @param {string} tableName\n   * @param {string} catalogName\n   * @param {string} schemaName\n   */\n\n\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''}${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()}WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${schema ? ` AND tc.table_schema = '${schema}'` : ''}`;\n  }\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n\n\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n\n}\n\nmodule.exports = PostgresQueryGenerator;","map":{"version":3,"names":["Utils","require","util","DataTypes","AbstractQueryGenerator","semver","_","PostgresQueryGenerator","setSearchPath","searchPath","createDatabaseQuery","databaseName","options","Object","assign","encoding","collate","values","database","quoteTable","escape","collation","ctype","template","dropDatabaseQuery","createSchema","schema","databaseVersion","get","gte","dropSchema","showSchemasQuery","versionQuery","createTableQuery","tableName","attributes","attrStr","comments","columnComments","quotedTable","comment","attr","quotedAttr","quoteIdentifier","i","indexOf","escapedCommentText","substring","dataType","dataTypeMapping","push","attributesClause","join","uniqueKeys","each","columns","customIndex","fields","map","field","pks","reduce","acc","attribute","key","includes","length","dropTableQuery","cascade","showTablesQuery","describeTableQuery","_checkValidJsonStatement","stmt","jsonFunctionRegex","jsonOperatorRegex","tokenCaptureRegex","currentIndex","openingBrackets","closingBrackets","hasJsonFunction","hasInvalidToken","string","substr","functionMatches","exec","operatorMatches","tokenMatches","capturedToken","Error","handleSequelizeMethod","smth","factory","prepend","Json","conditions","parseConditionObject","condition","jsonPathExtractionQuery","path","tail","value","str","paths","toPath","column","shift","format","call","addColumnQuery","table","dbDataType","attributeToSQL","context","definition","quotedKey","extractTableDetails","query","type","ENUM","pgEnum","removeColumnQuery","attributeName","quotedTableName","quotedAttributeName","changeColumnQuery","subQuery","sql","attrSql","replace","trim","match","startsWith","pgEnumName","renameColumnQuery","attrBefore","attrString","fn","fnName","parameters","body","returns","language","exceptionFn","main","then","when","upsertQuery","insertValues","updateValues","where","model","primaryField","primaryKeyField","upsertOptions","defaults","bindParam","insert","insertQuery","rawAttributes","update","updateQuery","returning","returningRegex","truncateTableQuery","restartIdentity","deleteQuery","whereClause","getWhereConditions","limit","primaryKeys","primaryKeysSelection","pk","primaryKeyAttributes","showIndexesQuery","schemaJoin","schemaWhere","showConstraintsQuery","removeIndexQuery","indexNameOrAttributes","indexName","underscore","quoteIdentifiers","addLimitAndOffset","fragment","offset","isPlainObject","ARRAY","enumType","Array","isArray","toString","prototype","hasOwnProperty","allowNull","autoIncrement","autoIncrementIdentity","defaultValueSchemable","defaultValue","unique","primaryKey","references","referencesTable","addSchema","_schema","referencesKey","onDelete","toUpperCase","onUpdate","deferrable","deferConstraintsQuery","setConstraintQuery","columnFragment","setDeferredQuery","setImmediateQuery","attributesToSQL","result","createTrigger","triggerName","eventType","fireOnSpec","functionName","functionParams","optionsArray","decodedEventType","decodeTriggerEventType","eventSpec","expandTriggerEventSpec","expandedOptions","expandOptions","paramList","expandFunctionParamList","triggerEventTypeIsConstraint","dropTrigger","renameTrigger","oldTriggerName","newTriggerName","createFunction","params","returnType","variableList","variables","expandFunctionVariableList","expandedOptionsArray","statement","force","dropFunction","renameFunction","oldFunctionName","newFunctionName","databaseConnectionUri","config","uri","protocol","user","password","host","port","ssl","pgEscapeAndQuote","val","removeTicks","undefined","forEach","curParam","paramDef","direction","name","joined","variableDefinitions","variable","variableDefinition","default","isEmpty","eventSpecifier","EVENT_DECODER","fireValue","fireKey","EVENT_MAP","tableDetails","enumName","addTicks","generateEnumName","delimiter","pgListEnums","attrName","pgEnumDrop","pgEnumAdd","sequelize","before","after","fromArray","text","matches","m","slice","padInt","getForeignKeysQuery","_getForeignKeyReferencesQueryPrefix","getForeignKeyReferencesQuery","catalogName","schemaName","getForeignKeyReferenceQuery","columnName","dropForeignKeyQuery","foreignKey","module","exports"],"sources":["/home/brian/node_modules/sequelize/lib/dialects/postgres/query-generator.js"],"sourcesContent":["'use strict';\n\nconst Utils = require('../../utils');\nconst util = require('util');\nconst DataTypes = require('../../data-types');\nconst AbstractQueryGenerator = require('../abstract/query-generator');\nconst semver = require('semver');\nconst _ = require('lodash');\n\nclass PostgresQueryGenerator extends AbstractQueryGenerator {\n  setSearchPath(searchPath) {\n    return `SET search_path to ${searchPath};`;\n  }\n\n  createDatabaseQuery(databaseName, options) {\n    options = Object.assign({\n      encoding: null,\n      collate: null\n    }, options || {});\n\n    const values = {\n      database: this.quoteTable(databaseName),\n      encoding: options.encoding ? ` ENCODING = ${this.escape(options.encoding)}` : '',\n      collation: options.collate ? ` LC_COLLATE = ${this.escape(options.collate)}` : '',\n      ctype: options.ctype ? ` LC_CTYPE = ${this.escape(options.ctype)}` : '',\n      template: options.template ? ` TEMPLATE = ${this.escape(options.template)}` : ''\n    };\n\n    return `CREATE DATABASE ${values.database}${values.encoding}${values.collation}${values.ctype}${values.template};`;\n  }\n\n  dropDatabaseQuery(databaseName) {\n    return `DROP DATABASE IF EXISTS ${this.quoteTable(databaseName)};`;\n  }\n\n  createSchema(schema) {\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n\n    if (databaseVersion && semver.gte(databaseVersion, '9.2.0')) {\n      return `CREATE SCHEMA IF NOT EXISTS ${schema};`;\n    }\n\n    return `CREATE SCHEMA ${schema};`;\n  }\n\n  dropSchema(schema) {\n    return `DROP SCHEMA IF EXISTS ${schema} CASCADE;`;\n  }\n\n  showSchemasQuery() {\n    return \"SELECT schema_name FROM information_schema.schemata WHERE schema_name <> 'information_schema' AND schema_name != 'public' AND schema_name !~ E'^pg_';\";\n  }\n\n  versionQuery() {\n    return 'SHOW SERVER_VERSION';\n  }\n\n  createTableQuery(tableName, attributes, options) {\n    options = Object.assign({}, options || {});\n\n    //Postgres 9.0 does not support CREATE TABLE IF NOT EXISTS, 9.1 and above do\n    const databaseVersion = _.get(this, 'sequelize.options.databaseVersion', 0);\n    const attrStr = [];\n    let comments = '';\n    let columnComments = '';\n\n    const quotedTable = this.quoteTable(tableName);\n\n    if (options.comment && typeof options.comment === 'string') {\n      comments += `; COMMENT ON TABLE ${quotedTable} IS ${this.escape(options.comment)}`;\n    }\n\n    for (const attr in attributes) {\n      const quotedAttr = this.quoteIdentifier(attr);\n      const i = attributes[attr].indexOf('COMMENT ');\n      if (i !== -1) {\n        // Move comment to a separate query\n        const escapedCommentText = this.escape(attributes[attr].substring(i + 8));\n        columnComments += `; COMMENT ON COLUMN ${quotedTable}.${quotedAttr} IS ${escapedCommentText}`;\n        attributes[attr] = attributes[attr].substring(0, i);\n      }\n\n      const dataType = this.dataTypeMapping(tableName, attr, attributes[attr]);\n      attrStr.push(`${quotedAttr} ${dataType}`);\n    }\n\n\n    let attributesClause = attrStr.join(', ');\n\n    if (options.uniqueKeys) {\n      _.each(options.uniqueKeys, columns => {\n        if (columns.customIndex) {\n          attributesClause += `, UNIQUE (${columns.fields.map(field => this.quoteIdentifier(field)).join(', ')})`;\n        }\n      });\n    }\n\n    const pks = _.reduce(attributes, (acc, attribute, key) => {\n      if (attribute.includes('PRIMARY KEY')) {\n        acc.push(this.quoteIdentifier(key));\n      }\n      return acc;\n    }, []).join(',');\n\n    if (pks.length > 0) {\n      attributesClause += `, PRIMARY KEY (${pks})`;\n    }\n\n    return `CREATE TABLE ${databaseVersion === 0 || semver.gte(databaseVersion, '9.1.0') ? 'IF NOT EXISTS ' : ''}${quotedTable} (${attributesClause})${comments}${columnComments};`;\n  }\n\n  dropTableQuery(tableName, options) {\n    options = options || {};\n    return `DROP TABLE IF EXISTS ${this.quoteTable(tableName)}${options.cascade ? ' CASCADE' : ''};`;\n  }\n\n  showTablesQuery() {\n    return \"SELECT table_name FROM information_schema.tables WHERE table_schema = 'public' AND table_type LIKE '%TABLE' AND table_name != 'spatial_ref_sys';\";\n  }\n\n  describeTableQuery(tableName, schema) {\n    if (!schema) schema = 'public';\n\n    return 'SELECT ' +\n      'pk.constraint_type as \"Constraint\",' +\n      'c.column_name as \"Field\", ' +\n      'c.column_default as \"Default\",' +\n      'c.is_nullable as \"Null\", ' +\n      '(CASE WHEN c.udt_name = \\'hstore\\' THEN c.udt_name ELSE c.data_type END) || (CASE WHEN c.character_maximum_length IS NOT NULL THEN \\'(\\' || c.character_maximum_length || \\')\\' ELSE \\'\\' END) as \"Type\", ' +\n      '(SELECT array_agg(e.enumlabel) FROM pg_catalog.pg_type t JOIN pg_catalog.pg_enum e ON t.oid=e.enumtypid WHERE t.typname=c.udt_name) AS \"special\", ' +\n      '(SELECT pgd.description FROM pg_catalog.pg_statio_all_tables AS st INNER JOIN pg_catalog.pg_description pgd on (pgd.objoid=st.relid) WHERE c.ordinal_position=pgd.objsubid AND c.table_name=st.relname) AS \"Comment\" ' +\n      'FROM information_schema.columns c ' +\n      'LEFT JOIN (SELECT tc.table_schema, tc.table_name, ' +\n      'cu.column_name, tc.constraint_type ' +\n      'FROM information_schema.TABLE_CONSTRAINTS tc ' +\n      'JOIN information_schema.KEY_COLUMN_USAGE  cu ' +\n      'ON tc.table_schema=cu.table_schema and tc.table_name=cu.table_name ' +\n      'and tc.constraint_name=cu.constraint_name ' +\n      'and tc.constraint_type=\\'PRIMARY KEY\\') pk ' +\n      'ON pk.table_schema=c.table_schema ' +\n      'AND pk.table_name=c.table_name ' +\n      'AND pk.column_name=c.column_name ' +\n      `WHERE c.table_name = ${this.escape(tableName)} AND c.table_schema = ${this.escape(schema)} `;\n  }\n\n  /**\n   * Check whether the statmement is json function or simple path\n   *\n   * @param   {string}  stmt  The statement to validate\n   * @returns {boolean}       true if the given statement is json function\n   * @throws  {Error}         throw if the statement looks like json function but has invalid token\n   */\n  _checkValidJsonStatement(stmt) {\n    if (typeof stmt !== 'string') {\n      return false;\n    }\n\n    // https://www.postgresql.org/docs/current/static/functions-json.html\n    const jsonFunctionRegex = /^\\s*((?:[a-z]+_){0,2}jsonb?(?:_[a-z]+){0,2})\\([^)]*\\)/i;\n    const jsonOperatorRegex = /^\\s*(->>?|#>>?|@>|<@|\\?[|&]?|\\|{2}|#-)/i;\n    const tokenCaptureRegex = /^\\s*((?:([`\"'])(?:(?!\\2).|\\2{2})*\\2)|[\\w\\d\\s]+|[().,;+-])/i;\n\n    let currentIndex = 0;\n    let openingBrackets = 0;\n    let closingBrackets = 0;\n    let hasJsonFunction = false;\n    let hasInvalidToken = false;\n\n    while (currentIndex < stmt.length) {\n      const string = stmt.substr(currentIndex);\n      const functionMatches = jsonFunctionRegex.exec(string);\n      if (functionMatches) {\n        currentIndex += functionMatches[0].indexOf('(');\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const operatorMatches = jsonOperatorRegex.exec(string);\n      if (operatorMatches) {\n        currentIndex += operatorMatches[0].length;\n        hasJsonFunction = true;\n        continue;\n      }\n\n      const tokenMatches = tokenCaptureRegex.exec(string);\n      if (tokenMatches) {\n        const capturedToken = tokenMatches[1];\n        if (capturedToken === '(') {\n          openingBrackets++;\n        } else if (capturedToken === ')') {\n          closingBrackets++;\n        } else if (capturedToken === ';') {\n          hasInvalidToken = true;\n          break;\n        }\n        currentIndex += tokenMatches[0].length;\n        continue;\n      }\n\n      break;\n    }\n\n    // Check invalid json statement\n    hasInvalidToken |= openingBrackets !== closingBrackets;\n    if (hasJsonFunction && hasInvalidToken) {\n      throw new Error(`Invalid json statement: ${stmt}`);\n    }\n\n    // return true if the statement has valid json function\n    return hasJsonFunction;\n  }\n\n  handleSequelizeMethod(smth, tableName, factory, options, prepend) {\n    if (smth instanceof Utils.Json) {\n      // Parse nested object\n      if (smth.conditions) {\n        const conditions = this.parseConditionObject(smth.conditions).map(condition =>\n          `${this.jsonPathExtractionQuery(condition.path[0], _.tail(condition.path))} = '${condition.value}'`\n        );\n\n        return conditions.join(' AND ');\n      }\n      if (smth.path) {\n        let str;\n\n        // Allow specifying conditions using the postgres json syntax\n        if (this._checkValidJsonStatement(smth.path)) {\n          str = smth.path;\n        } else {\n          // Also support json property accessors\n          const paths = _.toPath(smth.path);\n          const column = paths.shift();\n          str = this.jsonPathExtractionQuery(column, paths);\n        }\n\n        if (smth.value) {\n          str += util.format(' = %s', this.escape(smth.value));\n        }\n\n        return str;\n      }\n    }\n    return super.handleSequelizeMethod.call(this, smth, tableName, factory, options, prepend);\n  }\n\n  addColumnQuery(table, key, dataType) {\n\n    const dbDataType = this.attributeToSQL(dataType, { context: 'addColumn', table, key });\n    const definition = this.dataTypeMapping(table, key, dbDataType);\n    const quotedKey = this.quoteIdentifier(key);\n    const quotedTable = this.quoteTable(this.extractTableDetails(table));\n\n    let query = `ALTER TABLE ${quotedTable} ADD COLUMN ${quotedKey} ${definition};`;\n\n    if (dataType.type && dataType.type instanceof DataTypes.ENUM || dataType instanceof DataTypes.ENUM) {\n      query = this.pgEnum(table, key, dataType) + query;\n    }\n\n    return query;\n  }\n\n  removeColumnQuery(tableName, attributeName) {\n    const quotedTableName = this.quoteTable(this.extractTableDetails(tableName));\n    const quotedAttributeName = this.quoteIdentifier(attributeName);\n    return `ALTER TABLE ${quotedTableName} DROP COLUMN ${quotedAttributeName};`;\n  }\n\n  changeColumnQuery(tableName, attributes) {\n    const query = subQuery => `ALTER TABLE ${this.quoteTable(tableName)} ALTER COLUMN ${subQuery};`;\n    const sql = [];\n    for (const attributeName in attributes) {\n      let definition = this.dataTypeMapping(tableName, attributeName, attributes[attributeName]);\n      let attrSql = '';\n\n      if (definition.includes('NOT NULL')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET NOT NULL`);\n\n        definition = definition.replace('NOT NULL', '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP NOT NULL`);\n      }\n\n      if (definition.includes('DEFAULT')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} SET DEFAULT ${definition.match(/DEFAULT ([^;]+)/)[1]}`);\n\n        definition = definition.replace(/(DEFAULT[^;]+)/, '').trim();\n      } else if (!definition.includes('REFERENCES')) {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} DROP DEFAULT`);\n      }\n\n      if (attributes[attributeName].startsWith('ENUM(')) {\n        attrSql += this.pgEnum(tableName, attributeName, attributes[attributeName]);\n        definition = definition.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attributeName, { schema: false }));\n        definition += ` USING (${this.quoteIdentifier(attributeName)}::${this.pgEnumName(tableName, attributeName)})`;\n      }\n\n      if (definition.match(/UNIQUE;*$/)) {\n        definition = definition.replace(/UNIQUE;*$/, '');\n        attrSql += query(`ADD UNIQUE (${this.quoteIdentifier(attributeName)})`).replace('ALTER COLUMN', '');\n      }\n\n      if (definition.includes('REFERENCES')) {\n        definition = definition.replace(/.+?(?=REFERENCES)/, '');\n        attrSql += query(`ADD FOREIGN KEY (${this.quoteIdentifier(attributeName)}) ${definition}`).replace('ALTER COLUMN', '');\n      } else {\n        attrSql += query(`${this.quoteIdentifier(attributeName)} TYPE ${definition}`);\n      }\n\n      sql.push(attrSql);\n    }\n\n    return sql.join('');\n  }\n\n  renameColumnQuery(tableName, attrBefore, attributes) {\n\n    const attrString = [];\n\n    for (const attributeName in attributes) {\n      attrString.push(`${this.quoteIdentifier(attrBefore)} TO ${this.quoteIdentifier(attributeName)}`);\n    }\n\n    return `ALTER TABLE ${this.quoteTable(tableName)} RENAME COLUMN ${attrString.join(', ')};`;\n  }\n\n  fn(fnName, tableName, parameters, body, returns, language) {\n    fnName = fnName || 'testfunc';\n    language = language || 'plpgsql';\n    returns = returns ? `RETURNS ${returns}` : '';\n    parameters = parameters || '';\n\n    return `CREATE OR REPLACE FUNCTION pg_temp.${fnName}(${parameters}) ${returns} AS $func$ BEGIN ${body} END; $func$ LANGUAGE ${language}; SELECT * FROM pg_temp.${fnName}();`;\n  }\n\n  exceptionFn(fnName, tableName, parameters, main, then, when, returns, language) {\n    when = when || 'unique_violation';\n\n    const body = `${main} EXCEPTION WHEN ${when} THEN ${then};`;\n\n    return this.fn(fnName, tableName, parameters, body, returns, language);\n  }\n\n  upsertQuery(tableName, insertValues, updateValues, where, model, options) {\n    const primaryField = this.quoteIdentifier(model.primaryKeyField);\n\n    const upsertOptions = _.defaults({ bindParam: false }, options);\n    const insert = this.insertQuery(tableName, insertValues, model.rawAttributes, upsertOptions);\n    const update = this.updateQuery(tableName, updateValues, where, upsertOptions, model.rawAttributes);\n\n    if (options.returning) {\n      const returningRegex = /RETURNING \\*(?![\\s\\S]*RETURNING \\*)/;\n\n      insert.query = insert.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n      update.query = update.query.replace(returningRegex, `RETURNING ${primaryField} INTO primary_key`);\n    }\n\n    return this.exceptionFn(\n      'sequelize_upsert',\n      tableName,\n      'OUT created boolean, OUT primary_key text',\n      `${insert.query} created := true;`,\n      `${update.query}; created := false`\n    );\n  }\n\n  truncateTableQuery(tableName, options = {}) {\n    return [\n      `TRUNCATE ${this.quoteTable(tableName)}`,\n      options.restartIdentity ? ' RESTART IDENTITY' : '',\n      options.cascade ? ' CASCADE' : ''\n    ].join('');\n  }\n\n  deleteQuery(tableName, where, options = {}, model) {\n    const table = this.quoteTable(tableName);\n    let whereClause = this.getWhereConditions(where, null, model, options);\n    const limit = options.limit ? ` LIMIT ${this.escape(options.limit)}` : '';\n    let primaryKeys = '';\n    let primaryKeysSelection = '';\n\n    if (whereClause) {\n      whereClause = ` WHERE ${whereClause}`;\n    }\n\n    if (options.limit) {\n      if (!model) {\n        throw new Error('Cannot LIMIT delete without a model.');\n      }\n\n      const pks = _.values(model.primaryKeys).map(pk => this.quoteIdentifier(pk.field)).join(',');\n\n      primaryKeys = model.primaryKeyAttributes.length > 1 ? `(${pks})` : pks;\n      primaryKeysSelection = pks;\n\n      return `DELETE FROM ${table} WHERE ${primaryKeys} IN (SELECT ${primaryKeysSelection} FROM ${table}${whereClause}${limit})`;\n    }\n    return `DELETE FROM ${table}${whereClause}`;\n  }\n\n  showIndexesQuery(tableName) {\n    let schemaJoin = '';\n    let schemaWhere = '';\n    if (typeof tableName !== 'string') {\n      schemaJoin = ', pg_namespace s';\n      schemaWhere = ` AND s.oid = t.relnamespace AND s.nspname = '${tableName.schema}'`;\n      tableName = tableName.tableName;\n    }\n\n    // This is ARCANE!\n    return 'SELECT i.relname AS name, ix.indisprimary AS primary, ix.indisunique AS unique, ix.indkey AS indkey, ' +\n      'array_agg(a.attnum) as column_indexes, array_agg(a.attname) AS column_names, pg_get_indexdef(ix.indexrelid) ' +\n      `AS definition FROM pg_class t, pg_class i, pg_index ix, pg_attribute a${schemaJoin} ` +\n      'WHERE t.oid = ix.indrelid AND i.oid = ix.indexrelid AND a.attrelid = t.oid AND ' +\n      `t.relkind = 'r' and t.relname = '${tableName}'${schemaWhere} ` +\n      'GROUP BY i.relname, ix.indexrelid, ix.indisprimary, ix.indisunique, ix.indkey ORDER BY i.relname;';\n  }\n\n  showConstraintsQuery(tableName) {\n    //Postgres converts camelCased alias to lowercase unless quoted\n    return [\n      'SELECT constraint_catalog AS \"constraintCatalog\",',\n      'constraint_schema AS \"constraintSchema\",',\n      'constraint_name AS \"constraintName\",',\n      'table_catalog AS \"tableCatalog\",',\n      'table_schema AS \"tableSchema\",',\n      'table_name AS \"tableName\",',\n      'constraint_type AS \"constraintType\",',\n      'is_deferrable AS \"isDeferrable\",',\n      'initially_deferred AS \"initiallyDeferred\"',\n      'from INFORMATION_SCHEMA.table_constraints',\n      `WHERE table_name='${tableName}';`\n    ].join(' ');\n  }\n\n  removeIndexQuery(tableName, indexNameOrAttributes) {\n    let indexName = indexNameOrAttributes;\n\n    if (typeof indexName !== 'string') {\n      indexName = Utils.underscore(`${tableName}_${indexNameOrAttributes.join('_')}`);\n    }\n\n    return `DROP INDEX IF EXISTS ${this.quoteIdentifiers(indexName)}`;\n  }\n\n  addLimitAndOffset(options) {\n    let fragment = '';\n    /* eslint-disable */\n    if (options.limit != null) {\n      fragment += ' LIMIT ' + this.escape(options.limit);\n    }\n    if (options.offset != null) {\n      fragment += ' OFFSET ' + this.escape(options.offset);\n    }\n    /* eslint-enable */\n\n    return fragment;\n  }\n\n  attributeToSQL(attribute, options) {\n    if (!_.isPlainObject(attribute)) {\n      attribute = {\n        type: attribute\n      };\n    }\n\n    let type;\n    if (\n      attribute.type instanceof DataTypes.ENUM ||\n      attribute.type instanceof DataTypes.ARRAY && attribute.type.type instanceof DataTypes.ENUM\n    ) {\n      const enumType = attribute.type.type || attribute.type;\n      let values = attribute.values;\n\n      if (enumType.values && !attribute.values) {\n        values = enumType.values;\n      }\n\n      if (Array.isArray(values) && values.length > 0) {\n        type = `ENUM(${values.map(value => this.escape(value)).join(', ')})`;\n\n        if (attribute.type instanceof DataTypes.ARRAY) {\n          type += '[]';\n        }\n\n      } else {\n        throw new Error(\"Values for ENUM haven't been defined.\");\n      }\n    }\n\n    if (!type) {\n      type = attribute.type;\n    }\n\n    let sql = type.toString();\n\n    if (Object.prototype.hasOwnProperty.call(attribute, 'allowNull') && !attribute.allowNull) {\n      sql += ' NOT NULL';\n    }\n\n    if (attribute.autoIncrement) {\n      if (attribute.autoIncrementIdentity) {\n        sql += ' GENERATED BY DEFAULT AS IDENTITY';\n      } else {\n        sql += ' SERIAL';\n      }\n    }\n\n    if (Utils.defaultValueSchemable(attribute.defaultValue)) {\n      sql += ` DEFAULT ${this.escape(attribute.defaultValue, attribute)}`;\n    }\n\n    if (attribute.unique === true) {\n      sql += ' UNIQUE';\n    }\n\n    if (attribute.primaryKey) {\n      sql += ' PRIMARY KEY';\n    }\n\n    if (attribute.references) {\n      let referencesTable = this.quoteTable(attribute.references.model);\n      let schema;\n\n      if (options.schema) {\n        schema = options.schema;\n      } else if (\n        (!attribute.references.model || typeof attribute.references.model == 'string')\n        && options.table\n        && options.table.schema\n      ) {\n        schema = options.table.schema;\n      }\n\n      if (schema) {\n        referencesTable = this.quoteTable(this.addSchema({\n          tableName: referencesTable,\n          _schema: schema\n        }));\n      }\n\n      let referencesKey;\n\n      if (attribute.references.key) {\n        referencesKey = this.quoteIdentifiers(attribute.references.key);\n      } else {\n        referencesKey = this.quoteIdentifier('id');\n      }\n\n      sql += ` REFERENCES ${referencesTable} (${referencesKey})`;\n\n      if (attribute.onDelete) {\n        sql += ` ON DELETE ${attribute.onDelete.toUpperCase()}`;\n      }\n\n      if (attribute.onUpdate) {\n        sql += ` ON UPDATE ${attribute.onUpdate.toUpperCase()}`;\n      }\n\n      if (attribute.references.deferrable) {\n        sql += ` ${attribute.references.deferrable.toString(this)}`;\n      }\n    }\n\n    if (attribute.comment && typeof attribute.comment === 'string') {\n      if (options && (options.context === 'addColumn' || options.context === 'changeColumn')) {\n        const quotedAttr = this.quoteIdentifier(options.key);\n        const escapedCommentText = this.escape(attribute.comment);\n        sql += `; COMMENT ON COLUMN ${this.quoteTable(options.table)}.${quotedAttr} IS ${escapedCommentText}`;\n      } else {\n        // for createTable event which does it's own parsing\n        // TODO: centralize creation of comment statements here\n        sql += ` COMMENT ${attribute.comment}`;\n      }\n    }\n\n    return sql;\n  }\n\n  deferConstraintsQuery(options) {\n    return options.deferrable.toString(this);\n  }\n\n  setConstraintQuery(columns, type) {\n    let columnFragment = 'ALL';\n\n    if (columns) {\n      columnFragment = columns.map(column => this.quoteIdentifier(column)).join(', ');\n    }\n\n    return `SET CONSTRAINTS ${columnFragment} ${type}`;\n  }\n\n  setDeferredQuery(columns) {\n    return this.setConstraintQuery(columns, 'DEFERRED');\n  }\n\n  setImmediateQuery(columns) {\n    return this.setConstraintQuery(columns, 'IMMEDIATE');\n  }\n\n  attributesToSQL(attributes, options) {\n    const result = {};\n\n    for (const key in attributes) {\n      const attribute = attributes[key];\n      result[attribute.field || key] = this.attributeToSQL(attribute, Object.assign({ key }, options || {}));\n    }\n\n    return result;\n  }\n\n  createTrigger(tableName, triggerName, eventType, fireOnSpec, functionName, functionParams, optionsArray) {\n    const decodedEventType = this.decodeTriggerEventType(eventType);\n    const eventSpec = this.expandTriggerEventSpec(fireOnSpec);\n    const expandedOptions = this.expandOptions(optionsArray);\n    const paramList = this.expandFunctionParamList(functionParams);\n\n    return `CREATE ${this.triggerEventTypeIsConstraint(eventType)}TRIGGER ${this.quoteIdentifier(triggerName)} ${decodedEventType} ${\n      eventSpec} ON ${this.quoteTable(tableName)}${expandedOptions ? ` ${expandedOptions}` : ''} EXECUTE PROCEDURE ${functionName}(${paramList});`;\n  }\n\n  dropTrigger(tableName, triggerName) {\n    return `DROP TRIGGER ${this.quoteIdentifier(triggerName)} ON ${this.quoteTable(tableName)} RESTRICT;`;\n  }\n\n  renameTrigger(tableName, oldTriggerName, newTriggerName) {\n    return `ALTER TRIGGER ${this.quoteIdentifier(oldTriggerName)} ON ${this.quoteTable(tableName)} RENAME TO ${this.quoteIdentifier(newTriggerName)};`;\n  }\n\n  createFunction(functionName, params, returnType, language, body, optionsArray, options) {\n    if (!functionName || !returnType || !language || !body) throw new Error('createFunction missing some parameters. Did you pass functionName, returnType, language and body?');\n\n    const paramList = this.expandFunctionParamList(params);\n    const variableList = options && options.variables ? this.expandFunctionVariableList(options.variables) : '';\n    const expandedOptionsArray = this.expandOptions(optionsArray);\n\n    const statement = options && options.force ? 'CREATE OR REPLACE FUNCTION' : 'CREATE FUNCTION';\n\n    return `${statement} ${functionName}(${paramList}) RETURNS ${returnType} AS $func$ ${variableList} BEGIN ${body} END; $func$ language '${language}'${expandedOptionsArray};`;\n  }\n\n  dropFunction(functionName, params) {\n    if (!functionName) throw new Error('requires functionName');\n    // RESTRICT is (currently, as of 9.2) default but we'll be explicit\n    const paramList = this.expandFunctionParamList(params);\n    return `DROP FUNCTION ${functionName}(${paramList}) RESTRICT;`;\n  }\n\n  renameFunction(oldFunctionName, params, newFunctionName) {\n    const paramList = this.expandFunctionParamList(params);\n    return `ALTER FUNCTION ${oldFunctionName}(${paramList}) RENAME TO ${newFunctionName};`;\n  }\n\n  databaseConnectionUri(config) {\n    let uri = `${config.protocol}://${config.user}:${config.password}@${config.host}`;\n    if (config.port) {\n      uri += `:${config.port}`;\n    }\n    uri += `/${config.database}`;\n    if (config.ssl) {\n      uri += `?ssl=${config.ssl}`;\n    }\n    return uri;\n  }\n\n  pgEscapeAndQuote(val) {\n    return this.quoteIdentifier(Utils.removeTicks(this.escape(val), \"'\"));\n  }\n\n  expandFunctionParamList(params) {\n    if (params === undefined || !Array.isArray(params)) {\n      throw new Error('expandFunctionParamList: function parameters array required, including an empty one for no arguments');\n    }\n\n    const paramList = [];\n    params.forEach(curParam => {\n      const paramDef = [];\n      if (curParam.type) {\n        if (curParam.direction) { paramDef.push(curParam.direction); }\n        if (curParam.name) { paramDef.push(curParam.name); }\n        paramDef.push(curParam.type);\n      } else {\n        throw new Error('function or trigger used with a parameter without any type');\n      }\n\n      const joined = paramDef.join(' ');\n      if (joined) paramList.push(joined);\n\n    });\n\n    return paramList.join(', ');\n  }\n\n  expandFunctionVariableList(variables) {\n    if (!Array.isArray(variables)) {\n      throw new Error('expandFunctionVariableList: function variables must be an array');\n    }\n    const variableDefinitions = [];\n    variables.forEach(variable => {\n      if (!variable.name || !variable.type) {\n        throw new Error('function variable must have a name and type');\n      }\n      let variableDefinition = `DECLARE ${variable.name} ${variable.type}`;\n      if (variable.default) {\n        variableDefinition += ` := ${variable.default}`;\n      }\n      variableDefinition += ';';\n      variableDefinitions.push(variableDefinition);\n    });\n    return variableDefinitions.join(' ');\n  }\n\n  expandOptions(options) {\n    return options === undefined || _.isEmpty(options) ?\n      '' : options.join(' ');\n  }\n\n  decodeTriggerEventType(eventSpecifier) {\n    const EVENT_DECODER = {\n      'after': 'AFTER',\n      'before': 'BEFORE',\n      'instead_of': 'INSTEAD OF',\n      'after_constraint': 'AFTER'\n    };\n\n    if (!EVENT_DECODER[eventSpecifier]) {\n      throw new Error(`Invalid trigger event specified: ${eventSpecifier}`);\n    }\n\n    return EVENT_DECODER[eventSpecifier];\n  }\n\n  triggerEventTypeIsConstraint(eventSpecifier) {\n    return eventSpecifier === 'after_constraint' ? 'CONSTRAINT ' : '';\n  }\n\n  expandTriggerEventSpec(fireOnSpec) {\n    if (_.isEmpty(fireOnSpec)) {\n      throw new Error('no table change events specified to trigger on');\n    }\n\n    return _.map(fireOnSpec, (fireValue, fireKey) => {\n      const EVENT_MAP = {\n        'insert': 'INSERT',\n        'update': 'UPDATE',\n        'delete': 'DELETE',\n        'truncate': 'TRUNCATE'\n      };\n\n      if (!EVENT_MAP[fireValue]) {\n        throw new Error(`parseTriggerEventSpec: undefined trigger event ${fireKey}`);\n      }\n\n      let eventSpec = EVENT_MAP[fireValue];\n      if (eventSpec === 'UPDATE') {\n        if (Array.isArray(fireValue) && fireValue.length > 0) {\n          eventSpec += ` OF ${fireValue.join(', ')}`;\n        }\n      }\n\n      return eventSpec;\n    }).join(' OR ');\n  }\n\n  pgEnumName(tableName, attr, options) {\n    options = options || {};\n\n    const tableDetails = this.extractTableDetails(tableName, options);\n    let enumName = Utils.addTicks(Utils.generateEnumName(tableDetails.tableName, attr), '\"');\n\n    // pgListEnums requires the enum name only, without the schema\n    if (options.schema !== false && tableDetails.schema) {\n      enumName = this.quoteIdentifier(tableDetails.schema) + tableDetails.delimiter + enumName;\n    }\n\n    return enumName;\n  }\n\n  pgListEnums(tableName, attrName, options) {\n    let enumName = '';\n    const tableDetails = this.extractTableDetails(tableName, options);\n\n    if (tableDetails.tableName && attrName) {\n      enumName = ` AND t.typname=${this.pgEnumName(tableDetails.tableName, attrName, { schema: false }).replace(/\"/g, \"'\")}`;\n    }\n\n    return 'SELECT t.typname enum_name, array_agg(e.enumlabel ORDER BY enumsortorder) enum_value FROM pg_type t ' +\n      'JOIN pg_enum e ON t.oid = e.enumtypid ' +\n      'JOIN pg_catalog.pg_namespace n ON n.oid = t.typnamespace ' +\n      `WHERE n.nspname = '${tableDetails.schema}'${enumName} GROUP BY 1`;\n  }\n\n  pgEnum(tableName, attr, dataType, options) {\n    const enumName = this.pgEnumName(tableName, attr, options);\n    let values;\n\n    if (dataType.values) {\n      values = `ENUM(${dataType.values.map(value => this.escape(value)).join(', ')})`;\n    } else {\n      values = dataType.toString().match(/^ENUM\\(.+\\)/)[0];\n    }\n\n    let sql = `CREATE TYPE ${enumName} AS ${values};`;\n    if (!!options && options.force === true) {\n      sql = this.pgEnumDrop(tableName, attr) + sql;\n    }\n    return sql;\n  }\n\n  pgEnumAdd(tableName, attr, value, options) {\n    const enumName = this.pgEnumName(tableName, attr);\n    let sql = `ALTER TYPE ${enumName} ADD VALUE `;\n\n    if (semver.gte(this.sequelize.options.databaseVersion, '9.3.0')) {\n      sql += 'IF NOT EXISTS ';\n    }\n    sql += this.escape(value);\n\n    if (options.before) {\n      sql += ` BEFORE ${this.escape(options.before)}`;\n    } else if (options.after) {\n      sql += ` AFTER ${this.escape(options.after)}`;\n    }\n\n    return sql;\n  }\n\n  pgEnumDrop(tableName, attr, enumName) {\n    enumName = enumName || this.pgEnumName(tableName, attr);\n    return `DROP TYPE IF EXISTS ${enumName}; `;\n  }\n\n  fromArray(text) {\n    text = text.replace(/^{/, '').replace(/}$/, '');\n    let matches = text.match(/(\"(?:\\\\.|[^\"\\\\\\\\])*\"|[^,]*)(?:\\s*,\\s*|\\s*$)/ig);\n\n    if (matches.length < 1) {\n      return [];\n    }\n\n    matches = matches.map(m => m.replace(/\",$/, '').replace(/,$/, '').replace(/(^\"|\"$)/g, ''));\n\n    return matches.slice(0, -1);\n  }\n\n  padInt(i) {\n    return i < 10 ? `0${i.toString()}` : i.toString();\n  }\n\n  dataTypeMapping(tableName, attr, dataType) {\n    if (dataType.includes('PRIMARY KEY')) {\n      dataType = dataType.replace('PRIMARY KEY', '');\n    }\n\n    if (dataType.includes('SERIAL')) {\n      if (dataType.includes('BIGINT')) {\n        dataType = dataType.replace('SERIAL', 'BIGSERIAL');\n        dataType = dataType.replace('BIGINT', '');\n      } else if (dataType.includes('SMALLINT')) {\n        dataType = dataType.replace('SERIAL', 'SMALLSERIAL');\n        dataType = dataType.replace('SMALLINT', '');\n      } else {\n        dataType = dataType.replace('INTEGER', '');\n      }\n      dataType = dataType.replace('NOT NULL', '');\n    }\n\n    if (dataType.startsWith('ENUM(')) {\n      dataType = dataType.replace(/^ENUM\\(.+\\)/, this.pgEnumName(tableName, attr));\n    }\n\n    return dataType;\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys of a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  getForeignKeysQuery(tableName) {\n    return 'SELECT conname as constraint_name, pg_catalog.pg_get_constraintdef(r.oid, true) as condef FROM pg_catalog.pg_constraint r ' +\n      `WHERE r.conrelid = (SELECT oid FROM pg_class WHERE relname = '${tableName}' LIMIT 1) AND r.contype = 'f' ORDER BY 1;`;\n  }\n\n  /**\n   * Generate common SQL prefix for getForeignKeyReferencesQuery.\n   *\n   * @returns {string}\n   */\n  _getForeignKeyReferencesQueryPrefix() {\n    return 'SELECT ' +\n      'DISTINCT tc.constraint_name as constraint_name, ' +\n      'tc.constraint_schema as constraint_schema, ' +\n      'tc.constraint_catalog as constraint_catalog, ' +\n      'tc.table_name as table_name,' +\n      'tc.table_schema as table_schema,' +\n      'tc.table_catalog as table_catalog,' +\n      'kcu.column_name as column_name,' +\n      'ccu.table_schema  AS referenced_table_schema,' +\n      'ccu.table_catalog  AS referenced_table_catalog,' +\n      'ccu.table_name  AS referenced_table_name,' +\n      'ccu.column_name AS referenced_column_name ' +\n      'FROM information_schema.table_constraints AS tc ' +\n      'JOIN information_schema.key_column_usage AS kcu ' +\n      'ON tc.constraint_name = kcu.constraint_name ' +\n      'JOIN information_schema.constraint_column_usage AS ccu ' +\n      'ON ccu.constraint_name = tc.constraint_name ';\n  }\n\n  /**\n   * Generates an SQL query that returns all foreign keys details of a table.\n   *\n   * As for getForeignKeysQuery is not compatible with getForeignKeyReferencesQuery, so add a new function.\n   *\n   * @param {string} tableName\n   * @param {string} catalogName\n   * @param {string} schemaName\n   */\n  getForeignKeyReferencesQuery(tableName, catalogName, schemaName) {\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name = '${tableName}'${\n      catalogName ? ` AND tc.table_catalog = '${catalogName}'` : ''\n    }${schemaName ? ` AND tc.table_schema = '${schemaName}'` : ''}`;\n  }\n\n  getForeignKeyReferenceQuery(table, columnName) {\n    const tableName = table.tableName || table;\n    const schema = table.schema;\n    return `${this._getForeignKeyReferencesQueryPrefix()\n    }WHERE constraint_type = 'FOREIGN KEY' AND tc.table_name='${tableName}' AND  kcu.column_name = '${columnName}'${\n      schema ? ` AND tc.table_schema = '${schema}'` : ''}`;\n  }\n\n  /**\n   * Generates an SQL query that removes a foreign key from a table.\n   *\n   * @param  {string} tableName  The name of the table.\n   * @param  {string} foreignKey The name of the foreign key constraint.\n   * @returns {string}            The generated sql query.\n   * @private\n   */\n  dropForeignKeyQuery(tableName, foreignKey) {\n    return `ALTER TABLE ${this.quoteTable(tableName)} DROP CONSTRAINT ${this.quoteIdentifier(foreignKey)};`;\n  }\n}\n\nmodule.exports = PostgresQueryGenerator;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}