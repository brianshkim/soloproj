{"ast":null,"code":"'use strict';\n\nvar net = require('net');\n\nvar EventEmitter = require('events').EventEmitter;\n\nconst {\n  parse,\n  serialize\n} = require('pg-protocol');\n\nconst flushBuffer = serialize.flush();\nconst syncBuffer = serialize.sync();\nconst endBuffer = serialize.end(); // TODO(bmc) support binary mode at some point\n\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super();\n    config = config || {};\n    this.stream = config.stream || new net.Socket();\n    this._keepAlive = config.keepAlive;\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis;\n    this.lastBuffer = false;\n    this.parsedStatements = {};\n    this.ssl = config.ssl || false;\n    this._ending = false;\n    this._emitMessage = false;\n    var self = this;\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true;\n      }\n    });\n  }\n\n  connect(port, host) {\n    var self = this;\n    this._connecting = true;\n    this.stream.setNoDelay(true);\n    this.stream.connect(port, host);\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis);\n      }\n\n      self.emit('connect');\n    });\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return;\n      }\n\n      self.emit('error', error);\n    };\n\n    this.stream.on('error', reportStreamError);\n    this.stream.on('close', function () {\n      self.emit('end');\n    });\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream);\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8');\n\n      switch (responseCode) {\n        case 'S':\n          // Server supports SSL connections, continue with a secure connection\n          break;\n\n        case 'N':\n          // Server does not support SSL connections\n          self.stream.end();\n          return self.emit('error', new Error('The server does not support SSL connections'));\n\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end();\n          return self.emit('error', new Error('There was an error establishing an SSL connection'));\n      }\n\n      var tls = require('tls');\n\n      const options = {\n        socket: self.stream\n      };\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl);\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key;\n        }\n      }\n\n      if (net.isIP(host) === 0) {\n        options.servername = host;\n      }\n\n      try {\n        self.stream = tls.connect(options);\n      } catch (err) {\n        return self.emit('error', err);\n      }\n\n      self.attachListeners(self.stream);\n      self.stream.on('error', reportStreamError);\n      self.emit('sslconnect');\n    });\n  }\n\n  attachListeners(stream) {\n    stream.on('end', () => {\n      this.emit('end');\n    });\n    parse(stream, msg => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name;\n\n      if (this._emitMessage) {\n        this.emit('message', msg);\n      }\n\n      this.emit(eventName, msg);\n    });\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl());\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config));\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey));\n  }\n\n  password(password) {\n    this._send(serialize.password(password));\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse));\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData));\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false;\n    }\n\n    return this.stream.write(buffer);\n  }\n\n  query(text) {\n    this._send(serialize.query(text));\n  } // send parse message\n\n\n  parse(query) {\n    this._send(serialize.parse(query));\n  } // send bind message\n\n\n  bind(config) {\n    this._send(serialize.bind(config));\n  } // send execute message\n\n\n  execute(config) {\n    this._send(serialize.execute(config));\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer);\n    }\n  }\n\n  sync() {\n    this._ending = true;\n\n    this._send(flushBuffer);\n\n    this._send(syncBuffer);\n  }\n\n  ref() {\n    this.stream.ref();\n  }\n\n  unref() {\n    this.stream.unref();\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true;\n\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end();\n      return;\n    }\n\n    return this.stream.write(endBuffer, () => {\n      this.stream.end();\n    });\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg));\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg));\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk));\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone());\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg));\n  }\n\n}\n\nmodule.exports = Connection;","map":{"version":3,"names":["net","require","EventEmitter","parse","serialize","flushBuffer","flush","syncBuffer","sync","endBuffer","end","Connection","constructor","config","stream","Socket","_keepAlive","keepAlive","_keepAliveInitialDelayMillis","keepAliveInitialDelayMillis","lastBuffer","parsedStatements","ssl","_ending","_emitMessage","self","on","eventName","connect","port","host","_connecting","setNoDelay","once","setKeepAlive","emit","reportStreamError","error","code","attachListeners","buffer","responseCode","toString","Error","tls","options","socket","Object","assign","key","isIP","servername","err","msg","name","requestSsl","write","startup","cancel","processID","secretKey","_send","password","sendSASLInitialResponseMessage","mechanism","initialResponse","sendSCRAMClientFinalMessage","additionalData","writable","query","text","bind","execute","ref","unref","close","describe","sendCopyFromChunk","chunk","copyData","endCopyFrom","copyDone","sendCopyFail","copyFail","module","exports"],"sources":["/home/brian/node_modules/pg/lib/connection.js"],"sourcesContent":["'use strict'\n\nvar net = require('net')\nvar EventEmitter = require('events').EventEmitter\n\nconst { parse, serialize } = require('pg-protocol')\n\nconst flushBuffer = serialize.flush()\nconst syncBuffer = serialize.sync()\nconst endBuffer = serialize.end()\n\n// TODO(bmc) support binary mode at some point\nclass Connection extends EventEmitter {\n  constructor(config) {\n    super()\n    config = config || {}\n    this.stream = config.stream || new net.Socket()\n    this._keepAlive = config.keepAlive\n    this._keepAliveInitialDelayMillis = config.keepAliveInitialDelayMillis\n    this.lastBuffer = false\n    this.parsedStatements = {}\n    this.ssl = config.ssl || false\n    this._ending = false\n    this._emitMessage = false\n    var self = this\n    this.on('newListener', function (eventName) {\n      if (eventName === 'message') {\n        self._emitMessage = true\n      }\n    })\n  }\n\n  connect(port, host) {\n    var self = this\n\n    this._connecting = true\n    this.stream.setNoDelay(true)\n    this.stream.connect(port, host)\n\n    this.stream.once('connect', function () {\n      if (self._keepAlive) {\n        self.stream.setKeepAlive(true, self._keepAliveInitialDelayMillis)\n      }\n      self.emit('connect')\n    })\n\n    const reportStreamError = function (error) {\n      // errors about disconnections should be ignored during disconnect\n      if (self._ending && (error.code === 'ECONNRESET' || error.code === 'EPIPE')) {\n        return\n      }\n      self.emit('error', error)\n    }\n    this.stream.on('error', reportStreamError)\n\n    this.stream.on('close', function () {\n      self.emit('end')\n    })\n\n    if (!this.ssl) {\n      return this.attachListeners(this.stream)\n    }\n\n    this.stream.once('data', function (buffer) {\n      var responseCode = buffer.toString('utf8')\n      switch (responseCode) {\n        case 'S': // Server supports SSL connections, continue with a secure connection\n          break\n        case 'N': // Server does not support SSL connections\n          self.stream.end()\n          return self.emit('error', new Error('The server does not support SSL connections'))\n        default:\n          // Any other response byte, including 'E' (ErrorResponse) indicating a server error\n          self.stream.end()\n          return self.emit('error', new Error('There was an error establishing an SSL connection'))\n      }\n      var tls = require('tls')\n      const options = {\n        socket: self.stream,\n      }\n\n      if (self.ssl !== true) {\n        Object.assign(options, self.ssl)\n\n        if ('key' in self.ssl) {\n          options.key = self.ssl.key\n        }\n      }\n\n      if (net.isIP(host) === 0) {\n        options.servername = host\n      }\n      try {\n        self.stream = tls.connect(options)\n      } catch (err) {\n        return self.emit('error', err)\n      }\n      self.attachListeners(self.stream)\n      self.stream.on('error', reportStreamError)\n\n      self.emit('sslconnect')\n    })\n  }\n\n  attachListeners(stream) {\n    stream.on('end', () => {\n      this.emit('end')\n    })\n    parse(stream, (msg) => {\n      var eventName = msg.name === 'error' ? 'errorMessage' : msg.name\n      if (this._emitMessage) {\n        this.emit('message', msg)\n      }\n      this.emit(eventName, msg)\n    })\n  }\n\n  requestSsl() {\n    this.stream.write(serialize.requestSsl())\n  }\n\n  startup(config) {\n    this.stream.write(serialize.startup(config))\n  }\n\n  cancel(processID, secretKey) {\n    this._send(serialize.cancel(processID, secretKey))\n  }\n\n  password(password) {\n    this._send(serialize.password(password))\n  }\n\n  sendSASLInitialResponseMessage(mechanism, initialResponse) {\n    this._send(serialize.sendSASLInitialResponseMessage(mechanism, initialResponse))\n  }\n\n  sendSCRAMClientFinalMessage(additionalData) {\n    this._send(serialize.sendSCRAMClientFinalMessage(additionalData))\n  }\n\n  _send(buffer) {\n    if (!this.stream.writable) {\n      return false\n    }\n    return this.stream.write(buffer)\n  }\n\n  query(text) {\n    this._send(serialize.query(text))\n  }\n\n  // send parse message\n  parse(query) {\n    this._send(serialize.parse(query))\n  }\n\n  // send bind message\n  bind(config) {\n    this._send(serialize.bind(config))\n  }\n\n  // send execute message\n  execute(config) {\n    this._send(serialize.execute(config))\n  }\n\n  flush() {\n    if (this.stream.writable) {\n      this.stream.write(flushBuffer)\n    }\n  }\n\n  sync() {\n    this._ending = true\n    this._send(flushBuffer)\n    this._send(syncBuffer)\n  }\n\n  ref() {\n    this.stream.ref()\n  }\n\n  unref() {\n    this.stream.unref()\n  }\n\n  end() {\n    // 0x58 = 'X'\n    this._ending = true\n    if (!this._connecting || !this.stream.writable) {\n      this.stream.end()\n      return\n    }\n    return this.stream.write(endBuffer, () => {\n      this.stream.end()\n    })\n  }\n\n  close(msg) {\n    this._send(serialize.close(msg))\n  }\n\n  describe(msg) {\n    this._send(serialize.describe(msg))\n  }\n\n  sendCopyFromChunk(chunk) {\n    this._send(serialize.copyData(chunk))\n  }\n\n  endCopyFrom() {\n    this._send(serialize.copyDone())\n  }\n\n  sendCopyFail(msg) {\n    this._send(serialize.copyFail(msg))\n  }\n}\n\nmodule.exports = Connection\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}