{"ast":null,"code":"'use strict';\n\nconst {\n  Pool,\n  TimeoutError\n} = require('sequelize-pool');\n\nconst _ = require('lodash');\n\nconst semver = require('semver');\n\nconst Promise = require('../../promise');\n\nconst errors = require('../../errors');\n\nconst {\n  logger\n} = require('../../utils/logger');\n\nconst debug = logger.debugContext('pool');\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\n\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n\n\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      } // This is needed so that bundlers (like webpack) know which library to include in the bundle\n\n\n      switch (moduleName) {\n        case 'pg':\n          return require('pg');\n\n        case 'mysql2':\n          return require('mysql2');\n\n        case 'mariadb':\n          return require('mariadb');\n\n        case 'sqlite3':\n          return require('sqlite3');\n\n        case 'tedious':\n          return require('tedious');\n\n        default:\n          return require(moduleName);\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n\n\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n\n\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection).tap(() => {\n            debug('connection destroy');\n          });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    } // Map main connection config\n\n\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication')); // Apply defaults to each read config\n\n    config.replication.read = config.replication.read.map(readConfig => _.defaults(readConfig, _.omit(this.config, 'replication'))); // custom pooling for replication (original author @janmeier)\n\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(this.pool.read.destroyAllNow(), this.pool.write.destroyAllNow()).tap(() => {\n          debug('all connections destroyed');\n        });\n      },\n      drain: () => {\n        return Promise.join(this.pool.write.drain(), this.pool.read.drain());\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n\n\n  getConnection(options) {\n    options = options || {};\n    let promise;\n\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config).then(connection => {\n          const _options = {};\n          _options.transaction = {\n            connection\n          }; // Cheat .query to use our private connection\n\n          _options.logging = () => {};\n\n          _options.logging.__testLoggingFn = true; //connection might have set databaseVersion value at initialization,\n          //avoiding a useless round trip\n\n          if (this.sequelize.options.databaseVersion === 0) {\n            return this.sequelize.databaseVersion(_options).then(version => {\n              const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n              this.sequelize.options.databaseVersion = semver.valid(parsedVersion) ? parsedVersion : this.defaultVersion;\n              this.versionPromise = null;\n              return this._disconnect(connection);\n            });\n          }\n\n          this.versionPromise = null;\n          return this._disconnect(connection);\n        }).catch(err => {\n          this.versionPromise = null;\n          throw err;\n        });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster).catch(error => {\n        if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n        throw error;\n      });\n    }).tap(() => {\n      debug('connection acquired');\n    });\n  }\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n\n\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n\n\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config).then(() => this.dialect.connectionManager.connect(config)).then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n\n\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection).then(() => this.dialect.connectionManager.disconnect(connection)).then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n\n\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;","map":{"version":3,"names":["Pool","TimeoutError","require","_","semver","Promise","errors","logger","debug","debugContext","ConnectionManager","constructor","dialect","sequelize","config","cloneDeep","versionPromise","dialectName","options","pool","Error","defaults","max","min","idle","acquire","evict","validate","_validate","bind","initPools","refreshTypeParser","dataTypes","each","dataType","Object","prototype","hasOwnProperty","call","types","_refreshTypeParser","key","_loadDialectModule","moduleName","dialectModulePath","dialectModule","err","code","_onProcessExit","resolve","drain","then","destroyAllNow","close","getConnection","reject","replication","name","create","_connect","destroy","connection","_disconnect","tap","acquireTimeoutMillis","idleTimeoutMillis","reapIntervalMillis","Array","isArray","read","write","omit","map","readConfig","reads","release","client","queryType","useMaster","undefined","join","nextRead","length","promise","databaseVersion","_options","transaction","logging","__testLoggingFn","version","parsedVersion","get","coerce","valid","defaultVersion","catch","type","error","ConnectionAcquireTimeoutError","releaseConnection","try","runHooks","connectionManager","connect","return","disconnect","module","exports","default"],"sources":["/home/brian/node_modules/sequelize/lib/dialects/abstract/connection-manager.js"],"sourcesContent":["'use strict';\n\nconst { Pool, TimeoutError } = require('sequelize-pool');\nconst _ = require('lodash');\nconst semver = require('semver');\nconst Promise = require('../../promise');\nconst errors = require('../../errors');\nconst { logger } = require('../../utils/logger');\nconst debug = logger.debugContext('pool');\n\n/**\n * Abstract Connection Manager\n *\n * Connection manager which handles pooling & replication.\n * Uses sequelize-pool for pooling\n *\n * @private\n */\nclass ConnectionManager {\n  constructor(dialect, sequelize) {\n    const config = _.cloneDeep(sequelize.config);\n\n    this.sequelize = sequelize;\n    this.config = config;\n    this.dialect = dialect;\n    this.versionPromise = null;\n    this.dialectName = this.sequelize.options.dialect;\n\n    if (config.pool === false) {\n      throw new Error('Support for pool:false was removed in v4.0');\n    }\n\n    config.pool = _.defaults(config.pool || {}, {\n      max: 5,\n      min: 0,\n      idle: 10000,\n      acquire: 60000,\n      evict: 1000,\n      validate: this._validate.bind(this)\n    });\n\n    this.initPools();\n  }\n\n  refreshTypeParser(dataTypes) {\n    _.each(dataTypes, dataType => {\n      if (Object.prototype.hasOwnProperty.call(dataType, 'parse')) {\n        if (dataType.types[this.dialectName]) {\n          this._refreshTypeParser(dataType);\n        } else {\n          throw new Error(`Parse function not supported for type ${dataType.key} in dialect ${this.dialectName}`);\n        }\n      }\n    });\n  }\n\n  /**\n   * Try to load dialect module from various configured options.\n   * Priority goes like dialectModulePath > dialectModule > require(default)\n   *\n   * @param {string} moduleName Name of dialect module to lookup\n   *\n   * @private\n   * @returns {Object}\n   */\n  _loadDialectModule(moduleName) {\n    try {\n      if (this.sequelize.config.dialectModulePath) {\n        return require(this.sequelize.config.dialectModulePath);\n      }\n      if (this.sequelize.config.dialectModule) {\n        return this.sequelize.config.dialectModule;\n      }\n      // This is needed so that bundlers (like webpack) know which library to include in the bundle\n      switch (moduleName) {\n        case 'pg': return require('pg');\n        case 'mysql2': return require('mysql2');\n        case 'mariadb': return require('mariadb');\n        case 'sqlite3': return require('sqlite3');\n        case 'tedious': return require('tedious');\n        default: return require(moduleName);\n      }\n    } catch (err) {\n      if (err.code === 'MODULE_NOT_FOUND') {\n        if (this.sequelize.config.dialectModulePath) {\n          throw new Error(`Unable to find dialect at ${this.sequelize.config.dialectModulePath}`);\n        }\n        throw new Error(`Please install ${moduleName} package manually`);\n      }\n\n      throw err;\n    }\n  }\n\n  /**\n   * Handler which executes on process exit or connection manager shutdown\n   *\n   * @private\n   * @returns {Promise}\n   */\n  _onProcessExit() {\n    if (!this.pool) {\n      return Promise.resolve();\n    }\n\n    return this.pool.drain().then(() => {\n      debug('connection drain due to process exit');\n      return this.pool.destroyAllNow();\n    });\n  }\n\n  /**\n   * Drain the pool and close it permanently\n   *\n   * @returns {Promise}\n   */\n  close() {\n    // Mark close of pool\n    this.getConnection = function getConnection() {\n      return Promise.reject(new Error('ConnectionManager.getConnection was called after the connection manager was closed!'));\n    };\n\n    return this._onProcessExit();\n  }\n\n  /**\n   * Initialize connection pool. By default pool autostart is set to false, so no connection will be\n   * be created unless `pool.acquire` is called.\n   */\n  initPools() {\n    const config = this.config;\n\n    if (!config.replication) {\n      this.pool = new Pool({\n        name: 'sequelize',\n        create: () => this._connect(config),\n        destroy: connection => {\n          return this._disconnect(connection)\n            .tap(() => { debug('connection destroy'); });\n        },\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      });\n\n      debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, no replication`);\n\n      return;\n    }\n\n    if (!Array.isArray(config.replication.read)) {\n      config.replication.read = [config.replication.read];\n    }\n\n    // Map main connection config\n    config.replication.write = _.defaults(config.replication.write, _.omit(config, 'replication'));\n\n    // Apply defaults to each read config\n    config.replication.read = config.replication.read.map(readConfig =>\n      _.defaults(readConfig, _.omit(this.config, 'replication'))\n    );\n\n    // custom pooling for replication (original author @janmeier)\n    let reads = 0;\n    this.pool = {\n      release: client => {\n        if (client.queryType === 'read') {\n          this.pool.read.release(client);\n        } else {\n          this.pool.write.release(client);\n        }\n      },\n      acquire: (queryType, useMaster) => {\n        useMaster = useMaster === undefined ? false : useMaster;\n        if (queryType === 'SELECT' && !useMaster) {\n          return this.pool.read.acquire();\n        }\n        return this.pool.write.acquire();\n      },\n      destroy: connection => {\n        this.pool[connection.queryType].destroy(connection);\n        debug('connection destroy');\n      },\n      destroyAllNow: () => {\n        return Promise.join(\n          this.pool.read.destroyAllNow(),\n          this.pool.write.destroyAllNow()\n        ).tap(() => { debug('all connections destroyed'); });\n      },\n      drain: () => {\n        return Promise.join(\n          this.pool.write.drain(),\n          this.pool.read.drain()\n        );\n      },\n      read: new Pool({\n        name: 'sequelize:read',\n        create: () => {\n          // round robin config\n          const nextRead = reads++ % config.replication.read.length;\n          return this._connect(config.replication.read[nextRead]).tap(connection => {\n            connection.queryType = 'read';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      }),\n      write: new Pool({\n        name: 'sequelize:write',\n        create: () => {\n          return this._connect(config.replication.write).tap(connection => {\n            connection.queryType = 'write';\n          });\n        },\n        destroy: connection => this._disconnect(connection),\n        validate: config.pool.validate,\n        max: config.pool.max,\n        min: config.pool.min,\n        acquireTimeoutMillis: config.pool.acquire,\n        idleTimeoutMillis: config.pool.idle,\n        reapIntervalMillis: config.pool.evict\n      })\n    };\n\n    debug(`pool created with max/min: ${config.pool.max}/${config.pool.min}, with replication`);\n  }\n\n  /**\n   * Get connection from pool. It sets database version if it's not already set.\n   * Call pool.acquire to get a connection\n   *\n   * @param {Object}   [options]                 Pool options\n   * @param {string}   [options.type]            Set which replica to use. Available options are `read` and `write`\n   * @param {boolean}  [options.useMaster=false] Force master or write replica to get connection from\n   *\n   * @returns {Promise<Connection>}\n   */\n  getConnection(options) {\n    options = options || {};\n\n    let promise;\n    if (this.sequelize.options.databaseVersion === 0) {\n      if (this.versionPromise) {\n        promise = this.versionPromise;\n      } else {\n        promise = this.versionPromise = this._connect(this.config.replication.write || this.config)\n          .then(connection => {\n            const _options = {};\n\n            _options.transaction = { connection }; // Cheat .query to use our private connection\n            _options.logging = () => {};\n            _options.logging.__testLoggingFn = true;\n\n            //connection might have set databaseVersion value at initialization,\n            //avoiding a useless round trip\n            if (this.sequelize.options.databaseVersion === 0) {\n              return this.sequelize.databaseVersion(_options).then(version => {\n                const parsedVersion = _.get(semver.coerce(version), 'version') || version;\n                this.sequelize.options.databaseVersion = semver.valid(parsedVersion)\n                  ? parsedVersion\n                  : this.defaultVersion;\n                this.versionPromise = null;\n                return this._disconnect(connection);\n              });\n            }\n\n            this.versionPromise = null;\n            return this._disconnect(connection);\n          }).catch(err => {\n            this.versionPromise = null;\n            throw err;\n          });\n      }\n    } else {\n      promise = Promise.resolve();\n    }\n\n    return promise.then(() => {\n      return this.pool.acquire(options.type, options.useMaster)\n        .catch(error => {\n          if (error instanceof TimeoutError) throw new errors.ConnectionAcquireTimeoutError(error);\n          throw error;\n        });\n    }).tap(() => { debug('connection acquired'); });\n  }\n\n  /**\n   * Release a pooled connection so it can be utilized by other connection requests\n   *\n   * @param {Connection} connection\n   *\n   * @returns {Promise}\n   */\n  releaseConnection(connection) {\n    return Promise.try(() => {\n      this.pool.release(connection);\n      debug('connection released');\n    });\n  }\n\n  /**\n   * Call dialect library to get connection\n   *\n   * @param {*} config Connection config\n   * @private\n   * @returns {Promise<Connection>}\n   */\n  _connect(config) {\n    return this.sequelize.runHooks('beforeConnect', config)\n      .then(() => this.dialect.connectionManager.connect(config))\n      .then(connection => this.sequelize.runHooks('afterConnect', connection, config).return(connection));\n  }\n\n  /**\n   * Call dialect library to disconnect a connection\n   *\n   * @param {Connection} connection\n   * @private\n   * @returns {Promise}\n   */\n  _disconnect(connection) {\n    return this.sequelize.runHooks('beforeDisconnect', connection)\n      .then(() => this.dialect.connectionManager.disconnect(connection))\n      .then(() => this.sequelize.runHooks('afterDisconnect', connection));\n  }\n\n  /**\n   * Determine if a connection is still valid or not\n   *\n   * @param {Connection} connection\n   *\n   * @returns {boolean}\n   */\n  _validate(connection) {\n    if (!this.dialect.connectionManager.validate) {\n      return true;\n    }\n\n    return this.dialect.connectionManager.validate(connection);\n  }\n}\n\nmodule.exports = ConnectionManager;\nmodule.exports.ConnectionManager = ConnectionManager;\nmodule.exports.default = ConnectionManager;\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}