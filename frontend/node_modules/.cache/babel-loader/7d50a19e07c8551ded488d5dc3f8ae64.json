{"ast":null,"code":"'use strict';\n\nfunction isFunction(funktion) {\n  return typeof funktion === 'function';\n} // Default to complaining loudly when things don't go according to plan.\n\n\nvar logger = console.error.bind(console); // Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\n\nfunction defineProperty(obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name);\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  });\n} // Keep initialization idempotent.\n\n\nfunction shimmer(options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\");else logger = options.logger;\n  }\n}\n\nfunction wrap(nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap');\n    return;\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function');\n    logger(new Error().stack);\n    return;\n  }\n\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions');\n    return;\n  }\n\n  var original = nodule[name];\n  var wrapped = wrapper(original, name);\n  defineProperty(wrapped, '__original', original);\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original);\n  });\n  defineProperty(wrapped, '__wrapped', true);\n  defineProperty(nodule, name, wrapped);\n  return wrapped;\n}\n\nfunction massWrap(nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules');\n    return;\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper);\n    });\n  });\n}\n\nfunction unwrap(nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.');\n    logger(new Error().stack);\n    return;\n  }\n\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?');\n  } else {\n    return nodule[name].__unwrap();\n  }\n}\n\nfunction massUnwrap(nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch');\n    logger(new Error().stack);\n    return;\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules];\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules');\n    return;\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name);\n    });\n  });\n}\n\nshimmer.wrap = wrap;\nshimmer.massWrap = massWrap;\nshimmer.unwrap = unwrap;\nshimmer.massUnwrap = massUnwrap;\nmodule.exports = shimmer;","map":{"version":3,"names":["isFunction","funktion","logger","console","error","bind","defineProperty","obj","name","value","enumerable","propertyIsEnumerable","Object","configurable","writable","shimmer","options","wrap","nodule","wrapper","Error","stack","original","wrapped","massWrap","nodules","names","Array","isArray","forEach","unwrap","__unwrap","massUnwrap","module","exports"],"sources":["/home/brian/node_modules/shimmer/index.js"],"sourcesContent":["'use strict'\n\nfunction isFunction (funktion) {\n  return typeof funktion === 'function'\n}\n\n// Default to complaining loudly when things don't go according to plan.\nvar logger = console.error.bind(console)\n\n// Sets a property on an object, preserving its enumerability.\n// This function assumes that the property is already writable.\nfunction defineProperty (obj, name, value) {\n  var enumerable = !!obj[name] && obj.propertyIsEnumerable(name)\n  Object.defineProperty(obj, name, {\n    configurable: true,\n    enumerable: enumerable,\n    writable: true,\n    value: value\n  })\n}\n\n// Keep initialization idempotent.\nfunction shimmer (options) {\n  if (options && options.logger) {\n    if (!isFunction(options.logger)) logger(\"new logger isn't a function, not replacing\")\n    else logger = options.logger\n  }\n}\n\nfunction wrap (nodule, name, wrapper) {\n  if (!nodule || !nodule[name]) {\n    logger('no original function ' + name + ' to wrap')\n    return\n  }\n\n  if (!wrapper) {\n    logger('no wrapper function')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!isFunction(nodule[name]) || !isFunction(wrapper)) {\n    logger('original object and wrapper must be functions')\n    return\n  }\n\n  var original = nodule[name]\n  var wrapped = wrapper(original, name)\n\n  defineProperty(wrapped, '__original', original)\n  defineProperty(wrapped, '__unwrap', function () {\n    if (nodule[name] === wrapped) defineProperty(nodule, name, original)\n  })\n  defineProperty(wrapped, '__wrapped', true)\n\n  defineProperty(nodule, name, wrapped)\n  return wrapped\n}\n\nfunction massWrap (nodules, names, wrapper) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to wrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      wrap(nodule, name, wrapper)\n    })\n  })\n}\n\nfunction unwrap (nodule, name) {\n  if (!nodule || !nodule[name]) {\n    logger('no function to unwrap.')\n    logger((new Error()).stack)\n    return\n  }\n\n  if (!nodule[name].__unwrap) {\n    logger('no original to unwrap to -- has ' + name + ' already been unwrapped?')\n  } else {\n    return nodule[name].__unwrap()\n  }\n}\n\nfunction massUnwrap (nodules, names) {\n  if (!nodules) {\n    logger('must provide one or more modules to patch')\n    logger((new Error()).stack)\n    return\n  } else if (!Array.isArray(nodules)) {\n    nodules = [nodules]\n  }\n\n  if (!(names && Array.isArray(names))) {\n    logger('must provide one or more functions to unwrap on modules')\n    return\n  }\n\n  nodules.forEach(function (nodule) {\n    names.forEach(function (name) {\n      unwrap(nodule, name)\n    })\n  })\n}\n\nshimmer.wrap = wrap\nshimmer.massWrap = massWrap\nshimmer.unwrap = unwrap\nshimmer.massUnwrap = massUnwrap\n\nmodule.exports = shimmer\n"],"mappings":"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"},"metadata":{},"sourceType":"script"}