{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.serialize = void 0;\n\nconst buffer_writer_1 = require(\"./buffer-writer\");\n\nconst writer = new buffer_writer_1.Writer();\n\nconst startup = opts => {\n  // protocol version\n  writer.addInt16(3).addInt16(0);\n\n  for (const key of Object.keys(opts)) {\n    writer.addCString(key).addCString(opts[key]);\n  }\n\n  writer.addCString('client_encoding').addCString('UTF8');\n  var bodyBuffer = writer.addCString('').flush(); // this message is sent without a code\n\n  var length = bodyBuffer.length + 4;\n  return new buffer_writer_1.Writer().addInt32(length).add(bodyBuffer).flush();\n};\n\nconst requestSsl = () => {\n  const response = Buffer.allocUnsafe(8);\n  response.writeInt32BE(8, 0);\n  response.writeInt32BE(80877103, 4);\n  return response;\n};\n\nconst password = password => {\n  return writer.addCString(password).flush(112\n  /* startup */\n  );\n};\n\nconst sendSASLInitialResponseMessage = function (mechanism, initialResponse) {\n  // 0x70 = 'p'\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse);\n  return writer.flush(112\n  /* startup */\n  );\n};\n\nconst sendSCRAMClientFinalMessage = function (additionalData) {\n  return writer.addString(additionalData).flush(112\n  /* startup */\n  );\n};\n\nconst query = text => {\n  return writer.addCString(text).flush(81\n  /* query */\n  );\n};\n\nconst emptyArray = [];\n\nconst parse = query => {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n  // normalize missing query names to allow for null\n  const name = query.name || '';\n\n  if (name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.');\n    console.error('You supplied %s (%s)', name, name.length);\n    console.error('This can cause conflicts and silent errors executing queries');\n    /* eslint-enable no-console */\n  }\n\n  const types = query.types || emptyArray;\n  var len = types.length;\n  var buffer = writer.addCString(name) // name of query\n  .addCString(query.text) // actual query text\n  .addInt16(len);\n\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(types[i]);\n  }\n\n  return writer.flush(80\n  /* parse */\n  );\n};\n\nconst paramWriter = new buffer_writer_1.Writer();\n\nconst writeValues = function (values, valueMapper) {\n  for (let i = 0; i < values.length; i++) {\n    const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i];\n\n    if (mappedVal == null) {\n      // add the param type (string) to the writer\n      writer.addInt16(0\n      /* STRING */\n      ); // write -1 to the param writer to indicate null\n\n      paramWriter.addInt32(-1);\n    } else if (mappedVal instanceof Buffer) {\n      // add the param type (binary) to the writer\n      writer.addInt16(1\n      /* BINARY */\n      ); // add the buffer to the param writer\n\n      paramWriter.addInt32(mappedVal.length);\n      paramWriter.add(mappedVal);\n    } else {\n      // add the param type (string) to the writer\n      writer.addInt16(0\n      /* STRING */\n      );\n      paramWriter.addInt32(Buffer.byteLength(mappedVal));\n      paramWriter.addString(mappedVal);\n    }\n  }\n};\n\nconst bind = function () {\n  let config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  // normalize config\n  const portal = config.portal || '';\n  const statement = config.statement || '';\n  const binary = config.binary || false;\n  const values = config.values || emptyArray;\n  const len = values.length;\n  writer.addCString(portal).addCString(statement);\n  writer.addInt16(len);\n  writeValues(values, config.valueMapper);\n  writer.addInt16(len);\n  writer.add(paramWriter.flush()); // format code\n\n  writer.addInt16(binary ? 1\n  /* BINARY */\n  : 0\n  /* STRING */\n  );\n  return writer.flush(66\n  /* bind */\n  );\n};\n\nconst emptyExecute = Buffer.from([69\n/* execute */\n, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00]);\n\nconst execute = config => {\n  // this is the happy path for most queries\n  if (!config || !config.portal && !config.rows) {\n    return emptyExecute;\n  }\n\n  const portal = config.portal || '';\n  const rows = config.rows || 0;\n  const portalLength = Buffer.byteLength(portal);\n  const len = 4 + portalLength + 1 + 4; // one extra bit for code\n\n  const buff = Buffer.allocUnsafe(1 + len);\n  buff[0] = 69\n  /* execute */\n  ;\n  buff.writeInt32BE(len, 1);\n  buff.write(portal, 5, 'utf-8');\n  buff[portalLength + 5] = 0; // null terminate portal cString\n\n  buff.writeUInt32BE(rows, buff.length - 4);\n  return buff;\n};\n\nconst cancel = (processID, secretKey) => {\n  const buffer = Buffer.allocUnsafe(16);\n  buffer.writeInt32BE(16, 0);\n  buffer.writeInt16BE(1234, 4);\n  buffer.writeInt16BE(5678, 6);\n  buffer.writeInt32BE(processID, 8);\n  buffer.writeInt32BE(secretKey, 12);\n  return buffer;\n};\n\nconst cstringMessage = (code, string) => {\n  const stringLen = Buffer.byteLength(string);\n  const len = 4 + stringLen + 1; // one extra bit for code\n\n  const buffer = Buffer.allocUnsafe(1 + len);\n  buffer[0] = code;\n  buffer.writeInt32BE(len, 1);\n  buffer.write(string, 5, 'utf-8');\n  buffer[len] = 0; // null terminate cString\n\n  return buffer;\n};\n\nconst emptyDescribePortal = writer.addCString('P').flush(68\n/* describe */\n);\nconst emptyDescribeStatement = writer.addCString('S').flush(68\n/* describe */\n);\n\nconst describe = msg => {\n  return msg.name ? cstringMessage(68\n  /* describe */\n  , `${msg.type}${msg.name || ''}`) : msg.type === 'P' ? emptyDescribePortal : emptyDescribeStatement;\n};\n\nconst close = msg => {\n  const text = `${msg.type}${msg.name || ''}`;\n  return cstringMessage(67\n  /* close */\n  , text);\n};\n\nconst copyData = chunk => {\n  return writer.add(chunk).flush(100\n  /* copyFromChunk */\n  );\n};\n\nconst copyFail = message => {\n  return cstringMessage(102\n  /* copyFail */\n  , message);\n};\n\nconst codeOnlyBuffer = code => Buffer.from([code, 0x00, 0x00, 0x00, 0x04]);\n\nconst flushBuffer = codeOnlyBuffer(72\n/* flush */\n);\nconst syncBuffer = codeOnlyBuffer(83\n/* sync */\n);\nconst endBuffer = codeOnlyBuffer(88\n/* end */\n);\nconst copyDoneBuffer = codeOnlyBuffer(99\n/* copyDone */\n);\nconst serialize = {\n  startup,\n  password,\n  requestSsl,\n  sendSASLInitialResponseMessage,\n  sendSCRAMClientFinalMessage,\n  query,\n  parse,\n  bind,\n  execute,\n  describe,\n  close,\n  flush: () => flushBuffer,\n  sync: () => syncBuffer,\n  end: () => endBuffer,\n  copyData,\n  copyDone: () => copyDoneBuffer,\n  copyFail,\n  cancel\n};\nexports.serialize = serialize;","map":{"version":3,"mappings":"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","names":["writer","buffer_writer_1","startup","opts","addInt16","key","Object","keys","addCString","bodyBuffer","flush","length","addInt32","add","requestSsl","response","Buffer","allocUnsafe","writeInt32BE","password","sendSASLInitialResponseMessage","mechanism","initialResponse","byteLength","addString","sendSCRAMClientFinalMessage","additionalData","query","text","emptyArray","parse","name","console","error","types","len","buffer","i","paramWriter","writeValues","values","valueMapper","mappedVal","bind","config","portal","statement","binary","emptyExecute","from","execute","rows","portalLength","buff","write","writeUInt32BE","cancel","processID","secretKey","writeInt16BE","cstringMessage","code","string","stringLen","emptyDescribePortal","emptyDescribeStatement","describe","msg","type","close","copyData","chunk","copyFail","message","codeOnlyBuffer","flushBuffer","syncBuffer","endBuffer","copyDoneBuffer","serialize","sync","end","copyDone","exports"],"sources":["/home/brian/node_modules/pg-protocol/src/serializer.ts"],"sourcesContent":["import { Writer } from './buffer-writer'\n\nconst enum code {\n  startup = 0x70,\n  query = 0x51,\n  parse = 0x50,\n  bind = 0x42,\n  execute = 0x45,\n  flush = 0x48,\n  sync = 0x53,\n  end = 0x58,\n  close = 0x43,\n  describe = 0x44,\n  copyFromChunk = 0x64,\n  copyDone = 0x63,\n  copyFail = 0x66,\n}\n\nconst writer = new Writer()\n\nconst startup = (opts: Record<string, string>): Buffer => {\n  // protocol version\n  writer.addInt16(3).addInt16(0)\n  for (const key of Object.keys(opts)) {\n    writer.addCString(key).addCString(opts[key])\n  }\n\n  writer.addCString('client_encoding').addCString('UTF8')\n\n  var bodyBuffer = writer.addCString('').flush()\n  // this message is sent without a code\n\n  var length = bodyBuffer.length + 4\n\n  return new Writer().addInt32(length).add(bodyBuffer).flush()\n}\n\nconst requestSsl = (): Buffer => {\n  const response = Buffer.allocUnsafe(8)\n  response.writeInt32BE(8, 0)\n  response.writeInt32BE(80877103, 4)\n  return response\n}\n\nconst password = (password: string): Buffer => {\n  return writer.addCString(password).flush(code.startup)\n}\n\nconst sendSASLInitialResponseMessage = function (mechanism: string, initialResponse: string): Buffer {\n  // 0x70 = 'p'\n  writer.addCString(mechanism).addInt32(Buffer.byteLength(initialResponse)).addString(initialResponse)\n\n  return writer.flush(code.startup)\n}\n\nconst sendSCRAMClientFinalMessage = function (additionalData: string): Buffer {\n  return writer.addString(additionalData).flush(code.startup)\n}\n\nconst query = (text: string): Buffer => {\n  return writer.addCString(text).flush(code.query)\n}\n\ntype ParseOpts = {\n  name?: string\n  types?: number[]\n  text: string\n}\n\nconst emptyArray: any[] = []\n\nconst parse = (query: ParseOpts): Buffer => {\n  // expect something like this:\n  // { name: 'queryName',\n  //   text: 'select * from blah',\n  //   types: ['int8', 'bool'] }\n\n  // normalize missing query names to allow for null\n  const name = query.name || ''\n  if (name.length > 63) {\n    /* eslint-disable no-console */\n    console.error('Warning! Postgres only supports 63 characters for query names.')\n    console.error('You supplied %s (%s)', name, name.length)\n    console.error('This can cause conflicts and silent errors executing queries')\n    /* eslint-enable no-console */\n  }\n\n  const types = query.types || emptyArray\n\n  var len = types.length\n\n  var buffer = writer\n    .addCString(name) // name of query\n    .addCString(query.text) // actual query text\n    .addInt16(len)\n\n  for (var i = 0; i < len; i++) {\n    buffer.addInt32(types[i])\n  }\n\n  return writer.flush(code.parse)\n}\n\ntype ValueMapper = (param: any, index: number) => any\n\ntype BindOpts = {\n  portal?: string\n  binary?: boolean\n  statement?: string\n  values?: any[]\n  // optional map from JS value to postgres value per parameter\n  valueMapper?: ValueMapper\n}\n\nconst paramWriter = new Writer()\n\n// make this a const enum so typescript will inline the value\nconst enum ParamType {\n  STRING = 0,\n  BINARY = 1,\n}\n\nconst writeValues = function (values: any[], valueMapper?: ValueMapper): void {\n  for (let i = 0; i < values.length; i++) {\n    const mappedVal = valueMapper ? valueMapper(values[i], i) : values[i]\n    if (mappedVal == null) {\n      // add the param type (string) to the writer\n      writer.addInt16(ParamType.STRING)\n      // write -1 to the param writer to indicate null\n      paramWriter.addInt32(-1)\n    } else if (mappedVal instanceof Buffer) {\n      // add the param type (binary) to the writer\n      writer.addInt16(ParamType.BINARY)\n      // add the buffer to the param writer\n      paramWriter.addInt32(mappedVal.length)\n      paramWriter.add(mappedVal)\n    } else {\n      // add the param type (string) to the writer\n      writer.addInt16(ParamType.STRING)\n      paramWriter.addInt32(Buffer.byteLength(mappedVal))\n      paramWriter.addString(mappedVal)\n    }\n  }\n}\n\nconst bind = (config: BindOpts = {}): Buffer => {\n  // normalize config\n  const portal = config.portal || ''\n  const statement = config.statement || ''\n  const binary = config.binary || false\n  const values = config.values || emptyArray\n  const len = values.length\n\n  writer.addCString(portal).addCString(statement)\n  writer.addInt16(len)\n\n  writeValues(values, config.valueMapper)\n\n  writer.addInt16(len)\n  writer.add(paramWriter.flush())\n\n  // format code\n  writer.addInt16(binary ? ParamType.BINARY : ParamType.STRING)\n  return writer.flush(code.bind)\n}\n\ntype ExecOpts = {\n  portal?: string\n  rows?: number\n}\n\nconst emptyExecute = Buffer.from([code.execute, 0x00, 0x00, 0x00, 0x09, 0x00, 0x00, 0x00, 0x00, 0x00])\n\nconst execute = (config?: ExecOpts): Buffer => {\n  // this is the happy path for most queries\n  if (!config || (!config.portal && !config.rows)) {\n    return emptyExecute\n  }\n\n  const portal = config.portal || ''\n  const rows = config.rows || 0\n\n  const portalLength = Buffer.byteLength(portal)\n  const len = 4 + portalLength + 1 + 4\n  // one extra bit for code\n  const buff = Buffer.allocUnsafe(1 + len)\n  buff[0] = code.execute\n  buff.writeInt32BE(len, 1)\n  buff.write(portal, 5, 'utf-8')\n  buff[portalLength + 5] = 0 // null terminate portal cString\n  buff.writeUInt32BE(rows, buff.length - 4)\n  return buff\n}\n\nconst cancel = (processID: number, secretKey: number): Buffer => {\n  const buffer = Buffer.allocUnsafe(16)\n  buffer.writeInt32BE(16, 0)\n  buffer.writeInt16BE(1234, 4)\n  buffer.writeInt16BE(5678, 6)\n  buffer.writeInt32BE(processID, 8)\n  buffer.writeInt32BE(secretKey, 12)\n  return buffer\n}\n\ntype PortalOpts = {\n  type: 'S' | 'P'\n  name?: string\n}\n\nconst cstringMessage = (code: code, string: string): Buffer => {\n  const stringLen = Buffer.byteLength(string)\n  const len = 4 + stringLen + 1\n  // one extra bit for code\n  const buffer = Buffer.allocUnsafe(1 + len)\n  buffer[0] = code\n  buffer.writeInt32BE(len, 1)\n  buffer.write(string, 5, 'utf-8')\n  buffer[len] = 0 // null terminate cString\n  return buffer\n}\n\nconst emptyDescribePortal = writer.addCString('P').flush(code.describe)\nconst emptyDescribeStatement = writer.addCString('S').flush(code.describe)\n\nconst describe = (msg: PortalOpts): Buffer => {\n  return msg.name\n    ? cstringMessage(code.describe, `${msg.type}${msg.name || ''}`)\n    : msg.type === 'P'\n    ? emptyDescribePortal\n    : emptyDescribeStatement\n}\n\nconst close = (msg: PortalOpts): Buffer => {\n  const text = `${msg.type}${msg.name || ''}`\n  return cstringMessage(code.close, text)\n}\n\nconst copyData = (chunk: Buffer): Buffer => {\n  return writer.add(chunk).flush(code.copyFromChunk)\n}\n\nconst copyFail = (message: string): Buffer => {\n  return cstringMessage(code.copyFail, message)\n}\n\nconst codeOnlyBuffer = (code: code): Buffer => Buffer.from([code, 0x00, 0x00, 0x00, 0x04])\n\nconst flushBuffer = codeOnlyBuffer(code.flush)\nconst syncBuffer = codeOnlyBuffer(code.sync)\nconst endBuffer = codeOnlyBuffer(code.end)\nconst copyDoneBuffer = codeOnlyBuffer(code.copyDone)\n\nconst serialize = {\n  startup,\n  password,\n  requestSsl,\n  sendSASLInitialResponseMessage,\n  sendSCRAMClientFinalMessage,\n  query,\n  parse,\n  bind,\n  execute,\n  describe,\n  close,\n  flush: () => flushBuffer,\n  sync: () => syncBuffer,\n  end: () => endBuffer,\n  copyData,\n  copyDone: () => copyDoneBuffer,\n  copyFail,\n  cancel,\n}\n\nexport { serialize }\n"]},"metadata":{},"sourceType":"script"}