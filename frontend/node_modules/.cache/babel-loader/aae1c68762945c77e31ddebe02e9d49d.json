{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BufferReader = void 0;\nconst emptyBuffer = Buffer.allocUnsafe(0);\n\nclass BufferReader {\n  constructor() {\n    let offset = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.offset = offset;\n    this.buffer = emptyBuffer; // TODO(bmc): support non-utf8 encoding?\n\n    this.encoding = 'utf-8';\n  }\n\n  setBuffer(offset, buffer) {\n    this.offset = offset;\n    this.buffer = buffer;\n  }\n\n  int16() {\n    const result = this.buffer.readInt16BE(this.offset);\n    this.offset += 2;\n    return result;\n  }\n\n  byte() {\n    const result = this.buffer[this.offset];\n    this.offset++;\n    return result;\n  }\n\n  int32() {\n    const result = this.buffer.readInt32BE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n\n  string(length) {\n    const result = this.buffer.toString(this.encoding, this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  }\n\n  cstring() {\n    const start = this.offset;\n    let end = start;\n\n    while (this.buffer[end++] !== 0) {}\n\n    this.offset = end;\n    return this.buffer.toString(this.encoding, start, end - 1);\n  }\n\n  bytes(length) {\n    const result = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return result;\n  }\n\n}\n\nexports.BufferReader = BufferReader;","map":{"version":3,"mappings":";;;;;;AAAA,MAAMA,WAAW,GAAGC,MAAM,CAACC,WAAP,CAAmB,CAAnB,CAApB;;AAEA,MAAaC,YAAb,CAAyB;EAMvBC,cAAsC;IAAA,IAAlBC,MAAkB,uEAAD,CAAC;IAAlB;IALZ,cAAiBL,WAAjB,CAK8B,CAHtC;;IACQ,gBAAmB,OAAnB;EAEkC;;EAEnCM,SAAS,CAACD,MAAD,EAAiBE,MAAjB,EAA+B;IAC7C,KAAKF,MAAL,GAAcA,MAAd;IACA,KAAKE,MAAL,GAAcA,MAAd;EACD;;EAEMC,KAAK;IACV,MAAMC,MAAM,GAAG,KAAKF,MAAL,CAAYG,WAAZ,CAAwB,KAAKL,MAA7B,CAAf;IACA,KAAKA,MAAL,IAAe,CAAf;IACA,OAAOI,MAAP;EACD;;EAEME,IAAI;IACT,MAAMF,MAAM,GAAG,KAAKF,MAAL,CAAY,KAAKF,MAAjB,CAAf;IACA,KAAKA,MAAL;IACA,OAAOI,MAAP;EACD;;EAEMG,KAAK;IACV,MAAMH,MAAM,GAAG,KAAKF,MAAL,CAAYM,WAAZ,CAAwB,KAAKR,MAA7B,CAAf;IACA,KAAKA,MAAL,IAAe,CAAf;IACA,OAAOI,MAAP;EACD;;EAEMK,MAAM,CAACC,MAAD,EAAe;IAC1B,MAAMN,MAAM,GAAG,KAAKF,MAAL,CAAYS,QAAZ,CAAqB,KAAKC,QAA1B,EAAoC,KAAKZ,MAAzC,EAAiD,KAAKA,MAAL,GAAcU,MAA/D,CAAf;IACA,KAAKV,MAAL,IAAeU,MAAf;IACA,OAAON,MAAP;EACD;;EAEMS,OAAO;IACZ,MAAMC,KAAK,GAAG,KAAKd,MAAnB;IACA,IAAIe,GAAG,GAAGD,KAAV;;IACA,OAAO,KAAKZ,MAAL,CAAYa,GAAG,EAAf,MAAuB,CAA9B,EAAiC,CAAE;;IACnC,KAAKf,MAAL,GAAce,GAAd;IACA,OAAO,KAAKb,MAAL,CAAYS,QAAZ,CAAqB,KAAKC,QAA1B,EAAoCE,KAApC,EAA2CC,GAAG,GAAG,CAAjD,CAAP;EACD;;EAEMC,KAAK,CAACN,MAAD,EAAe;IACzB,MAAMN,MAAM,GAAG,KAAKF,MAAL,CAAYe,KAAZ,CAAkB,KAAKjB,MAAvB,EAA+B,KAAKA,MAAL,GAAcU,MAA7C,CAAf;IACA,KAAKV,MAAL,IAAeU,MAAf;IACA,OAAON,MAAP;EACD;;AAjDsB;;AAAzBc","names":["emptyBuffer","Buffer","allocUnsafe","BufferReader","constructor","offset","setBuffer","buffer","int16","result","readInt16BE","byte","int32","readInt32BE","string","length","toString","encoding","cstring","start","end","bytes","slice","exports"],"sources":["/home/brian/node_modules/pg-protocol/src/buffer-reader.ts"],"sourcesContent":["const emptyBuffer = Buffer.allocUnsafe(0)\n\nexport class BufferReader {\n  private buffer: Buffer = emptyBuffer\n\n  // TODO(bmc): support non-utf8 encoding?\n  private encoding: string = 'utf-8'\n\n  constructor(private offset: number = 0) {}\n\n  public setBuffer(offset: number, buffer: Buffer): void {\n    this.offset = offset\n    this.buffer = buffer\n  }\n\n  public int16(): number {\n    const result = this.buffer.readInt16BE(this.offset)\n    this.offset += 2\n    return result\n  }\n\n  public byte(): number {\n    const result = this.buffer[this.offset]\n    this.offset++\n    return result\n  }\n\n  public int32(): number {\n    const result = this.buffer.readInt32BE(this.offset)\n    this.offset += 4\n    return result\n  }\n\n  public string(length: number): string {\n    const result = this.buffer.toString(this.encoding, this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n\n  public cstring(): string {\n    const start = this.offset\n    let end = start\n    while (this.buffer[end++] !== 0) {}\n    this.offset = end\n    return this.buffer.toString(this.encoding, start, end - 1)\n  }\n\n  public bytes(length: number): Buffer {\n    const result = this.buffer.slice(this.offset, this.offset + length)\n    this.offset += length\n    return result\n  }\n}\n"]},"metadata":{},"sourceType":"script"}